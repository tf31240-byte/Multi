<!DOCTYPE html>

<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="theme-color" content="#007AFF" media="(prefers-color-scheme: light)">
    <meta name="theme-color" content="#0A84FF" media="(prefers-color-scheme: dark)">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="ScoreMaster">
    <meta name="description" content="Gestionnaire de scores pour belote, coinche et jeux de cartes avec statistiques avanc√©es">
    <meta name="keywords" content="belote, coinche, score, cartes, jeu, statistiques">

<!-- PWA Manifest -->
<link rel="manifest" href="manifest.json">

<!-- Apple Touch Icons -->
<link rel="apple-touch-icon" href="icon-180.png">
<link rel="apple-touch-icon" sizes="180x180" href="icon-180.png">
<link rel="apple-touch-icon" sizes="192x192" href="icon-192.png">
<link rel="apple-touch-icon" sizes="512x512" href="icon-512.png">

<!-- Favicon -->
<link rel="icon" type="image/png" sizes="192x192" href="icon-192.png">
<link rel="icon" type="image/png" sizes="512x512" href="icon-512.png">

<title>ScoreMaster</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/gifshot@0.4.5/dist/gifshot.min.js"></script>
<style>
    /* --- VARIABLES & THEME --- */
    :root {
        --primary: #007AFF; --bg: #F5F5F7; --card: #FFFFFF; --text: #1D1D1F;
        --text-sec: #86868B; --border: #E5E5EA; --dealer: #FF9500; 
        --danger: #FF3B30; --success: #34C759; 
        
        /* Glassmorphism Vars */
        --glass-bg: rgba(255, 255, 255, 0.65);
        --glass-border: rgba(255, 255, 255, 0.5);
        --glass-shadow: 0 15px 35px rgba(0,0,0,0.1), 0 5px 15px rgba(0,0,0,0.05);
        --glass-blur: 20px;
        
        /* Gradients */
        --bg-gradient: radial-gradient(circle at 50% 0%, #ffffff, #F5F5F7);
    }
    :root[data-theme="dark"] {
        --primary: #0A84FF; --bg: #000000; --card: #1C1C1E; --text: #F5F5F7;
        --text-sec: #98989D; --border: #38383A; 
        
        --glass-bg: rgba(28, 28, 30, 0.65);
        --glass-border: rgba(255, 255, 255, 0.1);
        --glass-shadow: 0 15px 35px rgba(0,0,0,0.4), 0 5px 15px rgba(0,0,0,0.2);
        
        --bg-gradient: radial-gradient(circle at 50% 0%, #2c2c2e, #000000);
    }
    @media (prefers-color-scheme: dark) {
        :root:not([data-theme="light"]) {
            --primary: #0A84FF; --bg: #000000; --card: #1C1C1E; --text: #F5F5F7;
            --text-sec: #98989D; --border: #38383A; 
            --glass-bg: rgba(28, 28, 30, 0.65);
            --glass-border: rgba(255, 255, 255, 0.1);
            --glass-shadow: 0 15px 35px rgba(0,0,0,0.4), 0 5px 15px rgba(0,0,0,0.2);
            --bg-gradient: radial-gradient(circle at 50% 0%, #2c2c2e, #000000);
        }
    }
    * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-family: -apple-system, system-ui, sans-serif; }
    
    html {
        height: -webkit-fill-available;
    }
    
    body { 
        margin: 0; 
        background: var(--bg);
        background-attachment: fixed;
        color: var(--text); 
        padding-bottom: calc(140px + env(safe-area-inset-bottom)); 
        transition: background 0.3s;
        min-height: 100vh;
        min-height: -webkit-fill-available;
    }
    
    body::before {
        content: '';
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: var(--bg-gradient);
        z-index: -1;
    }
    
    .container { 
        max-width: 600px; 
        margin: 0 auto; 
        padding: 20px; 
        padding-top: max(20px, env(safe-area-inset-top)); 
        animation: slideIn 0.4s ease-out; 
        position: relative; 
        z-index: 1; 
    }
    .hidden { display: none !important; }
    
    /* Typography Helpers */
    .text-huge { font-size: 28px; font-weight: 900; }
    .text-center { text-align: center; }

    /* --- ANIMATIONS --- */
    @keyframes slideIn { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }
    @keyframes rankPop { 0% { transform: scale(1); } 50% { transform: scale(1.1); } 100% { transform: scale(1); } }
    @keyframes badgeBounce { 0%, 100% { transform: scale(1) rotate(0deg); } 25% { transform: scale(1.3) rotate(-10deg); } 75% { transform: scale(1.3) rotate(10deg); } }
    @keyframes scoreBump { 0% { transform: scale(1); } 50% { transform: scale(1.15); } 100% { transform: scale(1); } }
    @keyframes victoryPop { 0% { transform: scale(0.8); opacity: 0; } 100% { transform: scale(1); opacity: 1; } }
    
    /* === NOUVELLES ANIMATIONS AM√âLIOR√âES === */
    @keyframes zenFadeIn {
        0% { opacity: 0; transform: scale(0.95); }
        100% { opacity: 1; transform: scale(1); }
    }
    @keyframes zenFadeOut {
        0% { opacity: 1; transform: scale(1); }
        100% { opacity: 0; transform: scale(0.95); }
    }
    @keyframes podiumEntrance {
        0% { transform: translateY(150px) scale(0.5); opacity: 0; }
        60% { transform: translateY(-20px) scale(1.1); opacity: 1; }
        80% { transform: translateY(10px) scale(0.95); }
        100% { transform: translateY(0) scale(1); opacity: 1; }
    }
    @keyframes crownFloat {
        0%, 100% { transform: translateY(0) rotate(0deg); }
        25% { transform: translateY(-8px) rotate(-5deg); }
        75% { transform: translateY(-8px) rotate(5deg); }
    }
    @keyframes podiumGlow {
        0%, 100% { box-shadow: 0 0 20px rgba(255, 215, 0, 0.3); }
        50% { box-shadow: 0 0 40px rgba(255, 215, 0, 0.6), 0 0 60px rgba(255, 215, 0, 0.3); }
    }
    @keyframes spinPulse {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }
    
    /* === INDICATEUR DE CHARGEMENT === */
    .loading-overlay {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.7);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        z-index: 10000;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.3s ease;
    }
    .loading-overlay.active {
        opacity: 1;
        pointer-events: auto;
    }
    .loading-spinner {
        width: 60px;
        height: 60px;
        border: 4px solid var(--glass-border);
        border-top-color: var(--primary);
        border-radius: 50%;
        animation: spinPulse 1s linear infinite;
    }
    .loading-text {
        margin-top: 20px;
        font-size: 16px;
        font-weight: 700;
        color: white;
        text-align: center;
    }
    .loading-progress {
        margin-top: 10px;
        font-size: 24px;
        font-weight: 900;
        color: var(--primary);
    }

    /* --- GLASSMORPHISM COMPONENTS --- */
    .modal-overlay { 
        position: fixed; inset: 0; 
        background: rgba(0,0,0,0.5); 
        backdrop-filter: blur(8px); 
        -webkit-backdrop-filter: blur(8px);
        z-index: 4000; 
        display: flex; 
        align-items: center; 
        justify-content: center; 
        padding: 20px; 
        opacity: 0; 
        pointer-events: none; 
        transition: 0.2s; 
    }
    .modal-overlay.active { opacity: 1; pointer-events: auto; }
    
    .modal-box, .sheet-content, .victory-box { 
        background: var(--glass-bg);
        backdrop-filter: blur(var(--glass-blur)) saturate(180%);
        -webkit-backdrop-filter: blur(var(--glass-blur)) saturate(180%);
        border: 1px solid var(--glass-border);
        box-shadow: var(--glass-shadow);
    }

    .modal-box { 
        width: 100%; max-width: 340px; border-radius: 28px; padding: 25px; text-align: center; 
        position: relative;
    }
    .modal-box.large { max-width: 500px; text-align: left; max-height: 80vh; overflow-y: auto; }
    
    /* === GRILLE DE PR√âS√âLECTION (iOS App Store Style) === */
    .preset-modal {
        z-index: 4500;
    }
    .preset-modal .modal-box {
        max-width: 420px;
        padding: 0;
        overflow: hidden;
    }
    .preset-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 20px 20px 15px;
        border-bottom: 1px solid var(--border);
    }
    .preset-header h2 {
        margin: 0;
        font-size: 20px;
        font-weight: 900;
    }
    .preset-close {
        width: 32px;
        height: 32px;
        border-radius: 50%;
        background: var(--border);
        border: none;
        font-size: 16px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        color: var(--text);
        transition: all 0.2s;
    }
    .preset-close:active {
        transform: scale(0.9);
        background: var(--text-sec);
        color: white;
    }
    .preset-edit-btn {
        width: 32px;
        height: 32px;
        border-radius: 50%;
        background: transparent;
        border: none;
        font-size: 16px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        color: var(--text);
        transition: all 0.2s;
    }
    .preset-edit-btn:active {
        transform: scale(0.9);
    }
    .preset-edit-btn.active {
        background: var(--danger);
    }
    .presets-grid {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 12px;
        padding: 15px 20px 20px;
        max-height: 60vh;
        overflow-y: auto;
    }
    @media (min-width: 420px) {
        .presets-grid {
            grid-template-columns: repeat(3, 1fr);
        }
    }
    .preset-card {
        background: var(--card);
        border: 2px solid var(--border);
        border-radius: 18px;
        padding: 16px 12px;
        text-align: center;
        cursor: pointer;
        transition: all 0.15s ease;
        position: relative;
        overflow: hidden;
    }
    .preset-card::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 3px;
        background: linear-gradient(90deg, var(--primary), var(--accent));
        opacity: 0;
        transition: opacity 0.2s;
    }
    .preset-card:active {
        transform: scale(0.95);
        background: var(--primary);
        border-color: var(--primary);
    }
    .preset-card:active::before {
        opacity: 1;
    }
    .preset-card:active .preset-icon,
    .preset-card:active .preset-name,
    .preset-card:active .preset-tag {
        color: white;
    }
    .preset-card:active .preset-tag {
        opacity: 0.8;
    }
    .preset-icon {
        font-size: 36px;
        display: block;
        margin-bottom: 8px;
        line-height: 1;
    }
    .preset-name {
        font-weight: 800;
        font-size: 13px;
        color: var(--text);
        display: block;
        line-height: 1.2;
    }
    .preset-tag {
        font-size: 10px;
        color: var(--text-sec);
        display: block;
        margin-top: 4px;
        font-weight: 600;
    }
    /* Carte sp√©ciale "Personnaliser" */
    .preset-card.custom {
        background: linear-gradient(135deg, var(--card) 0%, var(--border) 100%);
        border-style: dashed;
    }
    .preset-card.custom .preset-icon {
        font-size: 28px;
        opacity: 0.7;
    }
    /* Section favoris */
    .preset-section-title {
        grid-column: 1 / -1;
        font-size: 11px;
        font-weight: 800;
        color: var(--text-sec);
        text-transform: uppercase;
        letter-spacing: 0.5px;
        margin-top: 8px;
        margin-bottom: 4px;
    }
    .preset-section-title:first-child {
        margin-top: 0;
    }
    /* Animation d'apparition */
    @keyframes presetSlideIn {
        from {
            opacity: 0;
            transform: translateY(10px);
        }
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }
    .preset-card {
        animation: presetSlideIn 0.3s ease forwards;
        opacity: 0;
    }
    .preset-card:nth-child(1) { animation-delay: 0.05s; }
    .preset-card:nth-child(2) { animation-delay: 0.1s; }
    .preset-card:nth-child(3) { animation-delay: 0.15s; }
    .preset-card:nth-child(4) { animation-delay: 0.2s; }
    .preset-card:nth-child(5) { animation-delay: 0.25s; }
    .preset-card:nth-child(6) { animation-delay: 0.3s; }
    .preset-card:nth-child(7) { animation-delay: 0.35s; }
    .preset-card:nth-child(8) { animation-delay: 0.4s; }
    .preset-card:nth-child(9) { animation-delay: 0.45s; }
    .preset-card:nth-child(10) { animation-delay: 0.5s; }
    
    /* Emoji selector */
    .emoji-option {
        width: 44px;
        height: 44px;
        border: 2px solid var(--border);
        border-radius: 12px;
        background: var(--card);
        font-size: 22px;
        cursor: pointer;
        transition: all 0.15s;
        display: flex;
        align-items: center;
        justify-content: center;
    }
    .emoji-option:active, .emoji-option.selected {
        background: var(--primary);
        border-color: var(--primary);
        transform: scale(1.1);
    }
    .emoji-option.emoji-add {
        font-size: 28px;
        font-weight: 700;
        color: var(--text-sec);
        border-style: dashed;
    }
    .emoji-option.emoji-add:active, .emoji-option.emoji-add.selected {
        color: white;
    }
    
    /* Delete button on preset cards */
    .preset-delete {
        position: absolute;
        top: -6px;
        right: -6px;
        width: 24px;
        height: 24px;
        border-radius: 50%;
        background: var(--danger);
        color: white;
        border: 2px solid var(--bg);
        font-size: 12px;
        font-weight: 900;
        cursor: pointer;
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 10;
        transition: transform 0.15s;
    }
    .preset-delete:active {
        transform: scale(0.9);
    }
    /* Mode √©dition : afficher tous les boutons supprimer */
    .presets-grid.edit-mode .preset-delete {
        display: flex;
    }
    .presets-grid.edit-mode .preset-card {
        cursor: default;
    }
    /* D√©sactiver le clic sur la carte en mode √©dition */
    .preset-card .preset-icon,
    .preset-card .preset-name,
    .preset-card .preset-tag {
        pointer-events: none;
    }
    
    /* Bouton restaurer les jeux masqu√©s */
    .preset-restore-btn {
        grid-column: 1 / -1;
        padding: 12px;
        background: transparent;
        border: 2px dashed var(--border);
        border-radius: 12px;
        color: var(--text-sec);
        font-size: 13px;
        font-weight: 700;
        cursor: pointer;
        transition: all 0.2s;
        margin-top: 8px;
    }
    .preset-restore-btn:active {
        background: var(--card);
        border-style: solid;
    }
    
    /* Suggestions de joueurs r√©cents */
    .modal-player-wrapper { 
        position: relative; 
        display: flex;
        flex-direction: column;
        align-items: center;
    }
    .recent-suggestions {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 8px;
        margin-top: 16px;
        padding: 12px;
        background: var(--glass-bg);
        backdrop-filter: blur(10px);
        border-radius: 16px;
        border: 1px solid var(--glass-border);
    }
    .recent-suggestion-item {
        display: flex;
        align-items: center;
        gap: 8px;
        background: var(--card);
        border: 1px solid var(--border);
        border-radius: 12px;
        padding: 10px 14px;
        font-size: 13px;
        font-weight: 700;
        color: var(--text);
        cursor: pointer;
        white-space: nowrap;
        transition: all 0.2s ease;
    }
    .recent-suggestion-item:active {
        background: var(--primary);
        color: white;
        border-color: var(--primary);
        transform: scale(0.95);
    }
    .recent-suggestion-item .add-icon {
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: var(--success);
        color: white;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 14px;
        font-weight: 900;
        flex-shrink: 0;
    }
    .recent-suggestion-item:active .add-icon {
        background: white;
        color: var(--primary);
    }
    .recent-suggestions-title {
        width: 100%;
        text-align: center;
        font-size: 11px;
        font-weight: 800;
        color: var(--text-sec);
        text-transform: uppercase;
        letter-spacing: 0.5px;
        margin-bottom: 8px;
    }
    
    /* Sur grand √©cran : afficher √† droite */
    @media (min-width: 700px) {
        .modal-player-wrapper {
            flex-direction: row;
            align-items: flex-start;
        }
        .recent-suggestions {
            position: absolute;
            left: calc(50% + 180px);
            top: 0;
            margin-top: 0;
            flex-direction: column;
            flex-wrap: nowrap;
            justify-content: flex-start;
        }
        .recent-suggestion-item:hover {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
            transform: translateX(-4px);
            box-shadow: 0 6px 20px rgba(0,122,255,0.3);
        }
        .recent-suggestion-item:hover .add-icon {
            background: white;
            color: var(--primary);
        }
    }
    .sheet-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.2); z-index: 3000; opacity: 0; pointer-events: none; transition: 0.3s; display: flex; align-items: flex-end; }
    .sheet-overlay.active { opacity: 1; pointer-events: auto; }
    .sheet-content { 
        width: 100%; border-radius: 35px 35px 0 0; padding: 25px 20px calc(25px + env(safe-area-inset-bottom)); 
        transform: translateY(100%); transition: 0.4s cubic-bezier(0.1, 0.9, 0.2, 1);
    }
    .sheet-overlay.active .sheet-content { transform: translateY(0); }

    /* --- UI ELEMENTS --- */
    .header-controls { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; }
    .theme-toggle, .btn-stats, .btn-focus { 
        background: var(--glass-bg);
        backdrop-filter: blur(10px);
        border: 1px solid var(--glass-border); 
        width: 44px; height: 44px; border-radius: 12px; font-size: 20px; cursor: pointer; transition: all 0.3s; display:flex; align-items:center; justify-content:center; box-shadow: 0 4px 10px rgba(0,0,0,0.05);
    }
    .btn-stats:active, .theme-toggle:active, .btn-focus:active { transform: scale(0.9); }
    .btn-stats { color:var(--primary); }
    .btn-focus { color: var(--primary); }

    .welcome-title { font-size: 42px; font-weight: 900; text-align: center; margin-top: 40px; letter-spacing: -2px; background: linear-gradient(120deg, var(--text), var(--primary)); -webkit-background-clip: text; -webkit-text-fill-color: transparent;}

    .mode-btn { background: var(--card); border: 1px solid var(--border); border-radius: 24px; padding: 20px; margin-bottom: 12px; box-shadow: 0 4px 15px rgba(0,0,0,0.05); cursor: pointer; display: flex; align-items: center; gap: 15px; transition: all 0.2s; }
    .mode-btn:hover { transform: translateY(-2px); box-shadow: 0 10px 25px rgba(0,0,0,0.1); }
    .mode-btn:active { transform: translateY(0); }

    .guide-container { margin-top: 30px; background: var(--card); border-radius: 24px; padding: 20px; border: 1px solid var(--border); font-size: 13px; color: var(--text-sec); }

    .game-item { background: var(--card); border: 1px solid var(--border); border-radius: 20px; padding: 16px; margin-bottom: 12px; cursor: pointer; display: flex; justify-content: space-between; align-items: center; transition: all 0.2s; }
    .game-item:hover { border-color: var(--primary); transform: translateX(4px); box-shadow: 0 5px 15px rgba(0,0,0,0.05); }
    .game-mode-badge { display: inline-block; padding: 3px 8px; border-radius: 8px; font-size: 10px; font-weight: 900; margin-left: 8px; }
    .badge-belote { background: #FF9500; color: white; }
    .badge-standard { background: #007AFF; color: white; }
    .game-players-list { display: flex; gap: 8px; margin-top: 8px; flex-wrap: wrap; }
    .game-player-score { font-size: 11px; padding: 4px 8px; border-radius: 8px; font-weight: 700; }
    .game-actions { display: flex; gap: 8px; }
    .game-actions button { background: none; border: none; font-size: 18px; padding: 8px; cursor: pointer; transition: transform 0.2s; }
    .game-actions button:active { transform: scale(0.9); }

    .chart-box { background: var(--glass-bg); backdrop-filter: blur(10px); border-radius: 24px; padding: 15px; height: 200px; margin-bottom: 25px; border: 1px solid var(--border); box-shadow: 0 5px 15px rgba(0,0,0,0.05); transition: opacity 0.5s ease; }
    
    .players-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(130px, 1fr)); gap: 14px; margin-bottom: 30px; transition: all 0.5s cubic-bezier(0.34, 1.56, 0.64, 1); }
    
    .p-card { background: var(--card); padding: 22px 10px; border-radius: 26px; text-align: center; position: relative; border: 3px solid transparent; box-shadow: 0 8px 20px rgba(0,0,0,0.05); transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1), border-color 0.3s; overflow: visible; }
    .p-card.is-dealer { border-color: var(--dealer); }
    .p-card.rank-change { animation: rankPop 0.6s cubic-bezier(0.34, 1.56, 0.64, 1); }
    
    .rank-badge { position: absolute; top: -12px; left: 12px; font-size: 13px; padding: 4px 10px; border-radius: 12px; font-weight: 900; color: white; box-shadow: 0 4px 8px rgba(0,0,0,0.2); transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1); z-index: 10; }
    .rank-badge.bounce { animation: badgeBounce 0.6s cubic-bezier(0.34, 1.56, 0.64, 1); }

    /* Afficher les badges en mode Zen avec style adapt√© */
    .focus-mode .rank-badge {
        top: 8px;
        left: 8px;
        font-size: 16px;
        padding: 4px 8px;
    }

    /* Ajuster les cartes en mode Zen pour que le nom soit visible et le score temp pas coup√© */
    .focus-mode .p-card {
        padding: 12px 8px 22px 8px;
        overflow: visible;
    }
    
    .focus-mode .p-name-btn {
        font-size: 11px;
        margin-bottom: 6px;
        margin-top: 24px;
        padding: 3px 8px;
    }
    
    .focus-mode .p-score {
        font-size: 38px;
    }
    
    .focus-mode .p-temp {
        font-size: 13px;
        margin-top: 4px;
    }
    
    .badge-1 { background: #FFD700; }
    .badge-2 { background: #C0C0C0; }
    .badge-3 { background: #CD7F32; }
    .badge-none { background: var(--text-sec); opacity: 0.5; }

    .p-name-btn { font-size: 12px; font-weight: 900; text-transform: uppercase; cursor: pointer; display: inline-block; padding: 4px 10px; border: 1px solid var(--border); border-radius: 10px; margin-bottom: 8px; }
    .p-score { font-size: 44px; font-weight: 900; cursor: pointer; line-height: 1; letter-spacing: -2px; transition: transform 0.2s ease-out; }
    .p-score.score-bump { animation: scoreBump 0.4s ease-out; }
    .p-temp { font-size: 15px; font-weight: 800; color: var(--primary); min-height: 18px; margin-top: 6px; }

    .h-row { background: var(--card); padding: 12px; border-radius: 18px; display: flex; align-items: center; margin-bottom: 8px; border: 1px solid var(--border); gap: 10px; overflow-x: auto; transition: opacity 0.5s ease; }
    .h-idx { font-size: 10px; font-weight: 900; color: var(--text-sec); min-width: 30px; flex-shrink: 0; }
    .h-scores { display: flex; flex: 1; justify-content: space-between; align-items: center; min-width: max-content; padding-right: 5px; cursor: pointer; }
    .h-score-item { text-align: center; min-width: 50px; padding: 0 5px; }

    .sel-box { 
        background: var(--card); 
        padding: 12px; 
        border-radius: 18px; 
        text-align: center; 
        flex: 1; 
        border: 3px solid transparent; 
        min-width: 80px; 
        transition: transform 0.2s cubic-bezier(0.34, 1.56, 0.64, 1), border-color 0.2s; 
        position: relative;
        z-index: 1;
        margin-bottom: 0;
    }
    .sel-box.active { 
        border-color: var(--p-color); 
        transform: scale(1.04);
        box-shadow: 0 5px 15px rgba(0,0,0,0.05);
        z-index: 2;
    }
    .numpad { display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; }
    .btn-nb { background: var(--card); border: none; height: 58px; border-radius: 16px; font-size: 22px; font-weight: 700; color: var(--text); box-shadow: 0 3px 0 var(--border); cursor: pointer; }
    .btn-nb:active { transform: translateY(3px); box-shadow: none; }

    .dock { 
        position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%); width: 90%; max-width: 450px; z-index: 2000; 
        background: var(--glass-bg);
        backdrop-filter: blur(25px) saturate(200%);
        -webkit-backdrop-filter: blur(25px) saturate(200%);
        border: 1px solid var(--glass-border);
        box-shadow: var(--glass-shadow);
        border-radius: 26px;
        transition: opacity 0.5s ease;
    }
    .btn-main { width: 100%; background: var(--text); color: var(--bg); border: none; padding: 20px; border-radius: 20px; font-size: 16px; font-weight: 900; box-shadow: 0 5px 15px rgba(0,0,0,0.1); cursor: pointer; transition: transform 0.1s; }
    .btn-main:active { transform: scale(0.98); }
    .btn-main.editing { background: var(--dealer); color: #000; }


/* ‚Äî OVERLAY FOND MODE ZEN ‚Äî */
/* Overlay zen SUPPRIM√â - pas n√©cessaire */

    /* === TRANSITIONS DOUCES MODE ZEN === */
    .focus-mode #dock {
        opacity: 1 !important;
        pointer-events: auto !important;
        transform: translateX(-50%) !important;
        z-index: 200;
        animation: dockSlideUp 1s cubic-bezier(0.34, 1.56, 0.64, 1) 0.4s backwards;
    }
    
    /* Transition douce pour les cartes en mode Zen */
    .p-card {
        transition: all 0.6s cubic-bezier(0.34, 1.56, 0.64, 1);
    }
    
    .focus-mode .p-card {
        transition: all 0.8s cubic-bezier(0.34, 1.56, 0.64, 1);
    }
    
    /* Transition pour le bouton focus */
    .btn-focus {
        transition: all 0.6s cubic-bezier(0.34, 1.56, 0.64, 1);
    }
    
    .focus-mode .btn-focus {
        transition: all 0.6s cubic-bezier(0.34, 1.56, 0.64, 1);
    }

    @keyframes dockSlideUp {
        0% { opacity: 0; transform: translateX(-50%) translateY(80px); }
        100% { opacity: 1; transform: translateX(-50%) translateY(0); }
    }


/* ‚Äî LE BOUTON OEIL EN MODE ZEN ‚Äî */
.focus-mode .btn-focus {
position: fixed;
top: max(15px, env(safe-area-inset-top));
right: 15px;
z-index: 2000;
background: var(--card);
border: 1px solid var(--primary);
color: var(--primary);
box-shadow: 0 5px 15px rgba(0,0,0,0.2);
transform: scale(1.1);
}

.focus-mode header > *:not(.btn-focus) {
opacity: 0;
pointer-events: none;
}

/* Masquer les √©l√©ments non essentiels en mode Zen */
.focus-mode .chart-box,
.focus-mode #history,
.focus-mode #history-header {
opacity: 0;
pointer-events: none;
position: absolute;
}

/* ‚Äî CORRECTION DE LA GRILLE (Plus de fond noir vide) ‚Äî */
.focus-mode .players-grid {
position: fixed;
top: 0;
left: 0;
width: 100%;
height: 100vh;
height: 100dvh;
padding: max(20px, env(safe-area-inset-top)) 15px calc(100px + env(safe-area-inset-bottom)) 15px;
margin: 0;
display: grid;
grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
align-content: center;
gap: 15px;
z-index: 100;
transform: none !important;
opacity: 1 !important;
animation: zenGridFadeIn 0.8s cubic-bezier(0.34, 1.56, 0.64, 1) backwards;
overflow-y: auto;
-webkit-overflow-scrolling: touch;
}

@keyframes zenGridFadeIn {
0% { opacity: 0; transform: scale(0.95); }
100% { opacity: 1; transform: scale(1); }
}

.focus-mode .p-card {
display: flex;
flex-direction: column;
justify-content: center;
align-items: center;
height: 100%;
min-height: 140px;
padding: 20px;
box-shadow: 0 10px 40px rgba(0,0,0,0.15);
border-width: 0;
background: var(--card);
animation: none !important;
transition: none !important;
}

@keyframes zenCardFadeIn {
0% { opacity: 0; transform: translateY(30px) scale(0.9); }
100% { opacity: 1; transform: translateY(0) scale(1); }
}

/* Animation UNIQUEMENT √† l'ouverture du mode zen */
.focus-mode .players-grid .p-card {
animation: zenCardFadeIn 0.6s cubic-bezier(0.34, 1.56, 0.64, 1) backwards;
}
.focus-mode .players-grid .p-card:nth-child(1) { animation-delay: 0.05s; }
.focus-mode .players-grid .p-card:nth-child(2) { animation-delay: 0.1s; }
.focus-mode .players-grid .p-card:nth-child(3) { animation-delay: 0.15s; }
.focus-mode .players-grid .p-card:nth-child(4) { animation-delay: 0.2s; }
.focus-mode .players-grid .p-card:nth-child(5) { animation-delay: 0.25s; }
.focus-mode .players-grid .p-card:nth-child(6) { animation-delay: 0.3s; }

/* D√©sactiver toutes les animations apr√®s l'ouverture */
.focus-mode .p-card.rank-change { animation: none !important; }
.focus-mode .p-card.score-bump { animation: none !important; }

.focus-mode .rank-change { animation: none !important; }

.focus-mode .p-score {
font-size: 68px !important;
letter-spacing: -3px;
}

/* Pas d'animation sur le score en mode zen */
.focus-mode .p-score:active {
animation: none !important;
}

.focus-mode .p-score.score-bump {
animation: none !important;
}

@keyframes scoreClick {
0% { transform: scale(1); }
50% { transform: scale(0.92); }
100% { transform: scale(1); }
}

@keyframes badgePopIn {
0% { opacity: 0; transform: scale(0) rotate(-180deg); }
100% { opacity: 1; transform: scale(1) rotate(0deg); }
}

.focus-mode .p-name-btn {
font-size: 15px;
padding: 7px 16px;
}

.focus-mode .p-temp {
font-size: 20px;
margin-top: 12px;
}

.focus-mode-cta {
position: fixed;
bottom: 300px;
right: 20px;
top: auto;
background: var(--primary);
color: white;
box-shadow: 0 4px 15px rgba(0,0,0,0.3);
border: none;
padding: 12px 20px;
border-radius: 30px;
font-weight: 800;
font-size: 13px;
z-index: 9999;
cursor: pointer;
opacity: 0;
pointer-events: none;
transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
transform: translateY(20px) scale(0.9);
}

@keyframes ctaSlideIn {
0% { opacity: 0; transform: translateX(100px); }
100% { opacity: 1; transform: translateX(0); }
}

.focus-mode .focus-mode-cta {
opacity: 1;
pointer-events: auto;
transform: translateY(0) scale(1);
}
.focus-mode-cta:active { transform: scale(0.95); }

/* ‚Äî STATS STYLES ‚Äî */
.stats-tabs { display: flex; gap: 10px; margin-bottom: 20px; border-bottom: 1px solid var(--border); padding-bottom: 10px; }
.stats-tab { flex: 1; text-align: center; padding: 10px; border-radius: 10px; cursor: pointer; font-weight: 700; font-size: 14px; opacity: 0.5; transition: 0.3s; }
.stats-tab.active { opacity: 1; background: var(--primary); color: white; box-shadow: 0 4px 10px rgba(0,0,0,0.1); }

.mode-filter {
display: flex;
gap: 8px;
margin-bottom: 15px;
padding: 0 5px;
}

.filter-btn, .filter-btn-records {
flex: 1;
padding: 8px 12px;
border-radius: 10px;
border: 1px solid var(--border);
background: var(--card);
font-size: 12px;
font-weight: 700;
cursor: pointer;
transition: all 0.2s;
color: var(--text);
}

.filter-btn.active, .filter-btn-records.active {
background: var(--primary);
color: white;
border-color: var(--primary);
}

.rank-item { display: flex; align-items: center; padding: 12px; border-bottom: 1px solid var(--border); cursor: pointer; transition: background 0.2s; }
.rank-item:hover { background: rgba(0,0,0,0.03); }
.rank-item:last-child { border-bottom: none; }
.rank-num { font-size: 20px; font-weight: 900; width: 30px; color: var(--text-sec); font-style: italic; }
.rank-1 .rank-num { color: #FFD700; } .rank-2 .rank-num { color: #C0C0C0; } .rank-3 .rank-num { color: #CD7F32; }
.rank-info { flex: 1; }
.rank-name { font-weight: 900; font-size: 16px; }
.rank-sub { font-size: 12px; color: var(--text-sec); }
.rank-val { font-weight: 800; font-size: 18px; }

.stat-detail { background: var(--card); padding: 15px; border-radius: 15px; margin-bottom: 15px; border: 1px solid var(--border); }
.stat-detail h4 { margin: 0 0 5px 0; font-size: 12px; text-transform: uppercase; color: var(--text-sec); }
.stat-detail .value { font-size: 24px; font-weight: 900; color: var(--text); }

.toast {
position: fixed;
top: max(60px, calc(env(safe-area-inset-top) + 40px));
left: 50%;
transform: translateX(-50%) translateY(-100px);
background: var(--glass-bg);
backdrop-filter: blur(20px);
-webkit-backdrop-filter: blur(20px);
border: 1px solid var(--glass-border);
padding: 16px 24px;
border-radius: 20px;
box-shadow: var(--glass-shadow);
font-weight: 700;
z-index: 7000;
opacity: 0;
transition: all 0.3s;
white-space: nowrap;
}
.toast.show { opacity: 1; transform: translateX(-50%) translateY(0); }
.toast.success { border-color: var(--success); background: var(--success); color: white; border: none; }
.toast.warning { border-color: var(--dealer); background: var(--dealer); color: white; border: none; }
.toast.error { border-color: var(--danger); background: var(--danger); color: white; border: none; }
.toast.info { border-color: var(--primary); background: var(--primary); color: white; border: none; }

.victory-overlay {
position: fixed; inset: 0; background: rgba(0,0,0,0.6); backdrop-filter: blur(10px); z-index: 6000;
display: flex; align-items: center; justify-content: center; opacity: 0; pointer-events: none;
transition: 0.3s; overflow-y: auto; padding: 20px;
}
.victory-overlay.active { opacity: 1; pointer-events: auto; }

.podium-container { display: flex; align-items: flex-end; justify-content: center; gap: 8px; margin: 30px 0; height: 180px; }
.podium-place { flex: 1; max-width: 110px; display: flex; flex-direction: column; align-items: center; animation: podiumEntrance 0.8s cubic-bezier(0.34, 1.56, 0.64, 1) backwards; }
.podium-place.p1 { animation-delay: 0.3s; } .podium-place.p2 { animation-delay: 0s; } .podium-place.p3 { animation-delay: 0.15s; }
.podium-avatar {
width: 60px; height: 60px; border-radius: 50%; display: flex; align-items: center; justify-content: center;
font-size: 28px; font-weight: 900; margin-bottom: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.2); position: relative;
transition: transform 0.3s ease;
}
.podium-place.p1 .podium-avatar {
animation: podiumGlow 2s ease-in-out infinite;
}
.podium-avatar:hover {
    transform: scale(1.1);
}
.podium-crown { position: absolute; top: -15px; font-size: 24px; animation: crownFloat 2s ease-in-out infinite; }
.podium-name { font-size: 11px; font-weight: 900; text-align: center; margin-bottom: 6px; }
.podium-score { font-size: 16px; font-weight: 900; margin-bottom: 8px; }
.podium-bar {
width: 100%; border-radius: 12px 12px 0 0; display: flex; align-items: center; justify-content: center;
font-size: 32px; font-weight: 900; color: white; box-shadow: 0 -2px 8px rgba(0,0,0,0.1);
transition: all 0.3s ease;
}
.podium-bar:hover {
    transform: scaleY(1.05);
}
.podium-place.p1 .podium-bar { background: linear-gradient(180deg, #FFD700, #FFA500); height: 100px; }
.podium-place.p2 .podium-bar { background: linear-gradient(180deg, #E8E8E8, #A8A8A8); height: 70px; }
.podium-place.p3 .podium-bar { background: linear-gradient(180deg, #CD7F32, #8B4513); height: 50px; }

.victory-tabs { display: flex; gap: 8px; margin-bottom: 20px; border-bottom: 2px solid var(--border); padding-bottom: 8px; }
.victory-tab { flex: 1; text-align: center; padding: 10px 8px; border-radius: 8px; cursor: pointer; font-weight: 700; font-size: 13px; opacity: 0.5; transition: 0.2s; }
.victory-tab.active { opacity: 1; background: var(--primary); color: white; box-shadow: 0 4px 10px rgba(0,0,0,0.15); }

.highlight-card { background: rgba(0,0,0,0.03); padding: 12px; border-radius: 12px; margin-bottom: 10px; display: flex; align-items: center; gap: 12px; border: 1px solid var(--border); }
.highlight-icon { font-size: 28px; }
.highlight-text { flex: 1; }
.highlight-label { font-size: 11px; color: var(--text-sec); font-weight: 600; }
.highlight-value { font-size: 14px; font-weight: 900; }

.player-stats-row { display: flex; align-items: center; padding: 10px; border-bottom: 1px solid var(--border); }
.player-stats-row:last-child { border-bottom: none; }
.player-stats-rank { width: 30px; font-size: 18px; font-weight: 900; }
.player-stats-info { flex: 1; }
.player-stats-name { font-size: 14px; font-weight: 900; }
.player-stats-score { font-size: 16px; font-weight: 900; }

@keyframes podiumRise { from { transform: translateY(100px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }

#confirm-modal { z-index: 6500; }
#confirm-modal .modal-box { text-align: center; }
#confirm-msg { font-size: 18px; margin: 0 0 25px 0; color: var(--text); }
.confirm-actions { display: flex; gap: 10px; }
.btn-confirm-no { background: var(--card); color: var(--text); border: 1px solid var(--border); }
.btn-confirm-yes { background: var(--danger); color: white; border: 1px solid var(--danger); }

/* Toggle Switch pour Param√®tres */
.settings-toggle {
    width: 52px;
    height: 32px;
    border-radius: 16px;
    background: var(--border);
    border: none;
    cursor: pointer;
    position: relative;
    transition: background 0.3s;
    padding: 0;
}
.settings-toggle.active {
    background: var(--success);
}
.settings-toggle .toggle-slider {
    position: absolute;
    top: 3px;
    left: 3px;
    width: 26px;
    height: 26px;
    border-radius: 50%;
    background: white;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    transition: transform 0.3s;
}
.settings-toggle.active .toggle-slider {
    transform: translateX(20px);
}

/* Sections de param√®tres */
.settings-section {
    margin-bottom: 20px;
}
.settings-section-title {
    font-size: 12px;
    font-weight: 800;
    color: var(--text-sec);
    text-transform: uppercase;
    letter-spacing: 0.5px;
    margin-bottom: 10px;
    padding-bottom: 8px;
    border-bottom: 1px solid var(--border);
}
.settings-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 14px 16px;
    background: var(--bg);
    border-radius: 14px;
    margin-bottom: 8px;
}
.settings-label {
    flex: 1;
}
.settings-name {
    font-weight: 800;
    font-size: 15px;
    margin-bottom: 2px;
}
.settings-desc {
    font-size: 12px;
    color: var(--text-sec);
}
</style>

</head>
<body>
    <div id="toast" class="toast"></div>
    
    <!-- === INDICATEUR DE CHARGEMENT === -->
    <div id="loading-overlay" class="loading-overlay">
        <div class="loading-spinner"></div>
        <div id="loading-text" class="loading-text">G√©n√©ration en cours...</div>
        <div id="loading-progress" class="loading-progress"></div>
    </div>

<div id="confirm-modal" class="modal-overlay">
    <div class="modal-box">
        <h3 id="confirm-msg">Confirmer l'action ?</h3>
        <div class="confirm-actions">
            <button class="btn-main btn-confirm-no" onclick="UI.closeConfirm()">Annuler</button>
            <button id="confirm-yes-btn" class="btn-main btn-confirm-yes">Confirmer</button>
        </div>
    </div>
</div>

<div id="stats-modal" class="modal-overlay" onclick="if(event.target===this) UI.closeStats()">
    <div class="modal-box large">
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:20px;">
            <h2 style="margin:0">üìä Statistiques</h2>
            <button onclick="UI.closeStats()" style="background:none; border:none; font-size:24px; color:var(--text); cursor:pointer;">‚úï</button>
        </div>
        <div class="stats-tabs">
            <div id="tab-rank" class="stats-tab active" onclick="UI.switchStatsTab('rank')">Classement</div>
            <div id="tab-records" class="stats-tab" onclick="UI.switchStatsTab('records')">Records</div>
        </div>
        <div id="stats-content-rank">
            <div class="mode-filter">
                <button class="filter-btn active" onclick="UI.filterStats('all')">Tous</button>
                <button class="filter-btn" onclick="UI.filterStats('belote')">üÉè Belote</button>
                <button class="filter-btn" onclick="UI.filterStats('standard')">üé≤ Standard</button>
            </div>
            <div id="ranking-list"></div>
        </div>
        <div id="stats-content-player" class="hidden">
            <button onclick="UI.showRanking()" style="background:none; border:none; color:var(--primary); font-weight:700; font-size:14px; margin-bottom:10px; cursor:pointer;">‚Üê Retour au classement</button>
            <div id="player-detail-content"></div>
        </div>
        <div id="stats-content-records" class="hidden">
            <div class="mode-filter">
                <button class="filter-btn-records active" onclick="UI.filterRecords('all')">Tous</button>
                <button class="filter-btn-records" onclick="UI.filterRecords('belote')">üÉè Belote</button>
                <button class="filter-btn-records" onclick="UI.filterRecords('standard')">üé≤ Standard</button>
            </div>
            <div id="records-list"></div>
        </div>
    </div>
</div>

<!-- Modal Param√®tres -->
<div id="settings-modal" class="modal-overlay" onclick="if(event.target===this) UI.closeSettings()">
    <div class="modal-box large" style="max-height:80vh; overflow-y:auto;">
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:20px;">
            <h2 style="margin:0">‚öôÔ∏è Param√®tres</h2>
            <button onclick="UI.closeSettings()" style="background:none; border:none; font-size:24px; color:var(--text); cursor:pointer;">‚úï</button>
        </div>
        
        <!-- Section Apparence -->
        <div class="settings-section">
            <div class="settings-section-title">Apparence</div>
            <div class="settings-row">
                <div class="settings-label">
                    <div class="settings-name">üåô Mode sombre</div>
                    <div class="settings-desc">Activer le th√®me sombre</div>
                </div>
                <button id="settings-theme-btn" class="settings-toggle" onclick="app.toggleTheme(); UI.updateSettingsUI();">
                    <span class="toggle-slider"></span>
                </button>
            </div>
        </div>
        
        <!-- Section Notifications -->
        <div class="settings-section">
            <div class="settings-section-title">üîî Notifications & Alertes</div>
            <div class="settings-row">
                <div class="settings-label">
                    <div class="settings-name">üì≥ Vibration</div>
                    <div class="settings-desc">Retours haptiques sur les actions</div>
                </div>
                <button id="settings-vibration-btn" class="settings-toggle" onclick="app.toggleSetting('vibration'); UI.updateSettingsUI();">
                    <span class="toggle-slider"></span>
                </button>
            </div>
            <div class="settings-row">
                <div class="settings-label">
                    <div class="settings-name">üéâ C√©l√©brations</div>
                    <div class="settings-desc">Confettis √† la victoire</div>
                </div>
                <button id="settings-confetti-btn" class="settings-toggle" onclick="app.toggleSetting('confetti'); UI.updateSettingsUI();">
                    <span class="toggle-slider"></span>
                </button>
            </div>
            <div class="settings-row">
                <div class="settings-label">
                    <div class="settings-name">üèÜ Milestones</div>
                    <div class="settings-desc">C√©l√©brer les 200, 500, 1000 pts</div>
                </div>
                <button id="settings-milestones-btn" class="settings-toggle" onclick="app.toggleSetting('milestones'); UI.updateSettingsUI();">
                    <span class="toggle-slider"></span>
                </button>
            </div>
        </div>
        
        <!-- Section Sons -->
        <div class="settings-section">
            <div class="settings-section-title">üîä Sons</div>
            <div class="settings-row">
                <div class="settings-label">
                    <div class="settings-name">üîä Effets sonores</div>
                    <div class="settings-desc">Activer les sons</div>
                </div>
                <button id="settings-sound-btn" class="settings-toggle" onclick="app.toggleSound(); UI.updateSettingsUI();">
                    <span class="toggle-slider"></span>
                </button>
            </div>
        </div>
        
        <!-- Section Affichage -->
        <div class="settings-section">
            <div class="settings-section-title">üé® Affichage</div>
            <div class="settings-row">
                <div class="settings-label">
                    <div class="settings-name">üìä Graphique</div>
                    <div class="settings-desc">Afficher le graphique de progression</div>
                </div>
                <button id="settings-chart-btn" class="settings-toggle" onclick="app.toggleSetting('showChart'); UI.updateSettingsUI();">
                    <span class="toggle-slider"></span>
                </button>
            </div>
            <div class="settings-row">
                <div class="settings-label">
                    <div class="settings-name">‚ûï Score temporaire</div>
                    <div class="settings-desc">Afficher le delta sous le score</div>
                </div>
                <button id="settings-tempScore-btn" class="settings-toggle" onclick="app.toggleSetting('showTempScore'); UI.updateSettingsUI();">
                    <span class="toggle-slider"></span>
                </button>
            </div>
        </div>
        
        <!-- Section Avanc√© -->
        <div class="settings-section">
            <div class="settings-section-title">üîß Avanc√©</div>
            <div class="settings-row" style="cursor:pointer;" onclick="app.clearRecentPlayers()">
                <div class="settings-label">
                    <div class="settings-name">üóëÔ∏è Effacer joueurs r√©cents</div>
                    <div class="settings-desc">Vider la liste des noms sugg√©r√©s</div>
                </div>
                <div style="color:var(--primary); font-size:20px;">‚Üí</div>
            </div>
            <div class="settings-row" style="cursor:pointer;" onclick="app.resetStats()">
                <div class="settings-label">
                    <div class="settings-name">üìä R√©initialiser les stats</div>
                    <div class="settings-desc">Remettre √† z√©ro les classements</div>
                </div>
                <div style="color:var(--primary); font-size:20px;">‚Üí</div>
            </div>
        </div>
        
        <!-- Section Donn√©es -->
        <div class="settings-section">
            <div class="settings-section-title">üíæ Donn√©es</div>
            <div class="settings-row" style="cursor:pointer;" onclick="app.exportData()">
                <div class="settings-label">
                    <div class="settings-name">üì§ Exporter les donn√©es</div>
                    <div class="settings-desc">T√©l√©charger toutes vos parties</div>
                </div>
                <div style="color:var(--primary); font-size:20px;">‚Üí</div>
            </div>
            <div class="settings-row" style="cursor:pointer;" onclick="document.getElementById('import-file').click()">
                <div class="settings-label">
                    <div class="settings-name">üì• Importer les donn√©es</div>
                    <div class="settings-desc">Restaurer une sauvegarde</div>
                </div>
                <div style="color:var(--primary); font-size:20px;">‚Üí</div>
            </div>
            <input type="file" id="import-file" accept=".json" style="display:none;" onchange="app.importData(this)">
        </div>
    </div>
</div>

<!-- Modal de pr√©s√©lection des jeux -->
<div id="preset-modal" class="modal-overlay preset-modal" onclick="if(event.target===this) app.closePresets()">
    <div class="modal-box">
        <div class="preset-header">
            <h2>üéÆ Choisir un jeu</h2>
            <div style="display:flex; gap:8px;">
                <button id="preset-edit-btn" class="preset-edit-btn" onclick="app.togglePresetEditMode()" title="Supprimer des jeux">üóëÔ∏è</button>
                <button class="preset-close" onclick="app.closePresets()">‚úï</button>
            </div>
        </div>
        <div class="presets-grid" id="presets-grid">
            <!-- Rempli dynamiquement par JavaScript -->
        </div>
    </div>
</div>

<div id="modal-player-count" class="modal-overlay" onclick="if(event.target===this) app.closePlayerCountModal()">
    <div class="modal-box" style="max-width: 400px;">
        <!-- Bouton retour (cach√© par d√©faut) -->
        <button id="btn-back-to-presets" class="hidden" onclick="app.backToPresets()" style="position:absolute; top:15px; left:15px; width:36px; height:36px; border-radius:50%; background:var(--border); border:none; font-size:18px; cursor:pointer; display:flex; align-items:center; justify-content:center;">‚Üê</button>
        <h2 style="margin:0 0 10px 0" id="mode-setup-title">Mode Standard</h2>
        <p style="color:var(--text-sec); margin-bottom:20px;">Combien de joueurs ?</p>
        <div style="display:grid; grid-template-columns: repeat(3, 1fr); gap:10px; margin-bottom:25px;">
            <button class="btn-nb" onclick="app.selectPlayerCount(2)">2</button>
            <button class="btn-nb" onclick="app.selectPlayerCount(3)">3</button>
            <button class="btn-nb" onclick="app.selectPlayerCount(4)">4</button>
            <button class="btn-nb" onclick="app.selectPlayerCount(5)">5</button>
            <button class="btn-nb" onclick="app.selectPlayerCount(6)">6</button>
            <button id="btn-toggle-players" class="btn-nb" style="background:rgba(120,120,128,0.12); font-size:14px;" onclick="app.toggleMorePlayers()">Plus ‚ñº</button>
            <div id="extra-players" class="hidden" style="grid-column: 1 / -1; display:contents;">
                <button class="btn-nb" onclick="app.selectPlayerCount(7)">7</button>
                <button class="btn-nb" onclick="app.selectPlayerCount(8)">8</button>
                <button class="btn-nb" onclick="app.selectPlayerCount(9)">9</button>
                <button class="btn-nb" onclick="app.selectPlayerCount(10)">10</button>
                <button class="btn-nb" onclick="app.selectPlayerCount(11)">11</button>
                <button class="btn-nb" onclick="app.selectPlayerCount(12)">12</button>
            </div>
        </div>
        
        <!-- Nouvelles options -->
        <div style="border-top: 1px solid var(--border); padding-top: 20px; margin-top: 10px;">
            <div style="margin-bottom: 20px;">
                <label style="font-size: 13px; font-weight: 700; color: var(--text); margin-bottom: 10px; display: block;">üéØ Objectif de victoire</label>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                    <label style="display: flex; align-items: center; justify-content: center; background: var(--card); border: 2px solid var(--border); border-radius: 12px; padding: 12px; cursor: pointer; transition: all 0.2s;" id="victory-highest-label">
                        <input type="radio" name="victory-condition" value="highest" checked style="margin-right: 8px; accent-color: var(--primary);" onchange="app.updateVictoryCondition()">
                        <span style="font-size: 12px; font-weight: 700;">‚¨ÜÔ∏è Plus HAUT</span>
                    </label>
                    <label style="display: flex; align-items: center; justify-content: center; background: var(--card); border: 2px solid var(--border); border-radius: 12px; padding: 12px; cursor: pointer; transition: all 0.2s;" id="victory-lowest-label">
                        <input type="radio" name="victory-condition" value="lowest" style="margin-right: 8px; accent-color: var(--primary);" onchange="app.updateVictoryCondition()">
                        <span style="font-size: 12px; font-weight: 700;">‚¨áÔ∏è Plus BAS</span>
                    </label>
                </div>
            </div>
            
            <div>
                <label style="font-size: 13px; font-weight: 700; color: var(--text); margin-bottom: 10px; display: block;">üèÅ Condition de fin</label>
                <div style="display: grid; gap: 8px;">
                    <label style="display: flex; align-items: center; background: var(--card); border: 2px solid var(--border); border-radius: 12px; padding: 12px; cursor: pointer;" id="end-free-label">
                        <input type="radio" name="end-condition" value="free" checked style="margin-right: 10px; accent-color: var(--primary);" onchange="app.updateEndCondition()">
                        <span style="font-size: 12px; font-weight: 700; flex: 1;">‚ôæÔ∏è Partie libre</span>
                    </label>
                    <label style="display: flex; align-items: center; background: var(--card); border: 2px solid var(--border); border-radius: 12px; padding: 12px; cursor: pointer;" id="end-score-label">
                        <input type="radio" name="end-condition" value="score" style="margin-right: 10px; accent-color: var(--primary);" onchange="app.updateEndCondition()">
                        <span style="font-size: 12px; font-weight: 700; flex: 1;" id="score-label-text">üéØ Score objectif :</span>
                        <input type="number" id="score-target" value="100" min="10" max="9999" style="width: 70px; padding: 6px; border: 1px solid var(--border); border-radius: 8px; font-size: 14px; font-weight: 700; text-align: center; background: var(--bg); color: var(--text);" onclick="event.stopPropagation(); document.querySelector('input[name=end-condition][value=score]').checked = true; app.updateEndCondition();">
                    </label>
                </div>
            </div>
            
            <!-- Bouton sauvegarder le mode -->
            <div style="margin-top: 20px; padding-top: 15px; border-top: 1px solid var(--border);">
                <button onclick="app.openSaveCustomModal()" style="width: 100%; padding: 14px; background: linear-gradient(135deg, var(--primary), var(--accent)); color: white; border: none; border-radius: 14px; font-size: 14px; font-weight: 800; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 8px;">
                    <span>üíæ</span> Sauvegarder ce mode
                </button>
            </div>
        </div>
    </div>
</div>

<!-- Modal pour sauvegarder un mode personnalis√© -->
<div id="save-custom-modal" class="modal-overlay" onclick="if(event.target===this) document.getElementById('save-custom-modal').classList.remove('active')">
    <div class="modal-box" style="max-width: 340px;">
        <h2 style="margin:0 0 20px 0">üíæ Sauvegarder le mode</h2>
        <div style="margin-bottom: 15px;">
            <label style="font-size: 12px; font-weight: 700; color: var(--text-sec); display: block; margin-bottom: 6px;">Nom du jeu</label>
            <input type="text" id="custom-mode-name" placeholder="Ex: Mon Rami" maxlength="20" style="width: 100%; padding: 12px; border: 2px solid var(--border); border-radius: 12px; font-size: 16px; font-weight: 700; background: var(--bg); color: var(--text); box-sizing: border-box;">
        </div>
        <div style="margin-bottom: 20px;">
            <label style="font-size: 12px; font-weight: 700; color: var(--text-sec); display: block; margin-bottom: 6px; text-align: center;">Emoji</label>
            <div id="emoji-picker" style="display: flex; gap: 8px; flex-wrap: wrap; justify-content: center;">
                <button class="emoji-option selected" onclick="app.selectEmoji('üéÆ', event)">üéÆ</button>
                <button class="emoji-option" onclick="app.selectEmoji('üé≤', event)">üé≤</button>
                <button class="emoji-option" onclick="app.selectEmoji('üÉè', event)">üÉè</button>
                <button class="emoji-option" onclick="app.selectEmoji('üé¥', event)">üé¥</button>
                <button class="emoji-option" onclick="app.selectEmoji('üéØ', event)">üéØ</button>
                <button class="emoji-option" onclick="app.selectEmoji('‚≠ê', event)">‚≠ê</button>
                <button class="emoji-option" onclick="app.selectEmoji('üèÜ', event)">üèÜ</button>
                <button class="emoji-option" onclick="app.selectEmoji('üî•', event)">üî•</button>
                <button class="emoji-option" onclick="app.selectEmoji('üíé', event)">üíé</button>
                <button class="emoji-option" onclick="app.selectEmoji('üé™', event)">üé™</button>
                <button class="emoji-option" onclick="app.selectEmoji('üé®', event)">üé®</button>
                <button class="emoji-option" onclick="app.selectEmoji('üåü', event)">üåü</button>
                <button class="emoji-option" onclick="app.selectEmoji('üÄÑ', event)">üÄÑ</button>
                <button class="emoji-option" onclick="app.selectEmoji('ü™ô', event)">ü™ô</button>
                <button class="emoji-option emoji-add" onclick="app.openCustomEmojiPicker()" title="Emoji personnalis√©">+</button>
            </div>
            <input type="text" id="custom-mode-emoji" value="üéÆ" maxlength="2" style="display:none;">
        </div>
        <div style="display: flex; gap: 10px;">
            <button onclick="document.getElementById('save-custom-modal').classList.remove('active')" style="flex: 1; padding: 14px; background: var(--card); color: var(--text); border: 1px solid var(--border); border-radius: 14px; font-size: 14px; font-weight: 700; cursor: pointer;">Annuler</button>
            <button onclick="app.saveCustomMode()" style="flex: 2; padding: 14px; background: var(--success); color: white; border: none; border-radius: 14px; font-size: 14px; font-weight: 700; cursor: pointer;">‚úì Sauvegarder</button>
        </div>
    </div>
</div>

<div id="setup" class="container">
    <div class="header-controls">
        <h1 class="welcome-title" style="margin:0; flex:1;">ScoreMaster</h1>
        <div style="display:flex; gap:10px;">
            <button class="btn-stats" onclick="app.showStats()" title="Statistiques">üìä</button>
            <button class="theme-toggle" onclick="UI.showSettings()" title="Param√®tres">‚öôÔ∏è</button>
        </div>
    </div>
    <div class="mode-btn" onclick="app.quickStartBelote()">
        <span style="font-size:30px; margin-right:15px;">üÉè</span>
        <div><h2 style="margin:0">Belote / Coinche</h2><p style="margin:4px 0 0; font-size:12px; color:var(--text-sec)">D√©marrage rapide ‚Ä¢ 2 √©quipes</p></div>
    </div>
    <div class="mode-btn" onclick="app.openPresets()">
        <span style="font-size:30px; margin-right:15px;">üéÆ</span>
        <div><h2 style="margin:0">Nouvelle partie</h2><p style="margin:4px 0 0; font-size:12px; color:var(--text-sec)">Uno, Skyjo, Flip 7, Rami...</p></div>
    </div>
    <div style="margin-top: 40px;">
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:15px;">
            <h3 style="margin:0; font-size:18px; font-weight:900;">üìö Historique des parties</h3>
            <button onclick="app.clearAll()" style="background:none; border:none; color:var(--danger); font-weight:900; font-size:12px; cursor:pointer;">TOUT EFFACER</button>
        </div>
        <div id="games-list"></div>
    </div>
    <div class="guide-container">
        <b style="display:block; margin-bottom:8px; color:var(--text)">üìñ Guide Rapide</b>
        ‚Ä¢ üìä Stats : Consultez vos classements et records<br>
        ‚Ä¢ üëÅÔ∏è Zen : Affichage √©pur√© plein √©cran<br>
        ‚Ä¢ üÉè Nom : Cliquez pour donner/renommer<br>
        ‚Ä¢ ‚úçÔ∏è Score : Cliquez sur le score pour saisir<br>
        ‚Ä¢ ‚úèÔ∏è Manche : Cliquez sur l'historique pour corriger
    </div>
</div>

<div id="game" class="container hidden">
    <header style="display:flex; justify-content:space-between; align-items:center; margin-bottom:20px;">
        <button onclick="app.showSetup()" style="background:var(--card); border:1px solid var(--border); width:40px; height:40px; border-radius:12px; color:var(--text); cursor:pointer;">‚¨ÖÔ∏è</button>
        <div style="flex:1; text-align:center;">
            <h1 id="mode-title" style="margin:0; font-size:22px; font-weight:900;">SCORE</h1>
            <div id="game-info" style="font-size:10px; color:var(--text-sec); font-weight:700; margin-top:3px;"></div>
        </div>
        <button class="btn-focus" onclick="app.toggleFocusMode()" title="Mode Zen">üëÅÔ∏è</button>
    </header>
    <div class="chart-box"><canvas id="chart"></canvas></div>
    <div id="grid" class="players-grid"></div>
    <div id="history-header" style="display:flex; justify-content:space-between; margin: 30px 0 10px; font-size:11px; font-weight:900; color:var(--text-sec);">
        <span>HISTORIQUE DES MANCHES</span>
        <div style="display:flex; gap:12px;">
            <button onclick="app.finishGame()" style="background:none; border:none; color:var(--success); font-weight:900; cursor:pointer;">‚úì TERMINER</button>
            <button onclick="app.undo()" style="background:none; border:none; color:var(--danger); font-weight:900; cursor:pointer;">ANNULER</button>
        </div>
    </div>
    <div id="history"></div>
</div>

<div id="dock" class="dock hidden">
    <button id="save-btn" class="btn-main" onclick="app.validateRound()">ENREGISTRER MANCHE 1</button>
</div>

<div id="modal-player" class="modal-overlay" onclick="if(event.target===this) app.closeModal()">
    <div class="modal-player-wrapper">
        <div class="modal-box" style="max-width: 340px;">
            <h2 id="modal-title" style="margin:0 0 20px 0">Joueur</h2>
            <input type="text" id="edit-name" style="width:100%; padding:15px; border-radius:12px; border:2px solid var(--border); font-size:18px; font-weight:700; outline:none; background:var(--bg); color:var(--text);" placeholder="Nom du joueur">
            <label style="display:flex; align-items:center; justify-content:space-between; background:var(--bg); padding:15px; border-radius:12px; font-weight:700; cursor:pointer; margin-top:20px;">
                Donneur üÉè <input type="checkbox" id="edit-dealer" style="width:20px; height:20px; accent-color:var(--dealer);">
            </label>
            <button class="btn-main" style="margin-top:20px; background:var(--primary); color:white" onclick="app.savePlayer()">VALIDER</button>
        </div>
        <div id="recent-players-suggestions" class="recent-suggestions"></div>
    </div>
</div>

<div id="sheet" class="sheet-overlay" onclick="app.closeSheet()">
    <div class="sheet-content" onclick="event.stopPropagation()">
        <div id="input-switcher" style="display:flex; gap:8px; margin-bottom:20px; overflow-x:auto; padding: 10px 20px 5px 20px; scroll-snap-type: x mandatory;"></div>
        <div style="display:grid; grid-template-columns: repeat(4, 1fr); gap:8px; margin-bottom:12px;">
            <button id="calc-btn" class="btn-nb hidden" style="grid-column:span 4; background:var(--success); color:white; font-size:14px; box-shadow:none;" onclick="app.calcRest()">‚ú® RESTE √Ä 162</button>
            <button class="btn-nb" style="background:rgba(120,120,128,0.12); font-size:14px; box-shadow:none;" onclick="app.addVal(10)">+10</button>
            <button class="btn-nb" style="background:rgba(120,120,128,0.12); font-size:14px; box-shadow:none;" onclick="app.addVal(20)">+20</button>
            <button id="btn-82" class="btn-nb hidden" style="background:rgba(120,120,128,0.12); font-size:14px; box-shadow:none;" onclick="app.addVal(82)">+82</button>
            <button id="btn-50" class="btn-nb hidden" style="background:rgba(120,120,128,0.12); font-size:14px; box-shadow:none;" onclick="app.addVal(50)">+50</button>
            <button id="smart-btn" class="btn-nb" style="background:var(--text); color:var(--bg); font-size:14px; box-shadow:none;" onclick="app.handleSmart()">+/-</button>
        </div>
        <div class="numpad">
            <button class="btn-nb" onclick="app.typeNum(1)">1</button><button class="btn-nb" onclick="app.typeNum(2)">2</button><button class="btn-nb" onclick="app.typeNum(3)">3</button>
            <button class="btn-nb" onclick="app.typeNum(4)">4</button><button class="btn-nb" onclick="app.typeNum(5)">5</button><button class="btn-nb" onclick="app.typeNum(6)">6</button>
            <button class="btn-nb" onclick="app.typeNum(7)">7</button><button class="btn-nb" onclick="app.typeNum(8)">8</button><button class="btn-nb" onclick="app.typeNum(9)">9</button>
            <button class="btn-nb" style="color:var(--danger)" onclick="app.clearInput()">C</button>
            <button class="btn-nb" onclick="app.typeNum(0)">0</button>
            <button class="btn-nb" onclick="app.backspace()">‚å´</button>
        </div>
        <button class="btn-main" style="margin-top:15px; background:var(--primary); color:white" onclick="app.closeSheet()">OK</button>
    </div>
</div>

<div id="victory" class="victory-overlay">
    <div class="victory-box">
        <h2 class="text-center" style="margin:0 0 10px 0; font-size:28px;">üèÜ PARTIE TERMIN√âE</h2>
        
        <div class="victory-tabs">
            <div class="victory-tab active" onclick="UI.switchVictoryTab('podium')">üèÜ Podium</div>
            <div class="victory-tab" onclick="UI.switchVictoryTab('stats')">üìä Stats</div>
            <div class="victory-tab" onclick="UI.switchVictoryTab('highlights')">‚≠ê Highlights</div>
        </div>

        <div id="victory-tab-podium">
            <div class="podium-container" id="podium"></div>
        </div>

        <div id="victory-tab-stats" class="hidden">
            <div id="victory-all-players"></div>
        </div>

        <div id="victory-tab-highlights" class="hidden">
            <div id="victory-highlights"></div>
        </div>

        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin: 20px 0 12px;">
            <button class="btn-main" style="background:linear-gradient(135deg, #2B5AA0 0%, #1E3F6E 100%); color:white; font-size:16px;" onclick="app.shareRecapPNG()">
                üì∏ PNG
            </button>
            <button class="btn-main" style="background:linear-gradient(135deg, #667eea 0%, #764ba2 100%); color:white; font-size:16px;" onclick="app.shareRecapGIF()">
                üé¨ GIF
                <div style="font-size:10px; opacity:0.8; margin-top:2px;">~15s</div>
            </button>
        </div>
        <button class="btn-main" style="background:var(--primary); color:white; margin:0 0 12px;" onclick="app.restartWithSamePlayers()">üîÑ REJOUER (m√™mes joueurs)</button>
        <button class="btn-main" style="background:var(--card); border:1px solid var(--border); color:var(--text);" onclick="app.showSetup()">üè† RETOUR MENU</button>
    </div>
</div>

<script>
    // ==================== UTILITAIRES ====================
    // Debounce utility pour optimiser les √©critures
    const debounce = (fn, delay) => {
        let timeoutId;
        return (...args) => {
            clearTimeout(timeoutId);
            timeoutId = setTimeout(() => fn(...args), delay);
        };
    };
    
    // Escape HTML pour pr√©venir les XSS
    const escapeHtml = (str) => {
        if (!str) return '';
        return String(str)
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#039;');
    };
    
    // ==================== SOUND ENGINE ====================
    const SoundFX = {
        ctx: null, 
        enabled: true,
        audioAvailable: false,
        
        init() {
            try {
                if (window.AudioContext || window.webkitAudioContext) {
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                    this.audioAvailable = true;
                    if (this.ctx.state === 'suspended') {
                        document.addEventListener('click', () => {
                            if (this.ctx && this.ctx.state === 'suspended') {
                                this.ctx.resume().catch(() => {});
                            }
                        }, { once: true });
                    }
                } else {
                    console.warn("AudioContext non support√© - mode silencieux");
                    this.enabled = false;
                    this.audioAvailable = false;
                }
            } catch (e) { 
                console.warn("Audio API non disponible:", e.message);
                this.enabled = false;
                this.audioAvailable = false;
            }
        },
        
        playTone(freq, type, duration) {
            if (!this.enabled || !this.audioAvailable || !this.ctx) return;
            
            try {
                if (this.ctx.state === 'suspended') {
                    this.ctx.resume().catch(() => {});
                }
                
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + duration);
            } catch (e) {
                // Silencieux en cas d'erreur
            }
        },
        
        click() { 
            if (this.enabled) this.playTone(800, 'sine', 0.1); 
        },
        
        slide() { 
            if (!this.enabled || !this.audioAvailable || !this.ctx) return;
            try {
                const bufferSize = this.ctx.sampleRate * 0.15; 
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
                const noise = this.ctx.createBufferSource();
                noise.buffer = buffer;
                const gain = this.ctx.createGain();
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 400;
                gain.gain.setValueAtTime(0.05, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.15);
                noise.connect(filter);
                filter.connect(gain);
                gain.connect(this.ctx.destination);
                noise.start();
            } catch (e) {}
        },
        
        success() { 
            if (this.enabled) {
                this.playTone(600, 'sine', 0.1); 
                setTimeout(() => this.playTone(900, 'sine', 0.2), 100);
            }
        },
        
        error() { 
            if (this.enabled) this.playTone(150, 'sawtooth', 0.3); 
        }
    };

    // ==================== DATA LAYER ====================
    const GameState = {
        create(mode, playerCount) {
            const colors = ['#007AFF', '#FF2D55', '#34C759', '#FF9500', '#AF52DE', '#5AC8FA', '#FFCC00', '#5856D6', '#FF3B30', '#30B0C7', '#8E8E93', '#4CD964'];
            // Force minimum 2 joueurs, maximum 12
            const validPlayerCount = Math.max(2, Math.min(playerCount, 12));
            return {
                mode,
                victoryCondition: 'highest',
                players: Array.from({length: validPlayerCount}, (_, i) => ({
                    id: i + 1, 
                    name: mode === 'belote' ? (i === 0 ? 'NOUS' : 'EUX') : `J${i + 1}`, 
                    color: colors[i] || '#000000',
                    total: 0, previousRank: null
                })),
                history: [], temp: {}, dealerId: 1, celebratedMilestones: {}
            };
        },
        addRound(state, scores) {
            const round = {};
            state.players.forEach(p => {
                const score = scores[p.id] || 0;
                round[p.id] = score;
                p.total += score;
            });
            state.history.push(round);
            return state;
        },
        updateRound(state, index, scores) {
            const oldRound = state.history[index];
            state.players.forEach(p => p.total -= (oldRound[p.id] || 0));
            const newRound = {};
            state.players.forEach(p => {
                const score = scores[p.id] || 0;
                newRound[p.id] = score;
                p.total += score;
            });
            state.history[index] = newRound;
            return state;
        },
        deleteRound(state, index) {
            const round = state.history[index];
            state.players.forEach(p => p.total -= (round[p.id] || 0));
            state.history.splice(index, 1);
            return state;
        },
        // Recalculer les totaux depuis l'historique (pour r√©parer les donn√©es corrompues)
        rebuildTotals(state) {
            if (!state || !state.players || !state.history) return state;
            // R√©initialiser tous les totaux √† 0
            state.players.forEach(p => { p.total = 0; });
            // Recalculer depuis l'historique avec validation
            state.history.forEach(round => {
                state.players.forEach(p => {
                    const score = round[p.id];
                    // Valider que le score est un nombre fini
                    if (typeof score === 'number' && isFinite(score) && !isNaN(score)) {
                        p.total += score;
                    }
                    // Ignorer les valeurs invalides (non-num√©riques)
                });
            });
            return state;
        },
        getSortedPlayers(state) {
            const isLowest = state.victoryCondition === 'lowest';
            return [...state.players].sort((a, b) => 
                isLowest ? a.total - b.total : b.total - a.total
            );
        },
        validate(scores, mode) {
            // V√©rifier que scores est un objet valide
            if (!scores || typeof scores !== 'object') {
                return { valid: false, error: 'Scores invalides' };
            }
            
            const values = Object.values(scores);
            
            // V√©rifier que toutes les valeurs sont des nombres valides
            for (const v of values) {
                if (typeof v !== 'number' || isNaN(v) || !isFinite(v)) {
                    return { valid: false, error: 'Score invalide (doit √™tre un nombre)' };
                }
            }
            
            if(values.some(v => v > 9999)) return { valid: false, error: 'Score trop √©lev√© (max 9999)' };
            if(values.some(v => v < -9999)) return { valid: false, error: 'Score trop bas (min -9999)' };
            if(mode === 'belote' && values.some(v => v < 0)) return { valid: false, error: 'Score n√©gatif impossible en Belote' };
            return { valid: true };
        }
    };

    // ==================== STORAGE LAYER AM√âLIOR√â ====================
    const Storage = {
        GAMES_KEY: 'sm_v12_games', 
        CURRENT_KEY: 'sm_v12_current',
        memoryFallback: null, // Fallback en m√©moire si localStorage d√©sactiv√©
        storageAvailable: true,
        
        // V√©rifier la disponibilit√© du localStorage
        checkStorageAvailability() {
            try {
                const testKey = '__storage_test__';
                localStorage.setItem(testKey, testKey);
                localStorage.removeItem(testKey);
                this.storageAvailable = true;
                return true;
            } catch (e) {
                console.warn("localStorage non disponible - utilisation m√©moire tampon");
                this.storageAvailable = false;
                if (!this.memoryFallback) {
                    this.memoryFallback = { games: [], current: null };
                }
                return false;
            }
        },
        
        migrateData() {
            if (!this.storageAvailable && !this.checkStorageAvailability()) return;
            
            const v12Data = localStorage.getItem(this.GAMES_KEY);
            if (!v12Data) {
                const v11Data = localStorage.getItem('sm_v11_games');
                if (v11Data) {
                    try {
                        const parsed = JSON.parse(v11Data);
                        if (Array.isArray(parsed) && parsed.length > 0) {
                            localStorage.setItem(this.GAMES_KEY, v11Data);
                            console.log("SM: Migration v11->v12 OK");
                            const v11Current = localStorage.getItem('sm_v11_current');
                            if (v11Current && parsed.find(g => g.id === v11Current)) {
                                localStorage.setItem(this.CURRENT_KEY, v11Current);
                            }
                        }
                    } catch(e) { console.error("SM: Migration √©chou√©e", e); }
                }
            }
        },
        
        // Valider les donn√©es avant sauvegarde
        validateGameData(game) {
            if (!game || typeof game !== 'object') return false;
            if (!game.id || !game.mode || !game.state) return false;
            if (!Array.isArray(game.state.players)) return false;
            if (!Array.isArray(game.state.history)) return false;
            
            // Valider chaque joueur
            for (const player of game.state.players) {
                if (!player.id || typeof player.name !== 'string') return false;
                if (typeof player.total !== 'number') return false;
            }
            
            return true;
        },
        
        // Nettoyer les donn√©es corrompues
        sanitizeGame(game, forceRebuild = false) {
            if (!game) return null;
            
            // Ignorer le flag _sanitized legacy - toujours reconstruire pour garantir l'int√©grit√©
            
            const sanitized = {
                id: game.id || Date.now().toString(),
                name: String(game.name || 'Partie'),
                mode: game.mode || 'standard',
                date: game.date || new Date().toISOString(),
                victoryCondition: game.victoryCondition || 'highest',
                endCondition: game.endCondition || { type: 'free', value: null },
                finished: Boolean(game.finished),
                preset: game.preset || null,
                state: {
                    mode: game.state?.mode || game.mode || 'standard',
                    victoryCondition: game.state?.victoryCondition || game.victoryCondition || 'highest',
                    players: [],
                    history: [],
                    temp: {},
                    dealerId: game.state?.dealerId || 1,
                    celebratedMilestones: game.state?.celebratedMilestones || {}
                }
            };
            
            // Sanitiser les joueurs
            if (Array.isArray(game.state?.players)) {
                sanitized.state.players = game.state.players.map((p, i) => ({
                    id: p.id || (i + 1),
                    name: String(p.name || `J${i + 1}`).toUpperCase().substring(0, 20),
                    color: p.color || ['#007AFF', '#FF2D55', '#34C759', '#FF9500', '#AF52DE', '#5AC8FA'][i % 6],
                    total: typeof p.total === 'number' ? p.total : 0,
                    previousRank: p.previousRank || null
                }));
            }
            
            // Sanitiser l'historique
            if (Array.isArray(game.state?.history)) {
                sanitized.state.history = game.state.history.map(round => {
                    const sanitizedRound = {};
                    for (const [playerId, score] of Object.entries(round)) {
                        const numScore = Number(score);
                        if (!isNaN(numScore)) {
                            sanitizedRound[playerId] = numScore;
                        }
                    }
                    return sanitizedRound;
                });
            }
            
            // Recalculer les totaux depuis l'historique pour garantir la coh√©rence
            GameState.rebuildTotals(sanitized.state);
            
            // Note: _sanitized flag removed - we want rebuildTotals to run on every load
            // to catch any data corruption from previous sessions
            
            return sanitized;
        },
        
        saveGame(game) {
            // Valider d'abord
            if (!this.validateGameData(game)) {
                console.error("SM: Donn√©es invalides, tentative de r√©paration");
                game = this.sanitizeGame(game);
                if (!game) {
                    console.error("SM: Impossible de r√©parer les donn√©es");
                    return false;
                }
            }
            
            // Utiliser le fallback m√©moire si localStorage indisponible
            if (!this.storageAvailable && !this.checkStorageAvailability()) {
                if (!this.memoryFallback) this.memoryFallback = { games: [], current: null };
                const existing = this.memoryFallback.games.findIndex(g => g.id === game.id);
                if (existing >= 0) this.memoryFallback.games[existing] = game;
                else this.memoryFallback.games.push(game);
                this.memoryFallback.current = game.id;
                return true;
            }
            
            try {
                const games = this.loadGames() || [];
                const existing = games.findIndex(g => g.id === game.id);
                if (existing >= 0) games[existing] = game;
                else games.push(game);
                localStorage.setItem(this.GAMES_KEY, JSON.stringify(games));
                localStorage.setItem(this.CURRENT_KEY, game.id);
                return true;
            } catch(e) {
                console.error("SM: Save failed", e);
                // Erreur quota - essayer de nettoyer les vieilles parties
                if (e.name === 'QuotaExceededError') {
                    try {
                        const games = this.loadGames() || [];
                        if (games.length > 5) {
                            const recentGames = games.slice(-5);
                            localStorage.setItem(this.GAMES_KEY, JSON.stringify(recentGames));
                            // R√©essayer UNE SEULE FOIS (pas de r√©cursion)
                            try {
                                localStorage.setItem(this.GAMES_KEY, JSON.stringify([...recentGames, game]));
                                localStorage.setItem(this.CURRENT_KEY, game.id);
                                return true;
                            } catch (e3) {
                                console.error("SM: Impossible de sauvegarder m√™me apr√®s nettoyage");
                                return false;
                            }
                        }
                    } catch (e2) {
                        console.error("SM: Impossible de nettoyer", e2);
                    }
                }
                return false;
            }
        },
        
        loadGames() {
            // Utiliser le fallback m√©moire si localStorage indisponible
            if (!this.storageAvailable && !this.checkStorageAvailability()) {
                return this.memoryFallback?.games || [];
            }
            
            try {
                const data = localStorage.getItem(this.GAMES_KEY);
                if (!data) return [];
                
                const parsed = JSON.parse(data);
                if (!Array.isArray(parsed)) {
                    console.warn("SM: Donn√©es corrompues, r√©initialisation");
                    localStorage.removeItem(this.GAMES_KEY);
                    return [];
                }
                
                // Valider et nettoyer chaque partie
                return parsed.map(game => {
                    try {
                        return this.sanitizeGame(game);
                    } catch (e) {
                        console.warn("SM: Partie corrompue ignor√©e", e);
                        return null;
                    }
                }).filter(g => g !== null);
                
            } catch(e) { 
                console.error("SM: Corrupt data", e); 
                return []; 
            }
        },
        
        loadCurrentGame() {
            // Utiliser le fallback m√©moire si localStorage indisponible
            if (!this.storageAvailable && !this.checkStorageAvailability()) {
                if (!this.memoryFallback) return null;
                return this.memoryFallback.games.find(g => g.id === this.memoryFallback.current);
            }
            
            try {
                const currentId = localStorage.getItem(this.CURRENT_KEY);
                if (!currentId) return null;
                return this.loadGames().find(g => g.id === currentId);
            } catch(e) { return null; }
        },
        
        deleteGame(gameId) {
            // Utiliser le fallback m√©moire si localStorage indisponible
            if (!this.storageAvailable && !this.checkStorageAvailability()) {
                if (this.memoryFallback) {
                    this.memoryFallback.games = this.memoryFallback.games.filter(g => g.id !== gameId);
                    if (this.memoryFallback.current === gameId) {
                        this.memoryFallback.current = null;
                    }
                }
                return;
            }
            
            const games = this.loadGames().filter(g => g.id !== gameId);
            localStorage.setItem(this.GAMES_KEY, JSON.stringify(games));
            const currentId = localStorage.getItem(this.CURRENT_KEY);
            if (currentId === gameId) localStorage.removeItem(this.CURRENT_KEY);
        }
    };

    // ==================== STATS ENGINE OPTIMIS√â ====================
    const StatsEngine = {
        calculateStats(mode = 'all') {
            const games = Storage.loadGames().filter(g =>
                g.finished && (mode === 'all' || g.mode === mode)
            );

            // Trier les jeux par date une seule fois
            games.sort((a, b) => new Date(a.date || a.timestamp) - new Date(b.date || b.timestamp));

            const stats = {};
            const streaks = {};

            // UNE SEULE BOUCLE PRINCIPALE
            games.forEach(game => {
                const isLowest = game.victoryCondition === 'lowest';
                const sortedPlayers = [...game.state.players].sort((a,b) => isLowest ? a.total - b.total : b.total - a.total);
                const winner = sortedPlayers[0];

                game.state.players.forEach(p => {
                    const key = p.name.toUpperCase();
                    
                    // Initialiser les stats si n√©cessaire
                    if(!stats[key]) {
                        stats[key] = { 
                            wins: 0, played: 0, totalScoreSum: 0, highestScore: 0,
                            highestRound: 0, lowestRound: Infinity, roundScores: [],
                            totalRounds: 0, gameScores: []
                        };
                        streaks[key] = { current: 0, best: 0 };
                    }

                    // Stats de base
                    stats[key].played++;
                    stats[key].totalScoreSum += p.total;
                    stats[key].highestScore = Math.max(stats[key].highestScore, p.total);
                    stats[key].gameScores.push(p.total);

                    // Scores de manches en une seule passe
                    for (const round of game.state.history) {
                        const roundScore = round[p.id] || 0;
                        stats[key].roundScores.push(roundScore);
                        stats[key].totalRounds++;
                        if (roundScore > stats[key].highestRound) stats[key].highestRound = roundScore;
                        if (roundScore > 0 && roundScore < stats[key].lowestRound) stats[key].lowestRound = roundScore;
                    }

                    // Victoire
                    if(winner && p.id === winner.id) {
                        stats[key].wins++;
                        streaks[key].current++;
                        streaks[key].best = Math.max(streaks[key].best, streaks[key].current);
                    } else {
                        // R√©initialiser la s√©rie courante
                        streaks[key].current = 0;
                    }
                });
            });

            // Calcul final optimis√©
            return Object.entries(stats).map(([name, data]) => {
                const avgPerRound = data.totalRounds > 0 
                    ? Math.round(data.roundScores.reduce((a,b)=>a+b,0) / data.totalRounds) 
                    : 0;
                
                // √âcart-type simplifi√©
                const variance = data.roundScores.length > 0 
                    ? data.roundScores.reduce((acc, val) => acc + (val - avgPerRound) ** 2, 0) / data.roundScores.length 
                    : 0;
                const regularityScore = Math.max(0, Math.min(5, 5 - Math.floor((Math.sqrt(variance) / 50) * 5)));
                
                // Forme r√©cente
                const recentGames = data.gameScores.slice(-5);
                const olderGames = data.gameScores.slice(0, -5);
                const recentAvg = recentGames.length ? recentGames.reduce((a,b)=>a+b,0) / recentGames.length : 0;
                const olderAvg = olderGames.length ? olderGames.reduce((a,b)=>a+b,0) / olderGames.length : recentAvg;
                const formPercent = olderAvg !== 0 ? Math.round(((recentAvg - olderAvg) / olderAvg) * 100) : 0;
                
                return {
                    name,
                    ...data,
                    winRate: data.played ? Math.round((data.wins / data.played) * 100) : 0,
                    avgPerRound,
                    lowestRound: data.lowestRound === Infinity ? 0 : data.lowestRound,
                    regularityScore,
                    regularityStars: '‚≠ê'.repeat(regularityScore) + '‚òÜ'.repeat(5 - regularityScore),
                    currentStreak: streaks[name]?.current || 0,
                    bestStreak: streaks[name]?.best || 0,
                    formPercent,
                    formTrend: formPercent > 0 ? '‚ÜóÔ∏è' : formPercent < 0 ? '‚ÜòÔ∏è' : '‚û°Ô∏è'
                };
            }).sort((a,b)=>b.winRate - a.winRate);
        },
        getRecordScores(mode = 'all') {
            const stats = this.calculateStats(mode);
            return stats.sort((a,b) => b.highestScore - a.highestScore).slice(0, 10);
        },
        calculateGameHighlights(state, victoryCondition = 'highest') {
            const isLowest = victoryCondition === 'lowest';
            const highlights = [];
            let bestRound = { score: 0, player: null, roundIdx: 0 };
            state.history.forEach((round, idx) => {
                state.players.forEach(p => {
                    if(round[p.id] > bestRound.score) bestRound = { score: round[p.id], player: p, roundIdx: idx + 1 };
                });
            });
            if(bestRound.player) highlights.push({ icon: 'üî•', label: 'Meilleure manche', value: `${bestRound.player.name} - ${bestRound.score} pts (M${bestRound.roundIdx})`, color: bestRound.player.color });
            
            const rankProgression = {};
            state.players.forEach(p => {
                const ranks = [state.players.length];
                state.history.forEach((round, histIdx) => {
                    const totals = state.players.map(pl => {
                        let c = 0;
                        state.history.slice(0, histIdx + 1).forEach(r => c += r[pl.id] || 0);
                        return { id: pl.id, total: c };
                    }).sort((a,b) => isLowest ? a.total - b.total : b.total - a.total);
                    ranks.push(totals.findIndex(t => t.id === p.id) + 1);
                });
                const maxRank = Math.max(...ranks);
                const finalRank = ranks[ranks.length - 1];
                rankProgression[p.id] = { player: p, improvement: maxRank - finalRank, maxRank, finalRank };
            });
            const comeback = Object.values(rankProgression).sort((a,b) => b.improvement - a.improvement)[0];
            if(comeback && comeback.improvement > 0) highlights.push({ icon: '‚ö°', label: 'Comeback King', value: `${comeback.player.name} (${comeback.maxRank}e ‚Üí ${comeback.finalRank}e)`, color: comeback.player.color });

            const consistency = state.players.map(p => {
                const scores = state.history.map(r => r[p.id] || 0).filter(s => s > 0);
                if(scores.length === 0) return { player: p, std: Infinity };
                const mean = scores.reduce((a,b) => a+b, 0) / scores.length;
                const variance = scores.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0) / scores.length;
                return { player: p, std: Math.sqrt(variance), mean };
            }).sort((a,b) => a.std - b.std)[0];
            if(consistency && consistency.std !== Infinity) highlights.push({ icon: 'üéØ', label: 'Joueur r√©gulier', value: `${consistency.player.name} (${Math.round(consistency.mean)} pts/manche)`, color: consistency.player.color });
            
            if(state.history.length >= 20) highlights.push({ icon: 'üèÉ', label: 'Partie Marathon', value: `${state.history.length} manches jou√©es`, color: 'var(--primary)' });
            return highlights;
        }
    };

    // ==================== UI LAYER AM√âLIOR√â ====================
    const UI = {
        currentStatsMode: 'all',
        
        // === INDICATEUR DE CHARGEMENT ===
        showLoading(message = 'G√©n√©ration en cours...') {
            const overlay = document.getElementById('loading-overlay');
            const textEl = document.getElementById('loading-text');
            const progressEl = document.getElementById('loading-progress');
            if (overlay) {
                if (textEl) textEl.textContent = message;
                if (progressEl) progressEl.textContent = '';
                overlay.classList.add('active');
            }
        },
        
        updateLoadingProgress(progress, message = null) {
            const textEl = document.getElementById('loading-text');
            const progressEl = document.getElementById('loading-progress');
            if (textEl && message) textEl.textContent = message;
            if (progressEl && progress !== null) {
                progressEl.textContent = `${Math.round(progress)}%`;
            }
        },
        
        hideLoading() {
            const overlay = document.getElementById('loading-overlay');
            if (overlay) overlay.classList.remove('active');
        },
        
        showToast(message, type = 'default') {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.className = 'toast show';
            if(type !== 'default') toast.classList.add(type);
            setTimeout(() => toast.classList.remove('show'), 2500);
            if(type === 'success') SoundFX.success();
            else if(type === 'error') SoundFX.error();
        },
        confirm(message, onYes, onNo) {
            SoundFX.click();
            const modal = document.getElementById('confirm-modal');
            const msgEl = document.getElementById('confirm-msg');
            const yesBtn = document.getElementById('confirm-yes-btn');
            msgEl.textContent = message;
            modal.classList.add('active');
            
            // Stocker le callback onNo pour pouvoir l'appeler lors de l'annulation
            this._confirmOnNo = onNo || null;
            
            // Utiliser une fonction nomm√©e pour pouvoir la retirer
            const handleConfirm = () => {
                modal.classList.remove('active');
                yesBtn.removeEventListener('click', handleConfirm);
                this._confirmOnNo = null; // Nettoyer
                onYes();
            };
            
            // Retirer tout ancien handler et ajouter le nouveau
            yesBtn.onclick = null;
            yesBtn.addEventListener('click', handleConfirm);
        },
        closeConfirm() {
            document.getElementById('confirm-modal').classList.remove('active');
            // Appeler le callback onNo si d√©fini (pour annulation)
            if (this._confirmOnNo) {
                this._confirmOnNo();
                this._confirmOnNo = null;
            }
        },
        
        showStats() {
            SoundFX.click();
            document.getElementById('stats-modal').classList.add('active');
            this.switchStatsTab('rank'); 
        },
        closeStats() { document.getElementById('stats-modal').classList.remove('active'); },
        showSettings() {
            SoundFX.click();
            document.getElementById('settings-modal').classList.add('active');
            this.updateSettingsUI();
        },
        closeSettings() { document.getElementById('settings-modal').classList.remove('active'); },
        updateSettingsUI() {
            const themeBtn = document.getElementById('settings-theme-btn');
            const soundBtn = document.getElementById('settings-sound-btn');
            const vibrationBtn = document.getElementById('settings-vibration-btn');
            const confettiBtn = document.getElementById('settings-confetti-btn');
            const milestonesBtn = document.getElementById('settings-milestones-btn');
            const chartBtn = document.getElementById('settings-chart-btn');
            const tempScoreBtn = document.getElementById('settings-tempScore-btn');
            
            // V√©rifier si le mode sombre est actif
            const theme = document.documentElement.getAttribute('data-theme');
            const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
            const isDark = theme === 'dark' || (theme !== 'light' && prefersDark);
            
            if (themeBtn) themeBtn.classList.toggle('active', isDark);
            if (soundBtn) soundBtn.classList.toggle('active', SoundFX.enabled);
            if (vibrationBtn) vibrationBtn.classList.toggle('active', app.settings.vibration);
            if (confettiBtn) confettiBtn.classList.toggle('active', app.settings.confetti);
            if (milestonesBtn) milestonesBtn.classList.toggle('active', app.settings.milestones);
            if (chartBtn) chartBtn.classList.toggle('active', app.settings.showChart);
            if (tempScoreBtn) tempScoreBtn.classList.toggle('active', app.settings.showTempScore);
        },
        switchStatsTab(tab) {
            SoundFX.click();
            document.getElementById('tab-rank').classList.remove('active');
            document.getElementById('tab-records').classList.remove('active');
            document.getElementById('stats-content-rank').classList.add('hidden');
            document.getElementById('stats-content-records').classList.add('hidden');
            document.getElementById('stats-content-player').classList.add('hidden');

            if(tab === 'rank') {
                document.getElementById('tab-rank').classList.add('active');
                this.renderRanking();
                document.getElementById('stats-content-rank').classList.remove('hidden');
            } else if (tab === 'records') {
                document.getElementById('tab-records').classList.add('active');
                this.renderRecords();
                document.getElementById('stats-content-records').classList.remove('hidden');
            }
        },
        showRanking() {
            SoundFX.click();
            this.switchStatsTab('rank');
        },
        filterStats(mode) {
            this.currentStatsMode = mode;
            document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
            document.querySelector(`.filter-btn[onclick="UI.filterStats('${mode}')"]`)?.classList.add('active');
            this.renderRanking();
        },
        renderRanking() {
            const data = StatsEngine.calculateStats(this.currentStatsMode);
            const container = document.getElementById('stats-content-rank');
            container.innerHTML = '';
            if(data.length === 0) { container.innerHTML = '<p class="text-center" style="color:var(--text-sec); padding:20px;">Aucune statistique disponible</p>'; return; }
            data.forEach((p, idx) => {
                const streakEmoji = p.currentStreak >= 3 ? 'üî•' : p.currentStreak > 0 ? '‚ö°' : '';
                const formIndicator = p.formPercent > 10 ? '‚ÜóÔ∏è' : p.formPercent < -10 ? '‚ÜòÔ∏è' : '';
                
                const el = document.createElement('div');
                el.className = `rank-item rank-${idx+1}`;
                el.onclick = () => this.renderPlayerDetail(p.name);
                el.innerHTML = `
                    <div class="rank-num">${idx+1}</div>
                    <div class="rank-info">
                        <div class="rank-name">${p.name} ${streakEmoji}${p.currentStreak > 0 ? p.currentStreak : ''}</div>
                        <div class="rank-sub">${p.played} parties ‚Ä¢ Moy. ${p.avgPerRound} pts/manche ${formIndicator}</div>
                    </div>
                    <div class="rank-val" style="color:${p.winRate >= 50 ? 'var(--success)' : 'var(--text)'}">${p.winRate}%</div>
                `;
                container.appendChild(el);
            });
        },
        renderPlayerDetail(name) {
            const allStats = StatsEngine.calculateStats();
            const p = allStats.find(s => s.name === name);
            if(!p) return;
            document.getElementById('stats-content-rank').classList.add('hidden');
            document.getElementById('stats-content-player').classList.remove('hidden');
            document.getElementById('stats-content-records').classList.add('hidden');
            const container = document.getElementById('player-detail-content');
            
            const streakColor = p.currentStreak >= 3 ? 'var(--danger)' : p.currentStreak > 0 ? 'var(--primary)' : 'var(--text)';
            const formColor = p.formPercent > 10 ? 'var(--success)' : p.formPercent < -10 ? 'var(--danger)' : 'var(--text)';
            
            container.innerHTML = `
                <h2 class="text-huge" style="margin:0 0 20px 0;">${name}</h2>
                
                <div style="display:grid; grid-template-columns: 1fr 1fr; gap:12px; margin-bottom:20px;">
                    <div class="stat-detail">
                        <h4 style="font-size:11px; color:var(--text-sec); margin:0 0 5px 0; font-weight:600;">TAUX VICTOIRE</h4>
                        <div class="value" style="font-size:32px; font-weight:900; color:var(--primary);">${p.winRate}%</div>
                    </div>
                    <div class="stat-detail">
                        <h4 style="font-size:11px; color:var(--text-sec); margin:0 0 5px 0; font-weight:600;">S√âRIE ACTUELLE</h4>
                        <div class="value" style="font-size:32px; font-weight:900; color:${streakColor};">${p.currentStreak > 0 ? 'üî• ' : ''}${p.currentStreak}</div>
                    </div>
                </div>
                
                <div style="background:var(--card); border:1px solid var(--border); border-radius:16px; padding:15px; margin-bottom:15px;">
                    <h3 style="font-size:14px; font-weight:700; margin:0 0 12px 0; color:var(--text);">üìä Statistiques D√©taill√©es</h3>
                    <div style="display:grid; gap:10px;">
                        <div style="display:flex; justify-content:space-between; align-items:center;">
                            <span style="font-size:13px; color:var(--text-sec);">Score moyen/manche</span>
                            <span style="font-size:15px; font-weight:700;">${p.avgPerRound} pts</span>
                        </div>
                        <div style="display:flex; justify-content:space-between; align-items:center;">
                            <span style="font-size:13px; color:var(--text-sec);">Meilleur score (manche)</span>
                            <span style="font-size:15px; font-weight:700; color:var(--success);">üèÜ ${p.highestRound} pts</span>
                        </div>
                        <div style="display:flex; justify-content:space-between; align-items:center;">
                            <span style="font-size:13px; color:var(--text-sec);">Pire score (manche)</span>
                            <span style="font-size:15px; font-weight:700; color:var(--danger);">${p.lowestRound} pts</span>
                        </div>
                        <div style="display:flex; justify-content:space-between; align-items:center;">
                            <span style="font-size:13px; color:var(--text-sec);">R√©gularit√©</span>
                            <span style="font-size:15px; font-weight:700;">${p.regularityStars}</span>
                        </div>
                        <div style="display:flex; justify-content:space-between; align-items:center;">
                            <span style="font-size:13px; color:var(--text-sec);">Meilleure s√©rie</span>
                            <span style="font-size:15px; font-weight:700;">üèÖ ${p.bestStreak} victoire${p.bestStreak > 1 ? 's' : ''}</span>
                        </div>
                        <div style="display:flex; justify-content:space-between; align-items:center;">
                            <span style="font-size:13px; color:var(--text-sec);">Forme r√©cente</span>
                            <span style="font-size:15px; font-weight:700; color:${formColor};">${p.formTrend} ${p.formPercent > 0 ? '+' : ''}${p.formPercent}%</span>
                        </div>
                    </div>
                </div>
                
                <div style="background:var(--card); border:1px solid var(--border); border-radius:16px; padding:15px;">
                    <h3 style="font-size:14px; font-weight:700; margin:0 0 12px 0; color:var(--text);">üéÆ Historique</h3>
                    <div style="display:grid; gap:10px;">
                        <div style="display:flex; justify-content:space-between; align-items:center;">
                            <span style="font-size:13px; color:var(--text-sec);">Victoires</span>
                            <span style="font-size:15px; font-weight:700; color:var(--success);">${p.wins} üèÜ</span>
                        </div>
                        <div style="display:flex; justify-content:space-between; align-items:center;">
                            <span style="font-size:13px; color:var(--text-sec);">Parties jou√©es</span>
                            <span style="font-size:15px; font-weight:700;">${p.played}</span>
                        </div>
                        <div style="display:flex; justify-content:space-between; align-items:center;">
                            <span style="font-size:13px; color:var(--text-sec);">Manches jou√©es</span>
                            <span style="font-size:15px; font-weight:700;">${p.totalRounds}</span>
                        </div>
                        <div style="display:flex; justify-content:space-between; align-items:center;">
                            <span style="font-size:13px; color:var(--text-sec);">Record (partie)</span>
                            <span style="font-size:15px; font-weight:700; color:var(--primary);">${p.highestScore} pts</span>
                        </div>
                    </div>
                </div>
            `;
        },
        filterRecords(mode) {
            this.currentStatsMode = mode;
            document.querySelectorAll('.filter-btn-records').forEach(b => b.classList.remove('active'));
            document.querySelector(`.filter-btn-records[onclick="UI.filterRecords('${mode}')"]`)?.classList.add('active');
            this.renderRecords();
        },
        renderRecords() {
            const data = StatsEngine.getRecordScores(this.currentStatsMode || 'all');
            const container = document.getElementById('stats-content-records');
            container.innerHTML = '';
            if(data.length === 0) { container.innerHTML = '<p class="text-center" style="color:var(--text-sec); padding:20px;">Aucun record.</p>'; return; }
            
            // Trouver les records sp√©ciaux
            const bestAvg = [...data].sort((a,b) => b.avgPerRound - a.avgPerRound)[0];
            const bestStreak = [...data].sort((a,b) => b.bestStreak - a.bestStreak)[0];
            const mostRegular = [...data].sort((a,b) => b.regularityScore - a.regularityScore)[0];
            
            // Afficher les records sp√©ciaux en haut
            container.innerHTML += `
                <div style="margin-bottom:20px;">
                    <h3 style="font-size:14px; font-weight:700; margin:0 0 12px 0; color:var(--text);">üèÜ Records Sp√©ciaux</h3>
                    <div style="display:grid; gap:8px;">
                        <div style="background:var(--card); border:1px solid var(--border); border-radius:12px; padding:12px; display:flex; justify-content:space-between; align-items:center;">
                            <div>
                                <div style="font-size:11px; color:var(--text-sec); font-weight:600;">MEILLEURE MOYENNE</div>
                                <div style="font-size:15px; font-weight:700; margin-top:3px;">${bestAvg.name}</div>
                            </div>
                            <div style="font-size:20px; font-weight:900; color:var(--primary);">${bestAvg.avgPerRound}</div>
                        </div>
                        <div style="background:var(--card); border:1px solid var(--border); border-radius:12px; padding:12px; display:flex; justify-content:space-between; align-items:center;">
                            <div>
                                <div style="font-size:11px; color:var(--text-sec); font-weight:600;">MEILLEURE S√âRIE</div>
                                <div style="font-size:15px; font-weight:700; margin-top:3px;">${bestStreak.name}</div>
                            </div>
                            <div style="font-size:20px; font-weight:900; color:var(--danger);">üî• ${bestStreak.bestStreak}</div>
                        </div>
                        <div style="background:var(--card); border:1px solid var(--border); border-radius:12px; padding:12px; display:flex; justify-content:space-between; align-items:center;">
                            <div>
                                <div style="font-size:11px; color:var(--text-sec); font-weight:600;">PLUS R√âGULIER</div>
                                <div style="font-size:15px; font-weight:700; margin-top:3px;">${mostRegular.name}</div>
                            </div>
                            <div style="font-size:18px; font-weight:900;">${mostRegular.regularityStars}</div>
                        </div>
                    </div>
                </div>
                
                <h3 style="font-size:14px; font-weight:700; margin:0 0 12px 0; color:var(--text);">üéØ Meilleurs Scores (Partie)</h3>
            `;
            
            data.forEach((p, idx) => {
                const el = document.createElement('div');
                el.className = 'rank-item';
                el.innerHTML = `
                    <div class="rank-info">
                        <div class="rank-name">${p.name}</div>
                        <div class="rank-sub">Meilleure manche: ${p.highestRound} pts</div>
                    </div>
                    <div class="rank-val">${p.highestScore}</div>
                `;
                container.appendChild(el);
            });
        },
        renderScoreCards(state, editIdx = null) {
            const isLowest = app.currentGame.victoryCondition === 'lowest';
            
            // Calculer le score corrig√© pour l'affichage
            const getDisplayScore = (p) => {
                if (editIdx !== null && state.temp[p.id] !== undefined) {
                    // En mode √©dition: total - ancienne valeur + nouvelle valeur
                    const oldRoundValue = state.history[editIdx]?.[p.id] || 0;
                    const newRoundValue = state.temp[p.id] || 0;
                    return p.total - oldRoundValue + newRoundValue;
                }
                return p.total + (state.temp[p.id] || 0);
            };
            
            // Toujours trier selon victoryCondition, m√™me en mode Zen
            const sorted = [...state.players].sort((a,b) => {
                const scoreA = getDisplayScore(a);
                const scoreB = getDisplayScore(b);
                return isLowest ? scoreA - scoreB : scoreB - scoreA;
            });
            const grid = document.getElementById('grid');
            const rankChanges = new Set();
            app.lastRanks = app.lastRanks || {};

            state.players.forEach(p => {
                const newRank = sorted.findIndex(s => s.id === p.id);
                if(app.lastRanks[p.id] !== undefined && app.lastRanks[p.id] !== newRank) {
                    rankChanges.add(p.id);
                }
                app.lastRanks[p.id] = newRank;
            });
            grid.innerHTML = '';
            // En mode Zen, afficher dans l'ordre tri√© pour que les badges soient corrects
            const displayOrder = sorted;
            displayOrder.forEach(p => {
                const totalScore = getDisplayScore(p);
                const oldRoundValue = editIdx !== null ? (state.history[editIdx]?.[p.id] || 0) : 0;
                const tempScore = editIdx !== null ? (state.temp[p.id] || 0) - oldRoundValue : (state.temp[p.id] || 0);
                const rankIdx = sorted.findIndex(s => s.id === p.id);
                let badgeClass = 'badge-none', badgeText = '#' + (rankIdx + 1);
                if(rankIdx === 0) { badgeClass = 'badge-1'; badgeText = 'ü•á'; }
                else if(rankIdx === 1) { badgeClass = 'badge-2'; badgeText = 'ü•à'; }
                else if(rankIdx === 2) { badgeClass = 'badge-3'; badgeText = 'ü•â'; }
                const card = document.createElement('div');
                card.className = `p-card ${state.dealerId === p.id ? 'is-dealer' : ''}`;
                if(rankChanges.has(p.id) && !app.focusMode) card.classList.add('rank-change');
                const tempScoreDisplay = app.settings.showTempScore ? 
                    `<div class="p-temp">${tempScore ? (tempScore > 0 ? '+' + tempScore : tempScore) : ''}</div>` : '';
                card.innerHTML = `
                    <div class="rank-badge ${badgeClass} ${rankChanges.has(p.id) ? 'bounce' : ''}">${badgeText}</div>
                    <div class="p-name-btn" style="color:${p.color}; border-color:${p.color}40" onclick="app.openModal(${p.id})">${p.name}</div>
                    <div class="p-score ${tempScore !== 0 ? 'score-bump' : ''}" onclick="app.openSheet(${p.id})">${totalScore}</div>
                    ${tempScoreDisplay}
                    ${state.dealerId === p.id ? '<div style="position:absolute; top:8px; right:8px; font-size:12px;">üÉè</div>' : ''}
                `;
                grid.appendChild(card);
            });
        },
        renderHistory(state, editIdx) {
            const hist = document.getElementById('history');
            hist.innerHTML = '';
            state.history.slice().reverse().forEach((r, i) => {
                const idx = state.history.length - 1 - i;
                const isEditing = idx === editIdx;
                const row = document.createElement('div');
                row.className = 'h-row';
                row.style.borderColor = isEditing ? 'var(--dealer)' : 'var(--border)';
                let scoresHtml = '';
                state.players.forEach(p => {
                    const score = isEditing && state.temp[p.id] !== undefined ? state.temp[p.id] : (r[p.id] || 0);
                    scoresHtml += `
                        <div class="h-score-item">
                            <div style="font-size:7px; color:${p.color}; font-weight:900; opacity:0.7">${p.name.substring(0,4)}</div>
                            <div style="color:${p.color}; font-weight:800; font-size:14px;">${score}</div>
                        </div>
                    `;
                });
                row.innerHTML = `
                    <div class="h-idx">M${idx+1}</div>
                    <div class="h-scores" onclick="app.startEdit(${idx})">${scoresHtml}</div>
                    <button onclick="app.delRound(${idx})" style="border:none; background:none; color:var(--danger); font-size:18px; padding-left:10px; flex-shrink:0;">√ó</button>
                `;
                hist.appendChild(row);
            });
        },
        renderChart(state, editIdx) {
            const ctx = document.getElementById('chart');
            const chartBox = ctx?.closest('.chart-box');
            if(!ctx || typeof Chart === 'undefined') return;
            
            // Masquer le graphique si le param√®tre est d√©sactiv√©
            if (chartBox) {
                chartBox.style.display = app.settings.showChart ? '' : 'none';
            }
            if (!app.settings.showChart) return;
            
            // Pr√©parer les donn√©es
            let allValues = [0];
            const datasets = state.players.map(p => {
                let cumul = 0;
                const data = [0];
                state.history.forEach((h, idx) => {
                    if(idx === editIdx && state.temp[p.id] !== undefined) cumul += state.temp[p.id];
                    else cumul += (h[p.id] || 0);
                    data.push(cumul);
                    allValues.push(cumul);
                });
                if(Object.keys(state.temp).length > 0 && editIdx === null) {
                    const tempTotal = cumul + (state.temp[p.id] || 0);
                    data.push(tempTotal);
                    allValues.push(tempTotal);
                }
                return {
                    label: p.name, data, borderColor: p.color, backgroundColor: p.color + '20', tension: 0.4, pointRadius: 3, pointHoverRadius: 6, borderWidth: 2.5, fill: false
                };
            });
            
            // Calculer les limites min/max
            const minValue = Math.min(...allValues);
            const maxValue = Math.max(...allValues);
            const padding = Math.max(Math.abs(maxValue - minValue) * 0.1, 10);
            const hasNegativeScores = minValue < 0;
            const yMin = hasNegativeScores ? Math.floor((minValue - padding) / 50) * 50 : 0;
            const yMax = Math.max(Math.ceil((maxValue + padding) / 50) * 50, 50);
            
            const labels = ['0', ...state.history.map((_, i) => 'M' + (i + 1))];
            if(Object.keys(state.temp).length > 0 && editIdx === null) labels.push('...');
            
            // OPTIMISATION: Utiliser update() si le chart existe d√©j√†
            if (app.chart) {
                app.chart.data.labels = labels;
                app.chart.data.datasets = datasets;
                app.chart.options.scales.y.min = yMin;
                app.chart.options.scales.y.max = yMax;
                app.chart.update('none'); // 'none' = pas d'animation pour performance
            } else {
                // Cr√©er le chart seulement s'il n'existe pas
                app.chart = new Chart(ctx, {
                    type: 'line',
                    data: { labels, datasets },
                    options: {
                        responsive: true, maintainAspectRatio: false,
                        interaction: { mode: 'index', intersect: false },
                        plugins: { legend: { display: false }, tooltip: { backgroundColor: 'rgba(0,0,0,0.8)', padding: 12, titleFont: { size: 14, weight: 'bold' }, bodyFont: { size: 13 } } },
                        scales: { 
                            x: { grid: { display: false }, ticks: { font: { size: 10, weight: '700' }, color: '#86868B' } }, 
                            y: { 
                                min: yMin,
                                max: yMax,
                                beginAtZero: !hasNegativeScores, 
                                grid: { color: 'rgba(128,128,128,0.08)' }, 
                                ticks: { font: { size: 10, weight: '600' }, color: '#86868B' } 
                            } 
                        },
                        animation: { duration: 400 }
                    }
                });
            }
        },
        switchVictoryTab(tab) {
            SoundFX.click();
            document.querySelectorAll('.victory-tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('[id^="victory-tab-"]').forEach(t => t.classList.add('hidden'));
            const tabIndex = { podium: 1, stats: 2, highlights: 3 };
            document.querySelector(`.victory-tab:nth-child(${tabIndex[tab]})`).classList.add('active');
            document.getElementById(`victory-tab-${tab}`).classList.remove('hidden');
        },
        showVictory(winner, score, state) {
            SoundFX.success();
            const overlay = document.getElementById('victory');
            const isLowest = state.victoryCondition === 'lowest';
            const sorted = [...state.players].sort((a,b) => isLowest ? a.total - b.total : b.total - a.total);
            const podium = document.getElementById('podium');
            podium.innerHTML = '';
            
            // === D√âTECTION DES √âGALIT√âS ===
            const ties = [];
            const winningScore = sorted[0].total;
            sorted.forEach((p, idx) => {
                if (p.total === winningScore) {
                    ties.push({ player: p, rank: idx + 1 });
                }
            });
            
            // Si √©galit√©, afficher un message sp√©cial
            if (ties.length > 1) {
                UI.showToast(`ü§ù √âGALIT√â ! ${ties.length} joueurs √† ${winningScore} pts`, 'info');
            }
            
            // Ordre podium: 2√®me (gauche), 1er (centre), 3√®me (droite)
            const top3 = [sorted[1], sorted[0], sorted[2]].filter(p => p);
            top3.forEach((p) => {
                if(!p) return;
                // Calculer le rang correct en tenant compte des √©galit√©s
                let realRank = 1;
                for(let i = 0; i < sorted.length; i++) {
                    // Pour les √©galit√©s, tous les joueurs avec le m√™me score ont le m√™me rang
                    if(sorted[i].total === p.total) {
                        realRank = i + 1;
                        break;
                    }
                    if(sorted[i].id === p.id) {
                        realRank = i + 1;
                        break;
                    }
                }
                
                // V√©rifier si ce joueur est √† √©galit√©
                const isTied = ties.length > 1 && ties.find(t => t.player.id === p.id);
                
                const place = document.createElement('div');
                place.className = `podium-place p${realRank}`;
                place.innerHTML = `
                    <div class="podium-avatar" style="background:${p.color}30; border:3px solid ${p.color};">
                        ${realRank === 1 ? '<div class="podium-crown">üëë</div>' : ''}
                        ${isTied ? '<div style="position:absolute; top:-8px; right:-8px; font-size:12px;">ü§ù</div>' : ''}
                        <span style="color:${p.color}">${p.name.substring(0,2)}</span>
                    </div>
                    <div class="podium-name" style="color:${p.color}">${p.name}${isTied ? ' ü§ù' : ''}</div>
                    <div class="podium-score" style="color:${p.color}">${p.total}</div>
                    <div class="podium-bar">
                        ${realRank === 1 ? 'ü•á' : realRank === 2 ? 'ü•à' : 'ü•â'}
                    </div>
                `;
                podium.appendChild(place);
            });

            const allPlayersDiv = document.getElementById('victory-all-players');
            allPlayersDiv.innerHTML = '';
            sorted.forEach((p, idx) => {
                const stats = this.calculatePlayerGameStats(p, state);
                const bestLabel = isLowest ? 'Pire' : 'Meilleur';
                const row = document.createElement('div');
                row.className = 'player-stats-row';
                row.innerHTML = `
                    <div class="player-stats-rank" style="color:${idx < 3 ? p.color : 'var(--text-sec)'}">${idx+1}</div>
                    <div class="player-stats-info">
                        <div class="player-stats-name" style="color:${p.color}">${p.name}</div>
                        <div style="font-size:11px; color:var(--text-sec);">${bestLabel}: ${stats.best} ‚Ä¢ Moy: ${stats.avg} ‚Ä¢ Manches gagn√©es: ${stats.roundsWon}</div>
                    </div>
                    <div class="player-stats-score" style="color:${p.color}">${p.total}</div>
                `;
                allPlayersDiv.appendChild(row);
            });

            const highlights = StatsEngine.calculateGameHighlights(state, state.victoryCondition);
            const highlightsDiv = document.getElementById('victory-highlights');
            highlightsDiv.innerHTML = '';
            if(highlights.length === 0) {
                highlightsDiv.innerHTML = '<p class="text-center" style="color:var(--text-sec); padding:20px;">Aucun highlight.</p>';
            } else {
                highlights.forEach(h => {
                    const card = document.createElement('div');
                    card.className = 'highlight-card';
                    card.innerHTML = `
                        <div class="highlight-icon">${h.icon}</div>
                        <div class="highlight-text">
                            <div class="highlight-label">${h.label}</div>
                            <div class="highlight-value" style="color:${h.color}">${h.value}</div>
                        </div>
                    `;
                    highlightsDiv.appendChild(card);
                });
            }
            overlay.classList.add('active');
            this.switchVictoryTab('podium');
            if(app.settings.confetti) this.launchFireworks();
            if(app.settings.vibration && navigator.vibrate) navigator.vibrate([100, 50, 100, 50, 200]);
        },
        calculatePlayerGameStats(player, state) {
            const isLowest = state.victoryCondition === 'lowest';
            const scores = state.history.map(r => r[player.id] || 0);
            const nonZero = scores.filter(s => s > 0);
            // Pour le meilleur score: si tous les scores sont n√©gatifs, prendre le max (le moins n√©gatif)
            const best = isLowest 
                ? Math.min(...scores.filter(s => s > 0), 0) 
                : (scores.length > 0 ? Math.max(...scores) : 0);
            const avg = nonZero.length > 0 ? Math.round(nonZero.reduce((a,b) => a+b, 0) / nonZero.length) : 0;
            let roundsWon = 0;
            state.history.forEach(round => {
                const roundScores = state.players.map(p => round[p.id] || 0);
                const targetScore = isLowest ? Math.min(...roundScores.filter(s => s > 0)) : Math.max(...roundScores);
                if(round[player.id] === targetScore && targetScore > 0) roundsWon++;
            });
            return { best, avg, roundsWon };
        },
        closeVictory() { document.getElementById('victory').classList.remove('active'); },
        launchFireworks() {
            const duration = 5000;
            const end = Date.now() + duration;
            const colors = ['#007AFF', '#FF2D55', '#34C759', '#FF9500', '#AF52DE', '#FFD700'];
            (function frame() {
                confetti({ particleCount:3, angle: 60, spread: 55, origin: { x: 0, y: 0.8 }, colors: colors });
                confetti({ particleCount:3, angle: 120, spread: 55, origin: { x: 1, y: 0.8 }, colors: colors });
                if (Date.now() < end) requestAnimationFrame(frame);
            })();
            confetti({ particleCount: 100, spread: 70, origin: { y: 0.6 }, colors: colors });
        },
        launchMilestoneConfetti(score) {
            const colors = ['#007AFF', '#FF2D55', '#34C759', '#FF9500', '#AF52DE', '#FFD700'];
            confetti({ particleCount: 60, spread: 60, origin: { y: 0.6 }, colors: colors });
            let milestone = '';
            if(score >= 1000) milestone = 'üéâ 1000 POINTS !';
            else if(score >= 500) milestone = 'üéä 500 POINTS !';
            else if(score >= 200) milestone = '‚ú® 200 POINTS !';
            if(app.settings.vibration && navigator.vibrate) {
                if(score >= 1000) navigator.vibrate([50, 100, 50, 100, 50]);
                else if(score >= 500) navigator.vibrate([50, 100, 50]);
                else navigator.vibrate(100);
            }
            if(milestone) this.showToast(milestone);
        }
    };

    // ==================== GAME PRESETS ====================
    const GAME_PRESETS = {
        tarot: { 
            name: "Tarot", 
            victory: "highest", 
            endType: "score", 
            endValue: 1000, 
            icon: "üÉè", 
            tag: "Objectif 1000",
            players: 4
        },
        papayoo: { 
            name: "Papayoo", 
            victory: "lowest", 
            endType: "free", 
            endValue: null, 
            icon: "üçê", 
            tag: "Partie libre"
        },
        six_qui_prend: { 
            name: "6 qui prend !", 
            victory: "lowest", 
            endType: "score", 
            endValue: 66, 
            icon: "üêÇ", 
            tag: "Limite 66" 
        },
        flip_7: { 
            name: "Flip 7", 
            victory: "highest", 
            endType: "score", 
            endValue: 200, 
            icon: "üîÑ", 
            tag: "Objectif 200" 
        },
        skyjo: { 
            name: "Skyjo", 
            victory: "lowest", 
            endType: "score", 
            endValue: 100, 
            icon: "üü¶", 
            tag: "Limite 100" 
        },
        scrabble: { 
            name: "Scrabble", 
            victory: "highest", 
            endType: "free", 
            endValue: null, 
            icon: "üÖ∞Ô∏è", 
            tag: "Partie libre" 
        },
        molkky: { 
            name: "M√∂lkky", 
            victory: "highest", 
            endType: "score", 
            endValue: 50, 
            icon: "ü™µ", 
            tag: "Exactement 50" 
        },
        petanque: { 
            name: "P√©tanque", 
            victory: "highest", 
            endType: "score", 
            endValue: 13, 
            icon: "‚ö™", 
            tag: "13 points" 
        },
        rummy: { 
            name: "Rami", 
            victory: "highest", 
            endType: "score", 
            endValue: 500, 
            icon: "üé¥", 
            tag: "Objectif 500" 
        },
        uno: { 
            name: "Uno", 
            victory: "lowest", 
            endType: "score", 
            endValue: 500, 
            icon: "üåà", 
            tag: "Limite 500" 
        }
    };

    // ==================== APP CONTROLLER ====================
    const app = {
        currentGame: null, activePlayerId: null, editIdx: null, chart: null, savedPlayers: {}, focusMode: false,
        recentPlayers: [], // Les 8 derniers noms de joueurs utilis√©s
        
        // Param√®tres par d√©faut
        settings: {
            vibration: true,
            confetti: true,
            milestones: true,
            showChart: true,
            showTempScore: true
        },
        lastRanks: {}, // Pour le suivi des animations de rang
        pendingPreset: null, // Preset en attente lors de la s√©lection du nombre de joueurs
        tempCustomMode: null, // Configuration temporaire pour la sauvegarde de mode personnalis√©

        // Noms par d√©faut √† ne pas sugg√©rer
        defaultNames: ['NOUS', 'EUX', 'J1', 'J2', 'J3', 'J4', 'J5', 'J6', 'J7', 'J8', 'J9', 'J10', 'J11', 'J12'],

        // D√©marrage rapide Belote (2 √©quipes)
        quickStartBelote() {
            SoundFX.click();
            this.createGame('belote', 2);
        },

        init() {
            Storage.checkStorageAvailability();
            Storage.migrateData();
            
            // Initialiser le moteur sonore
            SoundFX.init();
            
            let savedTheme = null;
            try { savedTheme = localStorage.getItem('sm_theme'); } catch(e) {}
            if(savedTheme) { document.documentElement.setAttribute('data-theme', savedTheme); this.updateThemeIcon(); }
            
            // Charger la pr√©f√©rence son
            try {
                const savedSound = localStorage.getItem('sm_sound');
                if (savedSound !== null) {
                    SoundFX.enabled = savedSound === '1';
                }
                this.updateSoundIcon();
            } catch(e) {}
            
            // Charger les param√®tres
            try {
                const savedSettings = localStorage.getItem('sm_settings');
                if (savedSettings) {
                    this.settings = { ...this.settings, ...JSON.parse(savedSettings) };
                }
            } catch(e) {}
            
            try {
                const savedPlayersData = localStorage.getItem('sm_saved_players');
                if(savedPlayersData) { this.savedPlayers = JSON.parse(savedPlayersData); }
            } catch(e) { console.warn("Corrupt saved players data", e); this.savedPlayers = {}; }

            // Charger les joueurs r√©cents
            try {
                const recentData = localStorage.getItem('sm_recent_players');
                if(recentData) { this.recentPlayers = JSON.parse(recentData); }
            } catch(e) { console.warn("Corrupt recent players data", e); this.recentPlayers = []; }

            const game = Storage.loadCurrentGame();
            if(game) { 
                // Migration des anciennes parties
                if(!game.victoryCondition) {
                    game.victoryCondition = 'highest';
                }
                if(!game.endCondition) {
                    game.endCondition = game.mode === 'belote' ? { type: 'score', value: 1000 } : { type: 'free', value: null };
                }
                this.currentGame = game; 
                this.showGame(); 
            } else { 
                this.showSetup(); 
            }
            this.renderGamesList();
        },
        toggleTheme() {
            const root = document.documentElement;
            const currentTheme = root.getAttribute('data-theme');
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            root.setAttribute('data-theme', newTheme);
            try {
                if (Storage.storageAvailable) {
                    localStorage.setItem('sm_theme', newTheme);
                }
            } catch(e) {
                console.warn('Impossible de sauvegarder le th√®me:', e);
            }
            this.updateThemeIcon();
            if(app.settings.vibration && navigator.vibrate) navigator.vibrate(30);
        },
        updateThemeIcon() {
            // Met √† jour le toggle dans le modal param√®tres si ouvert
            UI.updateSettingsUI();
        },
        toggleSound() {
            SoundFX.enabled = !SoundFX.enabled;
            try {
                if (Storage.storageAvailable) {
                    localStorage.setItem('sm_sound', SoundFX.enabled ? '1' : '0');
                }
            } catch(e) {
                console.warn('Impossible de sauvegarder le son:', e);
            }
            this.updateSoundIcon();
            if(app.settings.vibration && navigator.vibrate) navigator.vibrate(30);
        },
        updateSoundIcon() {
            // Met √† jour le toggle dans le modal param√®tres si ouvert
            UI.updateSettingsUI();
        },
        toggleSetting(key) {
            this.settings[key] = !this.settings[key];
            this.saveSettings();
            if(this.settings.vibration && navigator.vibrate) navigator.vibrate(30);
        },
        saveSettings() {
            try {
                localStorage.setItem('sm_settings', JSON.stringify(this.settings));
            } catch(e) {
                console.warn('Impossible de sauvegarder les param√®tres:', e);
            }
        },
        clearRecentPlayers() {
            SoundFX.click();
            UI.confirm('Effacer la liste des joueurs r√©cents ?', () => {
                this.recentPlayers = [];
                try {
                    localStorage.removeItem('sm_recent_players');
                } catch(e) {}
                UI.showToast('üóëÔ∏è Joueurs r√©cents effac√©s', 'success');
            });
        },
        resetStats() {
            SoundFX.click();
            UI.confirm('R√©initialiser tous les classements et records ?', () => {
                try {
                    // Supprimer les donn√©es de statistiques
                    localStorage.removeItem('sm_player_stats');
                    
                    // Parcourir toutes les parties et r√©initialiser les flags
                    const games = Storage.loadGames();
                    if (games) {
                        games.forEach(game => {
                            if (game.state && game.state.celebratedMilestones) {
                                game.state.celebratedMilestones = {};
                            }
                        });
                        localStorage.setItem(Storage.GAMES_KEY, JSON.stringify(games));
                    }
                    
                    UI.showToast('üìä Statistiques r√©initialis√©es', 'success');
                } catch(e) {
                    console.error('Erreur reset stats:', e);
                    UI.showToast('‚ùå Erreur lors de la r√©initialisation', 'error');
                }
            });
        },
        exportData() {
            SoundFX.click();
            try {
                const data = {
                    version: 1,
                    exportDate: new Date().toISOString(),
                    games: Storage.loadGames(),
                    currentGame: Storage.loadCurrentGame(),
                    settings: this.settings,
                    savedPlayers: this.savedPlayers,
                    recentPlayers: this.recentPlayers,
                    sound: SoundFX.enabled,
                    theme: localStorage.getItem('sm_theme')
                };
                
                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `ScoreMaster_Export_${new Date().toISOString().split('T')[0]}.json`;
                a.click();
                URL.revokeObjectURL(url);
                
                UI.showToast('üì§ Donn√©es export√©es !', 'success');
            } catch(e) {
                console.error('Erreur export:', e);
                UI.showToast('‚ùå Erreur lors de l\'export', 'error');
            }
        },
        importData(input) {
            const file = input.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = JSON.parse(e.target.result);
                    
                    // V√©rifier la version
                    if (!data.version) {
                        throw new Error('Format de fichier invalide');
                    }
                    
                    // Importer les donn√©es
                    if (data.games) {
                        localStorage.setItem(Storage.GAMES_KEY, JSON.stringify(data.games));
                    }
                    if (data.currentGame) {
                        localStorage.setItem(Storage.CURRENT_KEY, JSON.stringify(data.currentGame));
                    }
                    if (data.settings) {
                        this.settings = { ...this.settings, ...data.settings };
                        this.saveSettings();
                    }
                    if (data.savedPlayers) {
                        this.savedPlayers = data.savedPlayers;
                        localStorage.setItem('sm_saved_players', JSON.stringify(data.savedPlayers));
                    }
                    if (data.recentPlayers) {
                        this.recentPlayers = data.recentPlayers;
                        localStorage.setItem('sm_recent_players', JSON.stringify(data.recentPlayers));
                    }
                    if (data.sound !== undefined) {
                        SoundFX.enabled = data.sound;
                        localStorage.setItem('sm_sound', data.sound ? '1' : '0');
                    }
                    if (data.theme) {
                        localStorage.setItem('sm_theme', data.theme);
                        document.documentElement.setAttribute('data-theme', data.theme);
                    }
                    
                    UI.showToast('üì• Donn√©es import√©es !', 'success');
                    UI.closeSettings();
                    
                    // Recharger l'affichage
                    setTimeout(() => {
                        this.init();
                        this.showSetup();
                    }, 500);
                    
                } catch(err) {
                    console.error('Erreur import:', err);
                    UI.showToast('‚ùå Fichier invalide', 'error');
                }
            };
            reader.readAsText(file);
            input.value = ''; // Reset pour permettre de r√©importer le m√™me fichier
        },
        updateThemeColor() {
            const theme = document.documentElement.getAttribute('data-theme');
            const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
            const isDark = theme === 'dark' || (theme !== 'light' && prefersDark);
            document.querySelectorAll('meta[name="theme-color"]').forEach(meta => {
                meta.setAttribute('content', isDark ? '#000000' : '#F5F5F7');
            });
        },
        showSetup() {
            UI.closeVictory();
            this.focusMode = false;
            document.body.classList.remove('focus-mode');
            document.getElementById('dock').classList.add('hidden');
            
            // Sauvegarder la partie en cours avant de quitter
            if(this.currentGame && !this.currentGame.finished) {
                Storage.saveGame(this.currentGame);
            }
            
            // D√©truire le chart pour √©viter les fuites m√©moire
            if (this.chart) {
                this.chart.destroy();
                this.chart = null;
            }
            
            this.currentGame = null;
            this.editIdx = null;
            document.getElementById('setup').classList.remove('hidden');
            document.getElementById('game').classList.add('hidden');
            this.renderGamesList();
        },
        // === GESTION DES PRESETS ===
        getPresetStats() {
            // R√©cup√©rer les statistiques d'utilisation des presets
            try {
                const stats = localStorage.getItem('sm_preset_stats');
                return stats ? JSON.parse(stats) : {};
            } catch(e) {
                return {};
            }
        },
        getCustomPresets() {
            // R√©cup√©rer les presets personnalis√©s
            try {
                const custom = localStorage.getItem('sm_custom_presets');
                return custom ? JSON.parse(custom) : {};
            } catch(e) {
                return {};
            }
        },
        saveCustomPreset(key, preset) {
            const custom = this.getCustomPresets();
            custom[key] = preset;
            try {
                localStorage.setItem('sm_custom_presets', JSON.stringify(custom));
                return true;
            } catch(e) {
                return false;
            }
        },
        deleteCustomPreset(key) {
            const custom = this.getCustomPresets();
            delete custom[key];
            try {
                localStorage.setItem('sm_custom_presets', JSON.stringify(custom));
                // Supprimer aussi des stats
                const stats = this.getPresetStats();
                delete stats[key];
                localStorage.setItem('sm_preset_stats', JSON.stringify(stats));
                return true;
            } catch(e) {
                return false;
            }
        },
        getHiddenPresets() {
            // Liste des presets cach√©s par l'utilisateur
            try {
                const hidden = localStorage.getItem('sm_hidden_presets');
                return hidden ? JSON.parse(hidden) : [];
            } catch(e) {
                return [];
            }
        },
        hidePreset(key) {
            const hidden = this.getHiddenPresets();
            if (!hidden.includes(key)) {
                hidden.push(key);
                try {
                    localStorage.setItem('sm_hidden_presets', JSON.stringify(hidden));
                    return true;
                } catch(e) {
                    return false;
                }
            }
            return true;
        },
        unhidePreset(key) {
            const hidden = this.getHiddenPresets();
            const index = hidden.indexOf(key);
            if (index > -1) {
                hidden.splice(index, 1);
                try {
                    localStorage.setItem('sm_hidden_presets', JSON.stringify(hidden));
                    return true;
                } catch(e) {
                    return false;
                }
            }
            return true;
        },
        getAllPresets() {
            // Combiner les presets par d√©faut et personnalis√©s
            const custom = this.getCustomPresets();
            return { ...GAME_PRESETS, ...custom };
        },
        savePresetUsage(key) {
            // Sauvegarder l'utilisation d'un preset
            const stats = this.getPresetStats();
            stats[key] = {
                count: (stats[key]?.count || 0) + 1,
                lastUsed: Date.now()
            };
            try {
                localStorage.setItem('sm_preset_stats', JSON.stringify(stats));
            } catch(e) {}
        },
        getSortedPresets() {
            const stats = this.getPresetStats();
            const hidden = this.getHiddenPresets();
            const allPresets = this.getAllPresets();
            
            // Filtrer les presets cach√©s
            const presets = Object.entries(allPresets).filter(([key]) => !hidden.includes(key));
            
            // Trier par nombre d'utilisations (d√©croissant) puis par derni√®re utilisation
            return presets.sort(([keyA, gameA], [keyB, gameB]) => {
                const statA = stats[keyA] || { count: 0, lastUsed: 0 };
                const statB = stats[keyB] || { count: 0, lastUsed: 0 };
                
                // D'abord par count d√©croissant
                if (statA.count !== statB.count) {
                    return statB.count - statA.count;
                }
                // Ensuite par derni√®re utilisation d√©croissante
                return statB.lastUsed - statA.lastUsed;
            });
        },
        openPresets() {
            this.refreshPresetsGrid();
            document.getElementById('preset-modal').classList.add('active');
        },
        refreshPresetsGrid() {
            const grid = document.getElementById('presets-grid');
            grid.innerHTML = '';
            
            // Reset le mode √©dition
            grid.classList.remove('edit-mode');
            document.getElementById('preset-edit-btn').classList.remove('active');
            
            const sortedPresets = this.getSortedPresets();
            
            // Les 2 premiers sont les favoris (les plus jou√©s)
            const favorites = sortedPresets.slice(0, 2);
            const others = sortedPresets.slice(2);
            
            // Ajouter les favoris
            if (favorites.length > 0) {
                const favTitle = document.createElement('div');
                favTitle.className = 'preset-section-title';
                favTitle.textContent = '‚≠ê Vos favoris';
                grid.appendChild(favTitle);
                
                favorites.forEach(([key, game]) => {
                    grid.appendChild(this.createPresetCard(key, game));
                });
            }
            
            // Ajouter les autres jeux (tri√©s par derni√®re utilisation)
            if (others.length > 0) {
                const otherTitle = document.createElement('div');
                otherTitle.className = 'preset-section-title';
                otherTitle.textContent = 'üéÆ Tous les jeux';
                grid.appendChild(otherTitle);
                
                others.forEach(([key, game]) => {
                    grid.appendChild(this.createPresetCard(key, game));
                });
            }
            
            // Ajouter la carte "Personnaliser" √† la fin
            const customCard = document.createElement('div');
            customCard.className = 'preset-card custom';
            customCard.onclick = () => this.openCustomSetup();
            customCard.innerHTML = `
                <span class="preset-icon">‚öôÔ∏è</span>
                <span class="preset-name">Personnaliser</span>
                <span class="preset-tag">Cr√©er votre config</span>
            `;
            grid.appendChild(customCard);
            
            // Ajouter bouton restaurer si des jeux sont masqu√©s
            const hidden = this.getHiddenPresets();
            if (hidden.length > 0) {
                const restoreBtn = document.createElement('button');
                restoreBtn.className = 'preset-restore-btn';
                restoreBtn.innerHTML = `‚Ü©Ô∏è Restaurer ${hidden.length} jeu${hidden.length > 1 ? 'x' : ''} masqu√©${hidden.length > 1 ? 's' : ''}`;
                restoreBtn.onclick = () => this.showHiddenPresets();
                grid.appendChild(restoreBtn);
            }
        },
        showHiddenPresets() {
            const hidden = this.getHiddenPresets();
            if (hidden.length === 0) return;
            
            const allPresets = this.getAllPresets();
            
            // Cr√©er un modal pour afficher les jeux masqu√©s
            const existingModal = document.getElementById('hidden-presets-modal');
            if (existingModal) existingModal.remove();
            
            const modal = document.createElement('div');
            modal.id = 'hidden-presets-modal';
            modal.className = 'modal-overlay active';
            modal.style.zIndex = '11000';
            modal.onclick = (e) => {
                if (e.target === modal) modal.remove();
            };
            
            let gamesList = '';
            hidden.forEach(key => {
                const game = allPresets[key];
                if (game) {
                    gamesList += `
                        <div style="display:flex; align-items:center; justify-content:space-between; padding:12px; background:var(--card); border-radius:12px; margin-bottom:8px;">
                            <div style="display:flex; align-items:center; gap:10px;">
                                <span style="font-size:24px;">${game.icon}</span>
                                <span style="font-weight:700;">${game.name}</span>
                            </div>
                            <button onclick="app.restorePreset('${key}')" style="padding:8px 16px; background:var(--success); color:white; border:none; border-radius:8px; font-weight:700; cursor:pointer;">Restaurer</button>
                        </div>
                    `;
                }
            });
            
            modal.innerHTML = `
                <div class="modal-box" style="max-width: 340px;">
                    <h3 style="margin:0 0 15px 0; text-align:center;">‚Ü©Ô∏è Jeux masqu√©s</h3>
                    <div style="max-height: 300px; overflow-y: auto;">
                        ${gamesList || '<p style="text-align:center; color:var(--text-sec);">Aucun jeu masqu√©</p>'}
                    </div>
                    <button onclick="document.getElementById('hidden-presets-modal').remove()" style="width:100%; margin-top:15px; padding:14px; background:var(--card); color:var(--text); border:1px solid var(--border); border-radius:14px; font-size:14px; font-weight:700; cursor:pointer;">Fermer</button>
                </div>
            `;
            document.body.appendChild(modal);
        },
        restorePreset(key) {
            this.unhidePreset(key);
            const allPresets = this.getAllPresets();
            const game = allPresets[key];
            UI.showToast(`‚Ü©Ô∏è ${game?.name || 'Jeu'} restaur√©`, 'success');
            
            // Rafra√Æchir le modal des jeux masqu√©s
            this.showHiddenPresets();
            // Rafra√Æchir la grille principale SANS fermer le modal (√©vite le flash)
            this.refreshPresetsGrid();
        },
        createPresetCard(key, game) {
            const card = document.createElement('div');
            const isCustom = game.custom === true;
            card.className = 'preset-card' + (isCustom ? ' custom-mode' : '');
            
            // Ajouter le bouton de suppression √† toutes les cartes
            const deleteBtn = document.createElement('button');
            deleteBtn.className = 'preset-delete';
            deleteBtn.textContent = '‚úï';
            deleteBtn.onclick = (e) => {
                e.stopPropagation();
                this.confirmDeletePreset(key, game.name, isCustom);
            };
            card.appendChild(deleteBtn);
            
            card.onclick = () => this.applyPreset(key);
            
            const content = document.createElement('div');
            content.innerHTML = `
                <span class="preset-icon">${game.icon}</span>
                <span class="preset-name">${game.name}</span>
                <span class="preset-tag">${game.tag}</span>
            `;
            card.appendChild(content);
            
            return card;
        },
        confirmDeletePreset(key, name, isCustom) {
            const title = isCustom ? 'Supprimer' : 'Masquer';
            
            // Message court pour le modal (textContent ne g√®re pas les \n)
            UI.confirm(`${title} "${name}" ?`, () => {
                if (isCustom) {
                    this.deleteCustomPreset(key);
                } else {
                    this.hidePreset(key);
                }
                UI.showToast(`üóëÔ∏è ${name} ${isCustom ? 'supprim√©' : 'masqu√©'}`, 'success');
                // Rafra√Æchir la grille sans fermer le modal
                this.refreshPresetsGrid();
            });
        },
        togglePresetEditMode() {
            const grid = document.getElementById('presets-grid');
            const btn = document.getElementById('preset-edit-btn');
            
            grid.classList.toggle('edit-mode');
            btn.classList.toggle('active');
            
            // Feedback sonore
            SoundFX.click();
        },
        closePresets() {
            const grid = document.getElementById('presets-grid');
            grid.classList.remove('edit-mode');
            document.getElementById('preset-edit-btn').classList.remove('active');
            document.getElementById('preset-modal').classList.remove('active');
        },
        applyPreset(key) {
            const allPresets = this.getAllPresets();
            const game = allPresets[key];
            if (!game) return;
            
            SoundFX.click();
            this.closePresets();
            
            // Enregistrer l'utilisation
            this.savePresetUsage(key);
            
            // Si le jeu a un nombre de joueurs d√©fini, cr√©er directement la partie
            if (game.players) {
                this.createGameWithPreset(key, game);
            } else {
                // Sinon, ouvrir le modal de s√©lection du nombre de joueurs avec les pr√©-configurations
                this.openPlayerCountWithPreset(key, game);
            }
        },
        createGameWithPreset(key, game) {
            this.currentGame = {
                id: Date.now().toString(),
                name: game.name,
                mode: 'standard',
                date: new Date().toISOString(),
                victoryCondition: game.victory,
                endCondition: { type: game.endType, value: game.endValue },
                state: GameState.create('standard', game.players),
                finished: false,
                preset: key
            };
            
            // Appliquer les joueurs sauvegard√©s si disponibles
            const savedKey = `standard_${game.players}`;
            if(this.savedPlayers[savedKey]) {
                const saved = this.savedPlayers[savedKey];
                this.currentGame.state.players.forEach((p, idx) => {
                    if(saved[idx]) { p.name = saved[idx].name; p.color = saved[idx].color; }
                });
            }
            
            if(!Storage.saveGame(this.currentGame)) {
                UI.showToast('‚ö†Ô∏è Erreur de sauvegarde', 'error');
                return;
            }
            
            UI.showToast(`üéÆ ${game.name} configur√© !`, 'success');
            this.showGame();
        },
        openPlayerCountWithPreset(key, game) {
            // Pr√©-configurer les options dans le modal player count
            document.getElementById('mode-setup-title').textContent = game.name;
            
            // Afficher le bouton retour
            document.getElementById('btn-back-to-presets').classList.remove('hidden');
            
            // D√©finir la victoire (highest/lowest)
            const victoryRadio = document.querySelector(`input[name="victory-condition"][value="${game.victory}"]`);
            if (victoryRadio) victoryRadio.checked = true;
            this.updateVictoryCondition();
            
            // D√©finir le type de fin
            const endRadio = document.querySelector(`input[name="end-condition"][value="${game.endType}"]`);
            if (endRadio) endRadio.checked = true;
            this.updateEndCondition();
            
            // D√©finir le score cible si applicable, sinon r√©initialiser
            const scoreInput = document.getElementById('score-target');
            if (game.endType === 'score' && game.endValue) {
                scoreInput.value = game.endValue;
            } else {
                scoreInput.value = 100; // Valeur par d√©faut
            }
            
            // Stocker le preset pour l'utiliser lors de la cr√©ation
            this.pendingPreset = { key, game };
            
            document.getElementById('modal-player-count').classList.add('active');
        },
        openCustomSetup() {
            SoundFX.click();
            this.closePresets();
            
            // Afficher le bouton retour
            document.getElementById('btn-back-to-presets').classList.remove('hidden');
            
            // Reset des options
            document.getElementById('mode-setup-title').textContent = 'Mode Personnalis√©';
            document.querySelector('input[name="victory-condition"][value="highest"]').checked = true;
            document.querySelector('input[name="end-condition"][value="free"]').checked = true;
            document.getElementById('score-target').value = 100;
            this.updateVictoryCondition();
            this.updateEndCondition();
            
            this.pendingPreset = null;
            document.getElementById('modal-player-count').classList.add('active');
        },
        backToPresets() {
            SoundFX.click();
            // Cacher le bouton retour
            document.getElementById('btn-back-to-presets').classList.add('hidden');
            // Fermer le modal player count
            document.getElementById('modal-player-count').classList.remove('active');
            // R√©ouvrir le modal presets
            this.openPresets();
        },
        closePlayerCountModal() {
            document.getElementById('modal-player-count').classList.remove('active');
            document.getElementById('btn-back-to-presets').classList.add('hidden');
            this.pendingPreset = null;
        },
        // === SAUVEGARDE MODE PERSONNALIS√â ===
        openSaveCustomModal() {
            // R√©cup√©rer les valeurs actuelles
            const victory = document.querySelector('input[name="victory-condition"]:checked')?.value || 'highest';
            const endType = document.querySelector('input[name="end-condition"]:checked')?.value || 'free';
            const endValue = endType === 'score' ? parseInt(document.getElementById('score-target').value) : null;
            
            // Stocker temporairement
            this.tempCustomMode = { victory, endType, endValue };
            
            // Reset le formulaire
            document.getElementById('custom-mode-name').value = '';
            document.getElementById('custom-mode-emoji').value = 'üéÆ';
            
            // Reset les emojis s√©lectionn√©s
            document.querySelectorAll('.emoji-option').forEach(btn => btn.classList.remove('selected'));
            document.querySelector('.emoji-option').classList.add('selected');
            
            // Reset le bouton "+" √† son √©tat initial
            const addBtn = document.querySelector('.emoji-add');
            if (addBtn) {
                addBtn.textContent = '+';
                addBtn.classList.remove('selected');
            }
            
            document.getElementById('save-custom-modal').classList.add('active');
        },
        selectEmoji(emoji, event) {
            document.getElementById('custom-mode-emoji').value = emoji;
            document.querySelectorAll('.emoji-option').forEach(btn => btn.classList.remove('selected'));
            if (event && event.currentTarget) {
                event.currentTarget.classList.add('selected');
            }
            
            // Reset le bouton "+" √† son √©tat initial
            const addBtn = document.querySelector('.emoji-add');
            if (addBtn) {
                addBtn.textContent = '+';
            }
        },
        openCustomEmojiPicker() {
            // Cr√©er un modal temporaire avec un input visible pour iOS
            const existingModal = document.getElementById('emoji-input-modal');
            if (existingModal) existingModal.remove();
            
            const modal = document.createElement('div');
            modal.id = 'emoji-input-modal';
            modal.className = 'modal-overlay active';
            modal.style.zIndex = '11000';
            modal.onclick = (e) => {
                if (e.target === modal) {
                    modal.remove();
                }
            };
            modal.innerHTML = `
                <div class="modal-box" style="max-width: 300px;">
                    <h3 style="margin:0 0 15px 0; text-align:center;">üé® Choisissez un emoji</h3>
                    <input type="text" id="emoji-text-input" placeholder="Tapez votre emoji" maxlength="2" 
                           style="width: 100%; padding: 15px; border: 2px solid var(--primary); border-radius: 14px; 
                                  font-size: 32px; text-align: center; background: var(--bg); color: var(--text); 
                                  box-sizing: border-box; margin-bottom: 15px;">
                    <div style="display: flex; gap: 10px;">
                        <button id="emoji-cancel-btn" style="flex: 1; padding: 14px; background: var(--card); color: var(--text); 
                                       border: 1px solid var(--border); border-radius: 14px; font-size: 14px; 
                                       font-weight: 700; cursor: pointer;">Annuler</button>
                        <button id="emoji-confirm-btn" style="flex: 1; padding: 14px; background: var(--primary); color: white; 
                                       border: none; border-radius: 14px; font-size: 14px; 
                                       font-weight: 700; cursor: pointer;">‚úì OK</button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
            
            // Ajouter les √©v√©nements aux boutons
            document.getElementById('emoji-cancel-btn').onclick = () => modal.remove();
            document.getElementById('emoji-confirm-btn').onclick = () => this.confirmCustomEmoji();
            
            // Focus l'input apr√®s un court d√©lai (pour iOS)
            setTimeout(() => {
                const input = document.getElementById('emoji-text-input');
                if (input) input.focus();
            }, 100);
        },
        confirmCustomEmoji() {
            const input = document.getElementById('emoji-text-input');
            const modal = document.getElementById('emoji-input-modal');
            if (!input || !modal) return;
            
            const emoji = input.value.trim();
            if (emoji) {
                document.getElementById('custom-mode-emoji').value = emoji;
                // Mettre √† jour le bouton "+" avec l'emoji choisi
                const addBtn = document.querySelector('.emoji-add');
                if (addBtn) {
                    addBtn.textContent = emoji;
                    addBtn.classList.add('selected');
                }
                document.querySelectorAll('.emoji-option:not(.emoji-add)').forEach(btn => btn.classList.remove('selected'));
            } else {
                UI.showToast('‚ö†Ô∏è Veuillez entrer un emoji', 'warning');
                return;
            }
            modal.remove();
        },
        saveCustomMode() {
            const name = document.getElementById('custom-mode-name').value.trim();
            const emoji = document.getElementById('custom-mode-emoji').value;
            
            if (!name) {
                UI.showToast('‚ö†Ô∏è Veuillez entrer un nom', 'warning');
                return;
            }
            
            if (!emoji || emoji.trim() === '') {
                UI.showToast('‚ö†Ô∏è Veuillez choisir un emoji', 'warning');
                return;
            }
            
            if (!this.tempCustomMode) {
                UI.showToast('‚ö†Ô∏è Erreur: configuration manquante', 'error');
                return;
            }
            
            const { victory, endType, endValue } = this.tempCustomMode;
            
            // Cr√©er le tag
            let tag = '';
            if (endType === 'free') {
                tag = 'Partie libre';
            } else {
                tag = victory === 'lowest' ? `Limite ${endValue}` : `Objectif ${endValue}`;
            }
            
            // G√©n√©rer une cl√© unique
            const key = 'custom_' + Date.now();
            
            // Cr√©er le preset
            const preset = {
                name: name,
                icon: emoji,
                victory: victory,
                endType: endType,
                endValue: endValue,
                tag: tag,
                custom: true
            };
            
            // Sauvegarder
            if (this.saveCustomPreset(key, preset)) {
                UI.showToast(`‚úÖ ${name} sauvegard√© !`, 'success');
                document.getElementById('save-custom-modal').classList.remove('active');
            } else {
                UI.showToast('‚ö†Ô∏è Erreur de sauvegarde', 'error');
            }
            
            this.tempCustomMode = null;
        },
        updateVictoryCondition() {
            const isLowest = document.querySelector('input[name="victory-condition"]:checked')?.value === 'lowest';
            const scoreLabel = document.getElementById('score-label-text');
            const highestLabel = document.getElementById('victory-highest-label');
            const lowestLabel = document.getElementById('victory-lowest-label');
            
            if (this.currentGame?.state) {
                this.currentGame.state.victoryCondition = isLowest ? 'lowest' : 'highest';
            }
            
            highestLabel.style.borderColor = !isLowest ? 'var(--primary)' : 'var(--border)';
            lowestLabel.style.borderColor = isLowest ? 'var(--primary)' : 'var(--border)';
            
            if(isLowest) {
                scoreLabel.textContent = '‚ö†Ô∏è Limite de d√©faite :';
            } else {
                scoreLabel.textContent = 'üéØ Score objectif :';
            }
        },
        updateEndCondition() {
            const endType = document.querySelector('input[name="end-condition"]:checked')?.value;
            const freeLabel = document.getElementById('end-free-label');
            const scoreLabel = document.getElementById('end-score-label');
            
            freeLabel.style.borderColor = endType === 'free' ? 'var(--primary)' : 'var(--border)';
            scoreLabel.style.borderColor = endType === 'score' ? 'var(--primary)' : 'var(--border)';
        },
        toggleMorePlayers() {
            const extraDiv = document.getElementById('extra-players');
            const btn = document.getElementById('btn-toggle-players');
            if (extraDiv.classList.contains('hidden')) { extraDiv.classList.remove('hidden'); btn.textContent = 'Moins ‚ñ≤'; }
            else { extraDiv.classList.add('hidden'); btn.textContent = 'Plus ‚ñº'; }
        },
        selectPlayerCount(count) {
            const victoryCondition = document.querySelector('input[name="victory-condition"]:checked')?.value || 'highest';
            const endType = document.querySelector('input[name="end-condition"]:checked')?.value || 'free';
            
            let scoreTarget = null;
            if (endType === 'score') {
                const inputValue = parseInt(document.getElementById('score-target').value);
                // Validation: score entre 10 et 9999
                if (isNaN(inputValue) || inputValue < 10) {
                    UI.showToast('‚ö†Ô∏è Score minimum : 10 points', 'warning');
                    return;
                }
                if (inputValue > 9999) {
                    UI.showToast('‚ö†Ô∏è Score maximum : 9999 points', 'warning');
                    return;
                }
                scoreTarget = inputValue;
            }
            
            document.getElementById('modal-player-count').classList.remove('active');
            document.getElementById('btn-back-to-presets').classList.add('hidden');
            document.getElementById('extra-players').classList.add('hidden');
            document.getElementById('btn-toggle-players').textContent = 'Plus ‚ñº';
            
            // Utiliser le preset si disponible
            const presetName = this.pendingPreset?.game?.name || null;
            const presetKey = this.pendingPreset?.key || null;
            this.pendingPreset = null;
            
            this.createGame('standard', count, victoryCondition, endType, scoreTarget, presetName, presetKey);
        },
        createGame(mode, playerCount, victoryCondition = 'highest', endType = 'free', scoreTarget = null, presetName = null, presetKey = null) {
            // Cr√©er le state et propager victoryCondition
            const state = GameState.create(mode, playerCount);
            state.victoryCondition = mode === 'belote' ? 'highest' : victoryCondition;
            
            this.currentGame = {
                id: Date.now().toString(),
                name: presetName || (mode === 'belote' ? 'Belote' : 'Partie Standard'),
                mode, 
                date: new Date().toISOString(),
                victoryCondition: state.victoryCondition,
                endCondition: mode === 'belote' ? { type: 'score', value: 1000 } : { type: endType, value: scoreTarget },
                state, 
                finished: false,
                preset: presetKey
            };
            // Appliquer les joueurs sauvegard√©s uniquement si le nombre correspond
            const savedKey = `${mode}_${playerCount}`;
            if(this.savedPlayers[savedKey]) {
                const saved = this.savedPlayers[savedKey];
                this.currentGame.state.players.forEach((p, idx) => {
                    if(saved[idx]) { p.name = saved[idx].name; p.color = saved[idx].color; }
                });
            }
            if(!Storage.saveGame(this.currentGame)) {
                UI.showToast('‚ö†Ô∏è Erreur de sauvegarde (M√©moire pleine)', 'error');
                return;
            }
            this.showGame();
        },
        showGame() {
            document.getElementById('setup').classList.add('hidden');
            document.getElementById('game').classList.remove('hidden');
            document.getElementById('dock').classList.remove('hidden');
            const isBelote = this.currentGame.mode === 'belote';
            // Afficher le nom du jeu (preset ou mode)
            const gameName = this.currentGame.name || (isBelote ? 'BELOTE' : 'STANDARD');
            document.getElementById('mode-title').textContent = gameName.toUpperCase();
            
            // Afficher les infos de la partie
            const gameInfo = document.getElementById('game-info');
            const isLowest = this.currentGame.victoryCondition === 'lowest';
            const endCond = this.currentGame.endCondition;
            let infoText = '';
            
            if(isBelote) {
                infoText = 'üéØ Premier √† 1000 pts';
            } else {
                infoText = isLowest ? '‚¨áÔ∏è Score le plus BAS' : '‚¨ÜÔ∏è Score le plus HAUT';
                if(endCond.type === 'score') {
                    infoText += isLowest ? ` ‚Ä¢ Limite ${endCond.value} pts` : ` ‚Ä¢ Objectif ${endCond.value} pts`;
                }
            }
            gameInfo.textContent = infoText;
            
            document.getElementById('calc-btn').classList.toggle('hidden', !isBelote);
            document.getElementById('btn-82').classList.toggle('hidden', !isBelote);
            document.getElementById('btn-50').classList.toggle('hidden', isBelote);
            document.getElementById('smart-btn').textContent = isBelote ? 'CAPOT' : '+/-';
            this.render();
        },
        toggleFocusMode() {
            SoundFX.click();
            this.focusMode = !this.focusMode;
            const root = document.body;

            if(this.focusMode) { 
                root.classList.add('focus-mode');
                if(app.settings.vibration && navigator.vibrate) navigator.vibrate(20);
            }
            else { 
                root.classList.remove('focus-mode');
            }
        },
        showStats() { UI.showStats(); },
        // Chart avec debounce pour optimiser les performances
        _debouncedRenderChart: debounce(function(state, editIdx) {
            UI.renderChart(state, editIdx);
        }, 100),
        
        render() {
            if(!this.currentGame) return;
            UI.renderScoreCards(this.currentGame.state, this.editIdx);
            UI.renderHistory(this.currentGame.state, this.editIdx);
            // Utiliser le chart avec debounce pour √©viter les re-rendus excessifs
            this._debouncedRenderChart(this.currentGame.state, this.editIdx);
            
            // Mettre √† jour le texte du bouton avec le num√©ro de manche
            const saveBtn = document.getElementById('save-btn');
            if(saveBtn && this.editIdx === null) {
                const nextRound = this.currentGame.state.history.length + 1;
                saveBtn.textContent = `ENREGISTRER MANCHE ${nextRound}`;
            }
        },
        renderGamesList() {
            const games = Storage.loadGames();
            const list = document.getElementById('games-list');
            if(!games || games.length === 0) { list.innerHTML = '<p class="text-center" style="color:var(--text-sec); padding:20px;">Aucune partie enregistr√©e</p>'; return; }
            list.innerHTML = '';
            games.slice().reverse().forEach(game => {
                const isLowest = game.victoryCondition === 'lowest';
                const sortedPlayers = [...game.state.players].sort((a,b) => isLowest ? a.total - b.total : b.total - a.total);
                const winner = sortedPlayers[0];
                const date = new Date(game.date).toLocaleDateString('fr-FR', { day: 'numeric', month: 'short', hour: '2-digit', minute: '2-digit' });
                const modeBadge = game.mode === 'belote' ? '<span class="game-mode-badge badge-belote">üÉè BELOTE</span>' : '<span class="game-mode-badge badge-standard">üé≤ STANDARD</span>';
                const item = document.createElement('div');
                item.className = 'game-item';
                let playersScoresHtml = '';
                sortedPlayers.forEach((p, idx) => {
                    const isWinner = idx === 0;
                    // √âchapper le nom du joueur pour pr√©venir XSS
                    const safeName = escapeHtml(p.name);
                    playersScoresHtml += `<div class="game-player-score" style="background:${p.color}20; color:${p.color}; border: 1px solid ${p.color}40;">${isWinner ? 'üèÜ ' : ''}${safeName}: ${p.total}</div>`;
                });
                // √âchapper le nom de la partie pour pr√©venir XSS
                const safeGameName = escapeHtml(game.name);
                item.innerHTML = `
                    <div onclick="app.loadGame('${game.id}')" style="flex:1; cursor:pointer;">
                        <div style="font-weight:900; font-size:16px; margin-bottom:6px;">${safeGameName} ${game.finished ? '‚úì' : ''} ${modeBadge}</div>
                        <div style="font-size:12px; color:var(--text-sec); margin-bottom:8px;">${date} ‚Ä¢ ${game.state.history.length} manches</div>
                        <div class="game-players-list">${playersScoresHtml}</div>
                    </div>
                    <div class="game-actions"><button onclick="event.stopPropagation(); app.deleteGame('${game.id}')" title="Supprimer">üóëÔ∏è</button></div>
                `;
                list.appendChild(item);
            });
        },
        loadGame(id) {
            SoundFX.click();
            const game = Storage.loadGames().find(g => g.id === id);
            if(game) {
                try {
                    const playerCount = game.state.players.length;
                    const savedKey = `${game.mode}_${playerCount}`;
                    this.savedPlayers[savedKey] = game.state.players.map(p => ({ name: p.name, color: p.color }));
                    localStorage.setItem('sm_saved_players', JSON.stringify(this.savedPlayers));
                    localStorage.setItem(Storage.CURRENT_KEY, id);
                } catch(e) {
                    if (e.name === 'QuotaExceededError') {
                        UI.showToast('‚ö†Ô∏è M√©moire pleine ! Supprimez des parties.', 'error');
                    } else {
                        console.error('localStorage error:', e);
                    }
                }
                
                this.currentGame = game;
                this.showGame();
            } else {
                UI.showToast('‚ö†Ô∏è Partie introuvable', 'error');
            }
        },
        deleteGame(gameId) {
            UI.confirm('Supprimer cette partie ?', () => {
                Storage.deleteGame(gameId);
                UI.showToast('‚úÖ Partie supprim√©e', 'success');
                this.renderGamesList();
            });
        },
        clearAll() {
            UI.confirm("‚ö†Ô∏è Supprimer TOUTES les parties ?", () => {
                try {
                    localStorage.removeItem(Storage.GAMES_KEY);
                    localStorage.removeItem(Storage.CURRENT_KEY);
                } catch(e) {
                    if (Storage.memoryFallback) {
                        Storage.memoryFallback.games = [];
                        Storage.memoryFallback.current = null;
                    }
                }
                UI.showToast('‚úÖ Historique effac√©', 'success');
                this.renderGamesList();
            });
        },
        restartWithSamePlayers() {
            UI.closeVictory();
            if(!this.currentGame) return;
            if(!this.currentGame.finished) { this.currentGame.finished = true; Storage.saveGame(this.currentGame); }
            const oldState = this.currentGame.state;
            const newGame = {
                id: Date.now().toString(),
                name: this.currentGame.name || (this.currentGame.mode === 'belote' ? 'Belote' : 'Partie Standard'),
                mode: this.currentGame.mode, 
                date: new Date().toISOString(),
                victoryCondition: this.currentGame.victoryCondition || 'highest',
                endCondition: this.currentGame.endCondition || { type: 'free', value: null },
                state: { mode: oldState.mode, victoryCondition: oldState.victoryCondition || 'highest', players: oldState.players.map(p => ({ ...p, total: 0, previousRank: null })), history: [], temp: {}, dealerId: oldState.dealerId, celebratedMilestones: {} },
                finished: false,
                preset: this.currentGame.preset || null
            };
            this.currentGame = newGame;
            if(!Storage.saveGame(newGame)) {
                UI.showToast('‚ö†Ô∏è Erreur de sauvegarde (M√©moire pleine)', 'error');
                return;
            }
            UI.showToast('üéÆ Nouvelle partie lanc√©e !', 'success');
            this.render();
        },
        finishGame() {
            if(this.currentGame.state.history.length === 0) { UI.showToast('‚ö†Ô∏è Aucune manche jou√©e', 'warning'); return; }
            this.currentGame.finished = true;
            Storage.saveGame(this.currentGame);
            
            try {
                const playerCount = this.currentGame.state.players.length;
                const savedKey = `${this.currentGame.mode}_${playerCount}`;
                this.savedPlayers[savedKey] = this.currentGame.state.players.map(p => ({ name: p.name, color: p.color }));
                localStorage.setItem('sm_saved_players', JSON.stringify(this.savedPlayers));
            } catch(e) {
                console.error('localStorage error:', e);
            }
            
            const isLowest = this.currentGame.victoryCondition === 'lowest';
            const winner = [...this.currentGame.state.players].sort((a,b) => isLowest ? a.total - b.total : b.total - a.total)[0];
            UI.showVictory(winner, winner.total, this.currentGame.state);
        },
        async shareRecapPNG() {
            if(!this.currentGame || !this.currentGame.finished) {
                UI.showToast("‚ö†Ô∏è Terminez d'abord la partie", 'warning');
                return;
            }
            
            SoundFX.click();
            
            try {
                UI.showLoading('üì∏ G√©n√©ration du PNG...');
                UI.updateLoadingProgress(10, 'Analyse des donn√©es...');
                
                const gameStateWithConfig = { ...this.currentGame.state, victoryCondition: this.currentGame.victoryCondition };
                
                UI.updateLoadingProgress(30, 'Cr√©ation du visuel...');
                // Utiliser le g√©n√©rateur unifi√© en mode statique
                const canvas = UnifiedRecapGenerator.generateStatic(gameStateWithConfig);
                
                if(!canvas) {
                    UI.hideLoading();
                    return;
                }
                
                UI.updateLoadingProgress(80, 'Pr√©paration du partage...');
                const shared = await UnifiedRecapGenerator.shareImage(canvas);
                
                UI.updateLoadingProgress(100, 'Termin√© !');
                
                setTimeout(() => {
                    UI.hideLoading();
                    
                    if(!shared) {
                        UnifiedRecapGenerator.downloadImage(canvas, `ScoreMaster_${new Date().toISOString().split('T')[0]}.png`);
                        UI.showToast('üì• PNG t√©l√©charg√© !', 'success');
                    } else {
                        UI.showToast('‚úÖ PNG partag√© !', 'success');
                    }
                    
                    if(app.settings.vibration && navigator.vibrate) navigator.vibrate([50, 30, 50]);
                }, 300);
                
            } catch (error) {
                UI.hideLoading();
                console.error('[ScoreMaster] Erreur PNG:', error);
                UI.showToast('‚ùå Erreur PNG', 'error');
            }
        },
        async shareRecapGIF() {
            if(!this.currentGame || !this.currentGame.finished) {
                UI.showToast("‚ö†Ô∏è Terminez d'abord la partie", 'warning');
                return;
            }
            
            // Verrou pour emp√™cher double g√©n√©ration (v√©rifi√© au d√©but ET lors du confirm)
            if (this._gifGenerating) {
                UI.showToast('‚è≥ G√©n√©ration en cours...', 'warning');
                return;
            }
            
            // Verrou pour emp√™cher d'ouvrir plusieurs confirms
            if (this._confirmPending) {
                return;
            }
            
            SoundFX.click();
            
            if (typeof gifshot === 'undefined') {
                UI.showToast('‚ùå Biblioth√®que GIF non charg√©e', 'error');
                return;
            }
            
            // Capturer les donn√©es du jeu IMM√âDIATEMENT avant tout confirm
            // (le modal de victoire peut √™tre ferm√© pendant l'attente)
            const savedGameState = { 
                ...this.currentGame.state, 
                victoryCondition: this.currentGame.victoryCondition 
            };
            
            // Marquer qu'un confirm est en attente
            this._confirmPending = true;
            
            const self = this;
            UI.confirm('G√©n√©rer le GIF ? (~15 secondes)', function() {
                // Activer le verrou GIF au moment de la confirmation
                self._gifGenerating = true;
                self._confirmPending = false;
                
                UI.showLoading('üé¨ G√©n√©ration du GIF...');
                UI.updateLoadingProgress(0, 'Initialisation...');
                
                try {
                    UnifiedRecapGenerator.generateAnimated(savedGameState, (progress, message) => {
                        UI.updateLoadingProgress(progress, message);
                    });
                } catch (error) {
                    console.error('[ScoreMaster] Erreur GIF:', error);
                    UI.hideLoading();
                    UI.showToast('‚ùå Erreur: ' + error.message, 'error');
                    self._gifGenerating = false;
                }
                // Note: le verrou sera lib√©r√© par UnifiedRecapGenerator √† la fin de la g√©n√©ration
                // ou apr√®s un timeout de s√©curit√©
                setTimeout(() => { self._gifGenerating = false; }, 30000);
            }, function() {
                // Callback onNo: lib√©rer le flag confirm si l'utilisateur annule
                self._confirmPending = false;
            });
        },
        openModal(playerId) {
            SoundFX.click();
            this.editPlayerId = playerId;
            const player = this.currentGame.state.players.find(p => p.id === playerId);
            document.getElementById('modal-title').textContent = player.name;
            document.getElementById('modal-title').style.color = player.color;
            document.getElementById('edit-name').value = player.name;
            document.getElementById('edit-dealer').checked = (this.currentGame.state.dealerId === playerId);
            this.renderRecentSuggestions(player.name);
            document.getElementById('modal-player').classList.add('active');
        },
        renderRecentSuggestions(currentName) {
            const container = document.getElementById('recent-players-suggestions');
            container.innerHTML = '';
            
            // Noms d√©j√† dans la partie
            const namesInGame = this.currentGame.state.players.map(p => p.name);
            
            // Filtrer les suggestions : pas les noms par d√©faut, pas le nom actuel, pas d√©j√† dans la partie
            const suggestions = this.recentPlayers
                .filter(name => 
                    !this.defaultNames.includes(name) && 
                    name !== currentName &&
                    !namesInGame.includes(name)
                )
                .slice(0, 5);
            
            if(suggestions.length === 0) {
                container.style.display = 'none';
                return;
            }
            
            container.style.display = 'flex';
            
            // Titre de la section
            const title = document.createElement('div');
            title.className = 'recent-suggestions-title';
            title.textContent = 'R√©cents';
            container.appendChild(title);
            
            suggestions.forEach(name => {
                const item = document.createElement('div');
                item.className = 'recent-suggestion-item';
                item.innerHTML = `<span class="add-icon">+</span><span>${name}</span>`;
                item.onclick = () => this.selectSuggestion(name);
                container.appendChild(item);
            });
        },
        selectSuggestion(name) {
            SoundFX.click();
            document.getElementById('edit-name').value = name;
            this.renderRecentSuggestions(name);
        },
        addRecentPlayer(name) {
            // Ne pas ajouter les noms par d√©faut
            if(this.defaultNames.includes(name)) return;
            
            // Retirer si d√©j√† pr√©sent, puis ajouter en premier
            this.recentPlayers = this.recentPlayers.filter(n => n !== name);
            this.recentPlayers.unshift(name);
            
            // Garder seulement les 8 derniers
            this.recentPlayers = this.recentPlayers.slice(0, 8);
            
            // Sauvegarder
            try {
                localStorage.setItem('sm_recent_players', JSON.stringify(this.recentPlayers));
            } catch(e) { console.warn('Erreur sauvegarde recentPlayers', e); }
        },
        closeModal() { document.getElementById('modal-player').classList.remove('active'); },
        savePlayer() {
            SoundFX.click();
            const player = this.currentGame.state.players.find(p => p.id === this.editPlayerId);
            
            // V√©rifier que le joueur existe
            if (!player) {
                UI.showToast('‚ö†Ô∏è Erreur: joueur introuvable', 'error');
                return;
            }
            
            let newName = document.getElementById('edit-name').value.trim().toUpperCase();
            
            // === VALIDATION DU NOM ===
            
            // V√©rifier si le nom est vide
            if (!newName || newName.length === 0) {
                UI.showToast('‚ö†Ô∏è Le nom ne peut pas √™tre vide', 'warning');
                return;
            }
            
            // Limiter la longueur du nom
            if (newName.length > 20) {
                newName = newName.substring(0, 20);
                UI.showToast('‚ö†Ô∏è Nom limit√© √† 20 caract√®res', 'warning');
            }
            
            // V√©rifier les doublons (sauf pour le joueur actuel)
            const duplicate = this.currentGame.state.players.find(p => 
                p.id !== this.editPlayerId && 
                p.name.toUpperCase() === newName
            );
            
            if (duplicate) {
                UI.showToast(`‚ö†Ô∏è "${newName}" existe d√©j√† !`, 'warning');
                return;
            }
            
            // V√©rifier les caract√®res interdits
            const forbiddenChars = /[<>\"'&]/;
            if (forbiddenChars.test(newName)) {
                newName = newName.replace(forbiddenChars, '');
                UI.showToast('‚ö†Ô∏è Caract√®res sp√©ciaux supprim√©s', 'warning');
            }
            
            // Assigner le nom valid√©
            player.name = newName;
            this.addRecentPlayer(newName);
            
            if(document.getElementById('edit-dealer').checked) { 
                this.currentGame.state.dealerId = player.id; 
            }
            
            this.closeModal();
            this.render();
            UI.showToast(`‚úÖ ${newName} mis √† jour`, 'success');
        },
        openSheet(playerId) {
            SoundFX.click();
            this.activePlayerId = playerId;
            const isBelote = this.currentGame.mode === 'belote';
            document.getElementById('calc-btn').classList.toggle('hidden', !isBelote);
            document.getElementById('btn-82').classList.toggle('hidden', !isBelote);
            document.getElementById('btn-50').classList.toggle('hidden', isBelote);
            this.renderSwitcher();
            document.getElementById('sheet').classList.add('active');
        },
        closeSheet() { document.getElementById('sheet').classList.remove('active'); this.render(); },
        renderSwitcher() {
            const cont = document.getElementById('input-switcher');
            cont.innerHTML = '';
            this.currentGame.state.players.forEach(p => {
                const isActive = p.id === this.activePlayerId;
                const tempScore = this.currentGame.state.temp[p.id] || 0;
                const div = document.createElement('div');
                div.className = `sel-box ${isActive ? 'active' : ''}`;
                if(isActive) div.style.setProperty('--p-color', p.color);
                div.onclick = () => { this.activePlayerId = p.id; this.renderSwitcher(); SoundFX.click(); };
                div.innerHTML = `<div style="font-size:10px; font-weight:800; color:${isActive ? p.color : 'var(--text-sec)'}">${p.name}</div><div style="font-size:20px; font-weight:900">${tempScore}</div>`;
                cont.appendChild(div);
            });
        },
        typeNum(n) {
            const current = (this.currentGame.state.temp[this.activePlayerId] || 0).toString();
            const newVal = parseInt((current === '0' ? '' : current) + n);
            if(newVal > 9999) { if(app.settings.vibration && navigator.vibrate) navigator.vibrate([50, 50, 50]); UI.showToast('‚ö†Ô∏è Maximum 9999 points', 'warning'); return; }
            if(newVal < -9999) { if(app.settings.vibration && navigator.vibrate) navigator.vibrate([50, 50, 50]); UI.showToast('‚ö†Ô∏è Minimum -9999 points', 'warning'); return; }
            if(app.settings.vibration && navigator.vibrate) navigator.vibrate(10);
            this.currentGame.state.temp[this.activePlayerId] = newVal;
            this.renderSwitcher();
            this.render();
        },
        addVal(value) {
            const current = this.currentGame.state.temp[this.activePlayerId] || 0;
            const newVal = current + value;
            if(newVal > 9999) { if(app.settings.vibration && navigator.vibrate) navigator.vibrate([50, 50, 50]); UI.showToast('‚ö†Ô∏è Maximum 9999 points', 'warning'); return; }
            if(newVal < -9999) { if(app.settings.vibration && navigator.vibrate) navigator.vibrate([50, 50, 50]); UI.showToast('‚ö†Ô∏è Minimum -9999 points', 'warning'); return; }
            if(app.settings.vibration && navigator.vibrate) navigator.vibrate(20);
            // En mode belote, pas de scores n√©gatifs
            this.currentGame.state.temp[this.activePlayerId] = this.currentGame.mode === 'belote' ? Math.max(0, newVal) : newVal;
            this.renderSwitcher();
            this.render();
        },
        backspace() {
            const current = (this.currentGame.state.temp[this.activePlayerId] || 0).toString();
            const sliced = current.slice(0, -1);
            // G√©rer le cas "-" ou "" qui donnerait NaN avec parseInt
            this.currentGame.state.temp[this.activePlayerId] = (sliced === '' || sliced === '-') ? 0 : parseInt(sliced);
            if(app.settings.vibration && navigator.vibrate) navigator.vibrate(15);
            this.renderSwitcher();
            this.render();
        },
        clearInput() {
            this.currentGame.state.temp[this.activePlayerId] = 0;
            if(app.settings.vibration && navigator.vibrate) navigator.vibrate([30, 50, 30]);
            this.renderSwitcher();
            this.render();
        },
        handleSmart() {
            SoundFX.click();
            if(this.currentGame.mode === 'belote') { this.currentGame.state.temp[this.activePlayerId] = 252; }
            else { const current = this.currentGame.state.temp[this.activePlayerId] || 0; this.currentGame.state.temp[this.activePlayerId] = current * -1; }
            this.renderSwitcher();
            this.render();
        },
        calcRest() {
            SoundFX.click();
            // Ne fonctionne qu'√† 2 joueurs (Belote uniquement)
            const players = this.currentGame.state.players;
            if(players.length !== 2) return; // S√©curit√© explicite
            const otherPlayer = players.find(p => p.id !== this.activePlayerId);
            if(otherPlayer) {
                const currentScore = this.currentGame.state.temp[this.activePlayerId] || 0;
                this.currentGame.state.temp[otherPlayer.id] = Math.max(0, 162 - currentScore);
                this.activePlayerId = otherPlayer.id;
                this.renderSwitcher();
                this.render();
            }
        },
        validateRound() {
            SoundFX.click();
            const state = this.currentGame.state;
            if(Object.keys(state.temp).length === 0) { UI.showToast('‚ö†Ô∏è Aucun score saisi', 'warning'); return; }
            const validation = GameState.validate(state.temp, this.currentGame.mode);
            if(!validation.valid) { UI.showToast(validation.error, 'error'); return; }
            const previousTotals = {};
            state.players.forEach(p => previousTotals[p.id] = p.total);
            
            let roundNumber;
            
            if(this.editIdx !== null) {
                roundNumber = this.editIdx + 1;
                GameState.updateRound(state, this.editIdx, state.temp);
                this.editIdx = null;
                document.getElementById('save-btn').textContent = `ENREGISTRER MANCHE ${state.history.length + 1}`;
                document.getElementById('save-btn').classList.remove('editing');
                UI.showToast(`‚úÖ Manche ${roundNumber} modifi√©e`, 'success');
            } else {
                roundNumber = state.history.length + 1;
                GameState.addRound(state, state.temp);
                
                // Protection findIndex = -1
                const currentIdx = state.players.findIndex(p => p.id === state.dealerId);
                if (currentIdx === -1) {
                    console.warn('Dealer not found, resetting to first player');
                    state.dealerId = state.players[0].id;
                } else {
                    state.dealerId = state.players[(currentIdx + 1) % state.players.length].id;
                }
                
                UI.showToast(`‚úÖ Manche ${roundNumber} enregistr√©e`, 'success');
            }
            // Milestones uniquement en mode 'highest' (pas en mode lowest)
            if(this.currentGame.mode === 'standard' && this.currentGame.victoryCondition === 'highest' && this.settings.milestones) {
                state.players.forEach(p => {
                    const milestones = [200, 500, 1000];
                    milestones.forEach(milestone => {
                        const key = `${p.id}-${milestone}`;
                        if(!state.celebratedMilestones[key] && previousTotals[p.id] < milestone && p.total >= milestone) {
                            state.celebratedMilestones[key] = true;
                            setTimeout(() => UI.launchMilestoneConfetti(milestone), 300);
                        }
                    });
                });
            }
            
            // V√©rifier les conditions de fin de partie
            const endCond = this.currentGame.endCondition;
            const victCond = this.currentGame.victoryCondition;
            let gameEnded = false;
            let winner = null;
            
            if(this.currentGame.mode === 'belote') {
                winner = state.players.find(p => p.total >= 1000);
                if(winner) gameEnded = true;
            } else if(endCond.type === 'score') {
                if(victCond === 'highest') {
                    // Premier √† atteindre l'objectif gagne
                    winner = state.players.find(p => p.total >= endCond.value);
                    if(winner) gameEnded = true;
                } else {
                    // Premier √† d√©passer la limite perd, le plus petit score parmi les autres gagne
                    const overLimit = state.players.filter(p => p.total >= endCond.value);
                    if(overLimit.length > 0) {
                        gameEnded = true;
                        const remaining = state.players.filter(p => p.total < endCond.value);
                        if(remaining.length > 0) {
                            winner = remaining.sort((a,b) => a.total - b.total)[0];
                        } else {
                            // Tous ont d√©pass√©, le plus petit gagne
                            winner = [...state.players].sort((a,b) => a.total - b.total)[0];
                        }
                    }
                }
            }
            
            if(gameEnded && winner) {
                try {
                    const playerCount = state.players.length;
                    const savedKey = `${this.currentGame.mode}_${playerCount}`;
                    this.savedPlayers[savedKey] = state.players.map(p => ({ name: p.name, color: p.color }));
                    localStorage.setItem('sm_saved_players', JSON.stringify(this.savedPlayers));
                } catch(e) {
                    console.error('localStorage error:', e);
                }
                
                this.currentGame.finished = true;
                setTimeout(() => { UI.showVictory(winner, winner.total, state); }, 500);
            }
            
            // Une seule sauvegarde pour tous les cas
            if(!Storage.saveGame(this.currentGame)) {
                UI.showToast('‚ö†Ô∏è Erreur de sauvegarde (M√©moire pleine)', 'error');
            }
            state.temp = {};
            this.render();
        },
        startEdit(idx) {
            SoundFX.click();
            const state = this.currentGame.state;
            if(Object.keys(state.temp).length > 0) {
                UI.confirm('Abandonner la saisie en cours ?', () => {
                    this.editIdx = idx;
                    state.temp = {...state.history[idx]};
                    document.getElementById('save-btn').textContent = `MODIFIER MANCHE ${idx + 1}`;
                    document.getElementById('save-btn').classList.add('editing');
                    this.openSheet(state.players[0].id);
                });
                return;
            }
            this.editIdx = idx;
            state.temp = {...state.history[idx]};
            document.getElementById('save-btn').textContent = `MODIFIER MANCHE ${idx + 1}`;
            document.getElementById('save-btn').classList.add('editing');
            this.openSheet(state.players[0].id);
        },
        delRound(idx) {
            UI.confirm('Supprimer cette manche ?', () => {
                GameState.deleteRound(this.currentGame.state, idx);
                
                // Reset editIdx si n√©cessaire
                if (this.editIdx !== null) {
                    if (this.editIdx === idx) {
                        // On supprime la manche en cours d'√©dition
                        this.editIdx = null;
                        this.currentGame.state.temp = {};
                        document.getElementById('save-btn').textContent = `ENREGISTRER MANCHE ${this.currentGame.state.history.length + 1}`;
                        document.getElementById('save-btn').classList.remove('editing');
                    } else if (this.editIdx > idx) {
                        // La manche √©dit√©e est apr√®s celle supprim√©e, d√©caler l'index
                        this.editIdx--;
                    }
                }
                
                // Sauvegarder apr√®s suppression
                Storage.saveGame(this.currentGame);
                UI.showToast('‚úÖ Manche supprim√©e', 'success');
                this.render();
            });
        },
        undo() {
            const history = this.currentGame.state.history;
            if(history.length > 0) {
                // Undo direct sans confirmation pour une action plus fluide
                GameState.deleteRound(this.currentGame.state, history.length - 1);
                this.lastRanks = {}; // Reset les ranks pour √©viter les animations incorrectes
                Storage.saveGame(this.currentGame);
                UI.showToast('‚Ü©Ô∏è Manche annul√©e', 'success');
                this.render();
            }
        }
    };
    
    // ==================== PWA MANAGER ====================
    const PWA = {
        deferredPrompt: null,
        isInstalled: false,
        
        init() {
            this.checkIfInstalled();
            this.registerServiceWorker();
            this.setupInstallPrompt();
            this.setupUpdateNotification();
            this.addInstallButton();
        },
        
        checkIfInstalled() {
            // V√©rifier si l'app est install√©e
            if (window.matchMedia('(display-mode: standalone)').matches || window.navigator.standalone === true) {
                this.isInstalled = true;
                console.log('[PWA] App install√©e');
            }
        },
        
        async registerServiceWorker() {
            if ('serviceWorker' in navigator) {
                try {
                    const registration = await navigator.serviceWorker.register('./service-worker.js');
                    console.log('[PWA] Service Worker enregistr√©:', registration.scope);
                    
                    // V√©rifier les mises √† jour
                    registration.addEventListener('updatefound', () => {
                        console.log('[PWA] Mise √† jour trouv√©e');
                        const newWorker = registration.installing;
                        newWorker.addEventListener('statechange', () => {
                            if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                                this.showUpdateNotification();
                            }
                        });
                    });
                } catch (error) {
                    console.error('[PWA] Erreur Service Worker:', error);
                }
            }
        },
        
        setupInstallPrompt() {
            window.addEventListener('beforeinstallprompt', (e) => {
                e.preventDefault();
                this.deferredPrompt = e;
                console.log('[PWA] Installation disponible');
                this.showInstallButton();
            });
            
            window.addEventListener('appinstalled', () => {
                console.log('[PWA] App install√©e avec succ√®s');
                this.isInstalled = true;
                this.hideInstallButton();
                UI.showToast('‚úÖ ScoreMaster install√© !', 'success');
            });
        },
        
        async installApp() {
            if (!this.deferredPrompt) {
                console.log('[PWA] Pas de prompt disponible');
                return;
            }
            
            this.deferredPrompt.prompt();
            const { outcome } = await this.deferredPrompt.userChoice;
            console.log('[PWA] Installation:', outcome);
            
            if (outcome === 'accepted') {
                SoundFX.success();
            }
            
            this.deferredPrompt = null;
            this.hideInstallButton();
        },
        
        addInstallButton() {
            // Cr√©er le bouton d'installation si pas encore install√©
            if (!this.isInstalled) {
                const setupContainer = document.getElementById('setup');
                if (setupContainer) {
                    const installBanner = document.createElement('div');
                    installBanner.id = 'install-banner';
                    installBanner.style.cssText = `
                        background: linear-gradient(135deg, var(--primary), #0051D5);
                        color: white;
                        padding: 15px 20px;
                        border-radius: 16px;
                        margin: 20px 0;
                        display: none;
                        align-items: center;
                        gap: 15px;
                        box-shadow: 0 8px 20px rgba(0,122,255,0.3);
                        cursor: pointer;
                        transition: transform 0.2s;
                    `;
                    installBanner.innerHTML = `
                        <div style="font-size: 32px;">üì±</div>
                        <div style="flex: 1;">
                            <div style="font-weight: 900; font-size: 16px; margin-bottom: 3px;">Installer ScoreMaster</div>
                            <div style="font-size: 12px; opacity: 0.9;">Acc√©dez rapidement depuis votre √©cran d'accueil</div>
                        </div>
                        <div style="font-size: 24px;">‚Üí</div>
                    `;
                    installBanner.onclick = () => this.installApp();
                    
                    const firstChild = setupContainer.querySelector('.header-controls');
                    if (firstChild && firstChild.nextSibling) {
                        setupContainer.insertBefore(installBanner, firstChild.nextSibling);
                    }
                }
            }
        },
        
        showInstallButton() {
            const banner = document.getElementById('install-banner');
            if (banner) {
                banner.style.display = 'flex';
                setTimeout(() => {
                    banner.style.animation = 'slideIn 0.4s ease-out';
                }, 100);
            }
        },
        
        hideInstallButton() {
            const banner = document.getElementById('install-banner');
            if (banner) {
                banner.style.display = 'none';
            }
        },
        
        setupUpdateNotification() {
            // √âcouter les messages du Service Worker
            navigator.serviceWorker?.addEventListener('message', (event) => {
                if (event.data.type === 'UPDATE_AVAILABLE') {
                    this.showUpdateNotification();
                }
            });
        },
        
        showUpdateNotification() {
            const updateBanner = document.createElement('div');
            updateBanner.style.cssText = `
                position: fixed;
                top: max(20px, env(safe-area-inset-top));
                left: 50%;
                transform: translateX(-50%);
                background: var(--card);
                border: 2px solid var(--primary);
                padding: 12px 20px;
                border-radius: 16px;
                box-shadow: 0 8px 20px rgba(0,0,0,0.2);
                z-index: 9999;
                display: flex;
                align-items: center;
                gap: 12px;
                max-width: 90%;
                animation: slideIn 0.4s ease-out;
            `;
            updateBanner.innerHTML = `
                <div style="font-size: 20px;">üÜï</div>
                <div style="flex: 1;">
                    <div style="font-weight: 700; font-size: 14px; color: var(--text);">Mise √† jour disponible</div>
                    <div style="font-size: 12px; color: var(--text-sec);">Rechargez pour la derni√®re version</div>
                </div>
                <button onclick="location.reload()" style="background: var(--primary); color: white; border: none; padding: 8px 16px; border-radius: 8px; font-weight: 700; font-size: 12px; cursor: pointer;">
                    RECHARGER
                </button>
            `;
            document.body.appendChild(updateBanner);
            
            // Auto-hide apr√®s 10 secondes
            setTimeout(() => {
                updateBanner.style.opacity = '0';
                updateBanner.style.transition = 'opacity 0.3s';
                setTimeout(() => updateBanner.remove(), 300);
            }, 10000);
        }
    };
    






    // ==================== UNIFIED RECAP GENERATOR V5.0 ====================
    // Design unifi√© pour PNG (statique) et GIF (anim√©)
    // PNG = capture du GIF √† un instant T
    // GIF = m√™me design avec animations d√©coratives
    
    const UnifiedRecapGenerator = {
        // Configuration du design
        CONFIG: {
            WIDTH: 500,
            PADDING: 25,
            FPS: 8,
            DURATION: 4,        // secondes
            BORDER_RADIUS: 16
        },
        
        // Palette de couleurs par genre
        GENRE_COLORS: {
            DOMINATION: { 
                primary: '#DC2626', 
                secondary: '#F59E0B', 
                accent: '#FCD34D',
                gradient: ['#DC2626', '#991B1B']
            },
            THRILLER: { 
                primary: '#F97316', 
                secondary: '#FBBF24', 
                accent: '#FDE68A',
                gradient: ['#F97316', '#EA580C']
            },
            CHAOS: { 
                primary: '#8B5CF6', 
                secondary: '#EC4899', 
                accent: '#F9A8D4',
                gradient: ['#8B5CF6', '#6D28D9']
            },
            COMEBACK: { 
                primary: '#3B82F6', 
                secondary: '#06B6D4', 
                accent: '#67E8F9',
                gradient: ['#3B82F6', '#1D4ED8']
            }
        },
        
        // Particules pour l'animation (r√©initialis√©es √† chaque g√©n√©ration)
        particles: [],
        
        // === ANALYSE DES DONN√âES ===
        analyzeGameData(gameState) {
            const victoryCondition = gameState.victoryCondition || 'highest';
            const isLowest = victoryCondition === 'lowest';
            const players = gameState.players;
            const history = gameState.history;
            
            // Calcul des totaux et courbes
            const totals = {};
            const curves = players.map(() => []);
            const leaders = [];
            
            players.forEach((p, i) => totals[i] = 0);
            
            history.forEach(r => {
                players.forEach((p, i) => {
                    totals[i] += r[p.id] || 0;
                    curves[i].push(totals[i]);
                });
                const sorted = players.map((p, i) => ({ i, t: totals[i] }))
                    .sort((a, b) => isLowest ? a.t - b.t : b.t - a.t);
                leaders.push(sorted[0].i);
            });
            
            // D√©tection du genre
            let changes = 0;
            for (let i = 1; i < leaders.length; i++) {
                if (leaders[i] != leaders[i - 1]) changes++;
            }
            
            const last = leaders[leaders.length - 1];
            const first = leaders[0];
            const finals = curves.map(c => c[c.length - 1]);
            const sortedF = finals.map((t, i) => ({ i, t }))
                .sort((a, b) => isLowest ? a.t - b.t : b.t - a.t);
            const gap = sortedF.length > 1 ? Math.abs(sortedF[0].t - sortedF[1].t) : 0;
            
            let genre;
            if (changes >= 3) genre = "CHAOS";
            else if (first !== last) genre = "COMEBACK";
            else if (gap <= 100) genre = "THRILLER";
            else genre = "DOMINATION";
            
            // Stats joueurs - initialisation avec valeurs par d√©faut
            let bestRound = { player: 'N/A', score: 0 };
            let secondBestRound = { player: 'N/A', score: 0 };
            let worstRound = { player: 'N/A', score: 0 };
            
            if (history.length > 0) {
                // Initialiser avec la premi√®re manche
                const firstRound = history[0];
                players.forEach(p => {
                    const score = firstRound[p.id] || 0;
                    if (bestRound.player === 'N/A' || score > bestRound.score) {
                        bestRound = { player: p.name, score, round: 1 };
                    }
                });
                secondBestRound = { ...bestRound };
                worstRound = { ...bestRound };
                
                history.forEach((round, idx) => {
                    players.forEach(p => {
                        const score = round[p.id] || 0;
                        if (score > bestRound.score) {
                            secondBestRound = {...bestRound};
                            bestRound = { player: p.name, score, round: idx + 1 };
                        } else if (score > secondBestRound.score && score !== bestRound.score) {
                            secondBestRound = { player: p.name, score, round: idx + 1 };
                        }
                        if (score < worstRound.score) {
                            worstRound = { player: p.name, score, round: idx + 1 };
                        }
                    });
                });
            }
            
            // Streaks
            const streaks = new Map();
            players.forEach(p => streaks.set(p.id, { current: 0, max: 0 }));
            
            history.forEach(round => {
                const scores = players.map(p => ({ id: p.id, score: round[p.id] || 0 }));
                const winningScore = isLowest 
                    ? Math.min(...scores.map(s => s.score))
                    : Math.max(...scores.map(s => s.score));
                const winner = scores.find(s => s.score === winningScore);
                
                scores.forEach(({ id, score }) => {
                    const streak = streaks.get(id);
                    if (id === winner.id && (isLowest ? score >= 0 : score > 0)) {
                        streak.current++;
                        streak.max = Math.max(streak.max, streak.current);
                    } else {
                        streak.current = 0;
                    }
                });
            });
            
            let bestStreak = { player: null, count: 0 };
            streaks.forEach((streak, playerId) => {
                if (streak.max > bestStreak.count) {
                    const player = players.find(p => p.id === playerId);
                    bestStreak = { player: player?.name || 'N/A', count: streak.max };
                }
            });
            
            // Narratives - avec protection contre les cas vides
            const lastPlayerName = players[last]?.name || 'N/A';
            const firstName = players[first]?.name || 'N/A';
            const loserName = players[sortedF[sortedF.length-1]?.i]?.name || 'le perdant';
            
            // S√©lection d√©terministe bas√©e sur les donn√©es (pas de random pour coh√©rence GIF)
            const narrativeIndex = (history.length + players.length) % 2;
            
            const narrativeTemplates = {
                DOMINATION: [
                    `Une d√©monstration totale. ${loserName} n'avait aucune chance.`,
                    `Match √† sens unique. ${lastPlayerName} √©crase la concurrence.`
                ],
                THRILLER: [
                    `Suspense jusqu'au bout ! Un √©cart de seulement ${gap} points.`,
                    `Match serr√© ! Chaque point comptait.`
                ],
                CHAOS: [
                    `Partie folle avec ${changes} changements de leader !`,
                    `Un chaos total ! Impossible de pr√©dire le vainqueur.`
                ],
                COMEBACK: [
                    `Incroyable remont√©e de ${lastPlayerName} !`,
                    `Le retour du comeback kid ! ${firstName} pensait avoir gagn√©.`
                ]
            };
            
            const narrative = narrativeTemplates[genre][narrativeIndex];
            
            // Taux de victoire
            const winCounts = players.map(() => 0);
            history.forEach(round => {
                const scores = players.map(p => round[p.id] || 0);
                const winningScore = isLowest ? Math.min(...scores) : Math.max(...scores);
                players.forEach((p, i) => {
                    if ((round[p.id] || 0) === winningScore) winCounts[i]++;
                });
            });
            
            const precision = players.map((p, i) => ({
                name: p.name,
                value: history.length > 0 ? Math.round((winCounts[i] / history.length) * 100) : 0
            })).sort((a, b) => b.value - a.value);
            
            // Gestion du cas o√π il n'y a pas d'historique
            const winnerIndex = last !== undefined ? last : 0;
            const winnerTotal = finals[winnerIndex] !== undefined ? finals[winnerIndex] : 0;
            
            return {
                genre,
                winner: players[winnerIndex]?.name || 'N/A',
                winnerScore: winnerTotal,
                colors: this.GENRE_COLORS[genre],
                narrative,
                bestRound,
                secondBestRound,
                worstRound,
                bestStreak,
                finalGap: gap,
                precision,
                totalManches: history.length,
                sortedPlayers: sortedF.map(s => ({
                    name: players[s.i].name,
                    total: s.t,
                    rank: 0
                }))
            };
        },
        
        // === G√âN√âRATION PNG (STATIQUE) ===
        generateStatic(gameState) {
            try {
                const ai = this.analyzeGameData(gameState);
                const canvas = document.createElement('canvas');
                canvas.width = this.CONFIG.WIDTH;
                canvas.height = this.calculateHeight(ai);
                const ctx = canvas.getContext('2d');
                
                // Dessiner sans animation (time = 0)
                this.drawFrame(ctx, ai, 0, false);
                
                return canvas;
            } catch (error) {
                console.error('[UnifiedRecap] Erreur PNG:', error);
                return null;
            }
        },
        
        // === G√âN√âRATION GIF (ANIM√â) ===
        generateAnimated(gameState, progressCallback = null) {
            const updateProgress = (progress, message) => {
                if (progressCallback) progressCallback(progress, message);
            };
            
            try {
                if (typeof gifshot === 'undefined') {
                    UI.hideLoading();
                    throw new Error('Biblioth√®que gifshot non charg√©e');
                }
                
                // Initialiser les particules
                this.initParticles();
                
                updateProgress(5, 'Analyse des donn√©es...');
                const ai = this.analyzeGameData(gameState);
                
                const totalFrames = this.CONFIG.FPS * this.CONFIG.DURATION;
                updateProgress(10, `G√©n√©ration de ${totalFrames} frames...`);
                
                // Utiliser un seul canvas r√©utilisable pour r√©duire la m√©moire
                const reusableCanvas = document.createElement('canvas');
                reusableCanvas.width = this.CONFIG.WIDTH;
                reusableCanvas.height = this.calculateHeight(ai);
                const ctx = reusableCanvas.getContext('2d');
                
                const frames = [];
                for (let frame = 0; frame < totalFrames; frame++) {
                    // Effacer le canvas pour la nouvelle frame
                    ctx.clearRect(0, 0, reusableCanvas.width, reusableCanvas.height);
                    
                    const time = frame / totalFrames;
                    this.drawFrame(ctx, ai, time, true);
                    
                    // Convertir en dataURL
                    frames.push(reusableCanvas.toDataURL('image/png'));
                    
                    if (frame % 4 === 0) {
                        const percent = 10 + Math.round((frame / totalFrames) * 50);
                        updateProgress(percent, `Frame ${frame + 1}/${totalFrames}`);
                    }
                }
                
                // Lib√©rer le canvas imm√©diatement apr√®s g√©n√©ration des frames
                // Note: pas besoin de setter ctx = null, √ßa lancerait une erreur (const)
                reusableCanvas.width = 1;
                reusableCanvas.height = 1;
                
                updateProgress(60, 'Encodage du GIF...');
                
                gifshot.createGIF({
                    images: frames,
                    gifWidth: this.CONFIG.WIDTH,
                    gifHeight: this.calculateHeight(ai),
                    interval: 1 / this.CONFIG.FPS,
                    numFrames: totalFrames,
                    frameDuration: 1,
                    sampleInterval: 10,
                    progressCallback: (progress) => {
                        updateProgress(60 + Math.round(progress * 35), `Encodage: ${Math.round(progress * 100)}%`);
                    }
                }, (obj) => {
                    if (!obj.error) {
                        updateProgress(95, 'Finalisation...');
                        // Convertir data URL directement en Blob (plus fiable que fetch)
                        const dataUrl = obj.image;
                        const base64 = dataUrl.split(',')[1];
                        const binary = atob(base64);
                        const arr = new Uint8Array(binary.length);
                        for (let i = 0; i < binary.length; i++) arr[i] = binary.charCodeAt(i);
                        const blob = new Blob([arr], { type: 'image/gif' });
                        
                        this.downloadGif(blob);
                        updateProgress(100, 'Termin√© !');
                        // Nettoyer les particules apr√®s g√©n√©ration
                        this.particles = [];
                        setTimeout(() => {
                            UI.hideLoading();
                            UI.showToast('‚úÖ GIF t√©l√©charg√© !', 'success');
                        }, 300);
                    } else {
                        // Nettoyer en cas d'erreur aussi
                        this.particles = [];
                        UI.hideLoading();
                        UI.showToast('‚ùå Erreur: ' + obj.error, 'error');
                    }
                });
            } catch (error) {
                // Nettoyer en cas d'exception
                this.particles = [];
                UI.hideLoading();
                UI.showToast('‚ùå Erreur: ' + error.message, 'error');
            }
        },
        
        // === INITIALISATION PARTICULES ===
        initParticles() {
            this.particles = [];
            for (let i = 0; i < 25; i++) {
                this.particles.push({
                    x: Math.random() * this.CONFIG.WIDTH,
                    y: Math.random() * 1500,
                    size: Math.random() * 3 + 1,
                    speedX: (Math.random() - 0.5) * 0.6,
                    speedY: (Math.random() - 0.5) * 0.3,
                    opacity: Math.random() * 0.4 + 0.2,
                    phase: Math.random() * Math.PI * 2
                });
            }
        },
        
        // === CALCUL HAUTEUR DYNAMIQUE ===
        calculateHeight(ai) {
            // Banni√®re: 100 + 10
            let height = 110;
            
            // Classement: header(40) + podium + autres joueurs
            const playerCount = ai.sortedPlayers?.length || 2;
            height += 40; // header
            
            if (playerCount >= 3) {
                height += 185; // podium complet (155 base + 30 au-dessus)
                // Autres joueurs apr√®s le top 3
                const othersCount = Math.max(0, playerCount - 3);
                height += othersCount * 43; // 38 + 5 de gap
            } else {
                // Moins de 3 joueurs: affichage simple
                height += playerCount * 48;
            }
            height += 15; // marge
            
            // Temps forts: header(40) + offset(50) + 3*(70+8) + 15
            height += 339;
            // Stats: header(40) + offset(55) + card(175) + 10
            height += 280;
            // Watermark: 40
            height += 40;
            return height;
        },
        
        // === DESSIN D'UNE FRAME (UNIFI√â) ===
        drawFrame(ctx, ai, time, animated) {
            const w = this.CONFIG.WIDTH;
            const h = this.calculateHeight(ai);
            const p = this.CONFIG.PADDING;
            
            // === FOND ===
            this.drawBackground(ctx, w, h, time, animated);
            
            // === PARTICULES (si anim√©) ===
            if (animated) {
                this.drawParticles(ctx, time);
            }
            
            // === CONTENU PRINCIPAL ===
            let y = 0;
            
            // Banni√®re
            y = this.drawBanner(ctx, y, ai, time, animated);
            
            // Classement complet (NOUVEAU)
            y = this.drawRanking(ctx, y, ai, time, animated);
            
            // Temps forts
            y = this.drawHighlights(ctx, y, ai, time, animated);
            
            // Stats
            y = this.drawStats(ctx, y, ai, time, animated);
            
            // Watermark
            this.drawWatermark(ctx, w, h, time, animated);
        },
        
        // === FOND ===
        drawBackground(ctx, w, h, time, animated) {
            // D√©grad√© de base
            const grad = ctx.createLinearGradient(0, 0, 0, h);
            grad.addColorStop(0, '#FFFBF5');
            grad.addColorStop(0.5, '#FFF8F0');
            grad.addColorStop(1, '#FFF5EB');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, w, h);
            
            // Texture subtile d√©terministe (pas de random pour √©viter les variations entre frames)
            ctx.fillStyle = 'rgba(180, 150, 120, 0.015)';
            for (let i = 0; i < 800; i++) {
                // Utiliser un pattern d√©terministe bas√© sur l'index
                const px = (i * 17) % w;
                const py = (i * 23) % h;
                ctx.fillRect(px, py, 1, 1);
            }
            
            // Vague de lumi√®re (si anim√©)
            if (animated) {
                const waveX = (time * 200) % (w + 200) - 100;
                const waveGrad = ctx.createLinearGradient(waveX - 80, 0, waveX + 80, 0);
                waveGrad.addColorStop(0, 'rgba(255,255,255,0)');
                waveGrad.addColorStop(0.5, 'rgba(255,255,255,0.2)');
                waveGrad.addColorStop(1, 'rgba(255,255,255,0)');
                ctx.fillStyle = waveGrad;
                ctx.fillRect(0, 0, w, h);
            }
        },
        
        // === PARTICULES ===
        drawParticles(ctx, time) {
            const w = this.CONFIG.WIDTH;
            
            this.particles.forEach(p => {
                p.x += p.speedX;
                p.y += p.speedY;
                
                if (p.x < 0) p.x = w;
                if (p.x > w) p.x = 0;
                
                const pulse = 0.6 + Math.sin(time * 3 + p.phase) * 0.4;
                
                ctx.save();
                ctx.globalAlpha = p.opacity * pulse;
                
                // √âtoile dor√©e
                ctx.fillStyle = '#FFD700';
                ctx.font = `${p.size * 4}px Arial`;
                ctx.fillText('‚ú¶', p.x, p.y);
                
                ctx.restore();
            });
        },
        
        // === BANNI√àRE ===
        drawBanner(ctx, startY, ai, time, animated) {
            const w = this.CONFIG.WIDTH;
            const h = 100;
            const colors = ai.colors;
            
            // Fond avec d√©grad√©
            const grad = ctx.createLinearGradient(0, startY, 0, startY + h);
            grad.addColorStop(0, colors.gradient[0]);
            grad.addColorStop(1, colors.gradient[1]);
            ctx.fillStyle = grad;
            ctx.fillRect(0, startY, w, h);
            
            // Bordure anim√©e (si anim√©)
            if (animated) {
                ctx.strokeStyle = 'rgba(255,255,255,0.5)';
                ctx.lineWidth = 3;
                ctx.setLineDash([20, 10]);
                ctx.lineDashOffset = -time * 60;
                ctx.strokeRect(2, startY + 2, w - 4, h - 4);
                ctx.setLineDash([]);
            }
            
            // Particules dor√©es dans la banni√®re
            ctx.fillStyle = 'rgba(255, 215, 0, 0.5)';
            for (let i = 0; i < 10; i++) {
                const px = (w / 10) * i + (animated ? Math.sin(time * 4 + i) * 12 : 0);
                const py = startY + 30 + (animated ? Math.cos(time * 3 + i) * 8 : 0);
                const size = 2 + (animated ? Math.sin(time * 5 + i) : 1);
                ctx.beginPath();
                ctx.arc(px, py, size, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Titre
            ctx.shadowBlur = 20;
            ctx.shadowColor = 'rgba(0,0,0,0.3)';
            ctx.font = 'italic 900 52px Georgia';
            ctx.fillStyle = '#FFFFFF';
            ctx.textAlign = 'center';
            ctx.fillText('SCORE MASTER', w / 2, startY + 60);
            
            ctx.shadowBlur = 0;
            ctx.strokeStyle = 'rgba(255,255,255,0.3)';
            ctx.lineWidth = 2;
            ctx.strokeText('SCORE MASTER', w / 2, startY + 60);
            
            // Badge genre
            const badgeX = w - 60;
            const badgeY = startY + 85;
            ctx.font = 'bold 11px Arial';
            ctx.fillStyle = 'rgba(255,255,255,0.9)';
            ctx.fillText(ai.genre, badgeX, badgeY);
            
            return startY + h + 10;
        },
        
        // === CLASSEMENT COMPLET AVEC PODIUM ===
        drawRanking(ctx, startY, ai, time, animated) {
            const w = this.CONFIG.WIDTH;
            const p = this.CONFIG.PADDING;
            const colors = ai.colors;
            const players = ai.sortedPlayers || [];
            
            // Header "CLASSEMENT"
            ctx.fillStyle = colors.gradient[0];
            this.roundRect(ctx, p, startY, w - p*2, 40, 12);
            ctx.fill();
            
            ctx.font = 'bold 18px Arial';
            ctx.fillStyle = '#FFFFFF';
            ctx.textAlign = 'center';
            ctx.fillText('üèÜ CLASSEMENT üèÜ', w/2, startY + 26);
            
            const contentY = startY + 50;
            const cardW = w - p*2;
            
            // === PODIUM pour le TOP 3 ===
            const top3 = players.slice(0, 3);
            const hasPodium = top3.length >= 3;
            
            if (hasPodium) {
                // Ordre d'affichage: 2√®me (gauche), 1er (centre), 3√®me (droite)
                const order = [1, 0, 2]; // indices: 2√®me, 1er, 3√®me
                const podiumHeights = [60, 85, 40]; // hauteurs des barres
                const podiumColors = [
                    ['#C0C0C0', '#A8A8A8'], // Argent
                    ['#FFD700', '#FFA500'], // Or
                    ['#CD7F32', '#8B4513']  // Bronze
                ];
                const rankEmojis = ['ü•à', 'ü•á', 'ü•â'];
                
                const podiumWidth = 95;
                const gap = 10;
                const totalPodiumW = podiumWidth * 3 + gap * 2;
                const podiumStartX = p + (cardW - totalPodiumW) / 2;
                const podiumBaseY = contentY + 155; // Base du podium
                
                order.forEach((playerIdx, displayIdx) => {
                    const player = top3[playerIdx];
                    if (!player) return;
                    
                    const barH = podiumHeights[displayIdx];
                    const x = podiumStartX + displayIdx * (podiumWidth + gap);
                    const centerX = x + podiumWidth / 2;
                    
                    // Flottement (si anim√©)
                    const floatY = animated ? Math.sin(time * 2 + displayIdx) * 2 : 0;
                    
                    // === BARRE DU PODIUM (en bas) ===
                    const barY = podiumBaseY - barH + floatY;
                    const barGrad = ctx.createLinearGradient(x, barY, x, podiumBaseY);
                    barGrad.addColorStop(0, podiumColors[displayIdx][0]);
                    barGrad.addColorStop(1, podiumColors[displayIdx][1]);
                    
                    ctx.shadowBlur = 8;
                    ctx.shadowColor = 'rgba(0,0,0,0.2)';
                    ctx.shadowOffsetY = -3;
                    ctx.fillStyle = barGrad;
                    this.roundRect(ctx, x, barY, podiumWidth, barH, [10, 10, 0, 0]);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                    ctx.shadowOffsetY = 0;
                    
                    // M√©daille sur la barre
                    ctx.font = '22px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(rankEmojis[displayIdx], centerX, barY + 25);
                    
                    // === SECTION AU-DESSUS DE LA BARRE ===
                    const aboveBarY = barY + floatY;
                    
                    // SCORE (juste au-dessus de la barre)
                    ctx.font = 'bold 16px Arial';
                    ctx.fillStyle = '#1a1a1a';
                    ctx.textAlign = 'center';
                    ctx.fillText(`${player.total} pts`, centerX, aboveBarY - 8);
                    
                    // NOM (au-dessus du score)
                    ctx.font = 'bold 13px Arial';
                    ctx.fillStyle = '#333';
                    const name = player.name.toUpperCase();
                    // Tronquer si trop long
                    const maxNameW = podiumWidth - 10;
                    let displayName = name;
                    while (ctx.measureText(displayName).width > maxNameW && displayName.length > 2) {
                        displayName = displayName.slice(0, -1);
                    }
                    ctx.fillText(displayName, centerX, aboveBarY - 28);
                    
                    // AVATAR (cercle avec initiale)
                    const avatarR = displayIdx === 1 ? 22 : 18; // Plus grand pour le 1er
                    const avatarY = aboveBarY - 58;
                    
                    const avatarGrad = ctx.createRadialGradient(centerX, avatarY, 0, centerX, avatarY, avatarR);
                    avatarGrad.addColorStop(0, podiumColors[displayIdx][0]);
                    avatarGrad.addColorStop(1, podiumColors[displayIdx][1]);
                    
                    ctx.shadowBlur = 6;
                    ctx.shadowColor = 'rgba(0,0,0,0.25)';
                    ctx.fillStyle = avatarGrad;
                    ctx.beginPath();
                    ctx.arc(centerX, avatarY, avatarR, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                    
                    // Initiale dans l'avatar
                    ctx.font = `bold ${avatarR}px Arial`;
                    ctx.fillStyle = displayIdx === 1 ? '#1a1a1a' : '#FFFFFF';
                    ctx.fillText(player.name.charAt(0), centerX, avatarY + avatarR * 0.35);
                    
                    // Couronne pour le 1er
                    if (displayIdx === 1) {
                        ctx.font = '18px Arial';
                        ctx.fillText('üëë', centerX, avatarY - avatarR - 5);
                    }
                });
            }
            
            // === Liste des autres joueurs (si plus de 3) ===
            const others = players.slice(3);
            if (others.length > 0) {
                const listY = contentY + (hasPodium ? 170 : 0);
                const itemH = 38;
                
                others.forEach((player, i) => {
                    const itemY = listY + i * (itemH + 5);
                    
                    // Ombre
                    ctx.shadowBlur = 5;
                    ctx.shadowColor = 'rgba(0,0,0,0.1)';
                    ctx.shadowOffsetY = 2;
                    
                    // Fond carte
                    ctx.fillStyle = '#FFFFFF';
                    this.roundRect(ctx, p, itemY, cardW, itemH, 10);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                    ctx.shadowOffsetY = 0;
                    
                    // Barre color√©e gauche
                    ctx.fillStyle = colors.primary;
                    this.roundRect(ctx, p, itemY, 5, itemH, [10, 0, 0, 10]);
                    ctx.fill();
                    
                    // Rang
                    ctx.font = 'bold 18px Arial';
                    ctx.fillStyle = '#888';
                    ctx.textAlign = 'center';
                    ctx.fillText(`${i + 4}`, p + 28, itemY + 25);
                    
                    // Nom
                    ctx.font = 'bold 16px Arial';
                    ctx.fillStyle = '#333';
                    ctx.fillText(player.name.toUpperCase(), w/2, itemY + 25);
                    
                    // Score
                    ctx.font = 'bold 17px Arial';
                    ctx.fillStyle = colors.primary;
                    ctx.textAlign = 'right';
                    ctx.fillText(`${player.total} pts`, p + cardW - 15, itemY + 25);
                });
                
                ctx.textAlign = 'left';
                return listY + others.length * (itemH + 5) + 15;
            }
            
            ctx.textAlign = 'left';
            return contentY + (hasPodium ? 185 : 15);
        },
        
        // === TEMPS FORTS ===
        drawHighlights(ctx, startY, ai, time, animated) {
            const w = this.CONFIG.WIDTH;
            const p = this.CONFIG.PADDING;
            
            // Header avec coins arrondis
            ctx.fillStyle = ai.colors.gradient[0];
            this.roundRect(ctx, p, startY, w - p*2, 40, 12);
            ctx.fill();
            
            ctx.font = 'bold 18px Arial';
            ctx.fillStyle = '#FFFFFF';
            ctx.textAlign = 'center';
            ctx.fillText('‚≠ê TEMPS FORTS ‚≠ê', w/2, startY + 26);
            
            const items = [
                { icon: 'üî•', label: 'MEILLEURE MANCHE', value: `${ai.bestRound.player}`, sub: `${ai.bestRound.score} pts`, color: '#EF4444' },
                { icon: 'üéØ', label: 'EXPLOIT', value: `${ai.secondBestRound.player || 'N/A'}`, sub: `${ai.secondBestRound.score || 0} pts`, color: '#3B82F6' },
                { icon: '‚ö°', label: 'S√âRIE', value: ai.bestStreak.count > 1 ? ai.bestStreak.player : `${ai.totalManches} manches`, sub: ai.bestStreak.count > 1 ? `${ai.bestStreak.count} victoires` : 'Match √©quilibr√©', color: '#F59E0B' }
            ];
            
            const itemH = 70;
            const contentY = startY + 50;
            const cardW = w - p*2;
            const barW = 6; // Largeur de la barre color√©e
            
            items.forEach((item, i) => {
                const itemY = contentY + i * (itemH + 8);
                const cardX = p;
                
                // Flottement (si anim√©)
                const floatY = animated ? Math.sin(time * 2 + i) * 2 : 0;
                
                // Ombre de la carte
                ctx.shadowBlur = 10;
                ctx.shadowColor = 'rgba(0,0,0,0.1)';
                ctx.shadowOffsetY = 4;
                
                // Carte blanche
                ctx.fillStyle = '#FFFFFF';
                this.roundRect(ctx, cardX, itemY + floatY, cardW, itemH, 12);
                ctx.fill();
                ctx.shadowBlur = 0;
                ctx.shadowOffsetY = 0;
                
                // Barre color√©e √† gauche (pulsante si anim√©)
                const borderAlpha = animated ? 0.7 + Math.sin(time * 4 + i) * 0.3 : 1;
                ctx.globalAlpha = borderAlpha;
                ctx.fillStyle = item.color;
                this.roundRect(ctx, cardX, itemY + floatY, barW, itemH, [12, 0, 0, 12]);
                ctx.fill();
                ctx.globalAlpha = 1;
                
                // === CONTENU CENTR√â ===
                // Zone disponible pour le contenu (apr√®s la barre)
                const contentAreaX = cardX + barW + 15;
                const contentAreaW = cardW - barW - 30;
                const centerX = contentAreaX + contentAreaW / 2;
                const baseY = itemY + floatY;
                
                ctx.textAlign = 'center';
                
                // Ic√¥ne centr√©e en haut
                ctx.font = '24px Arial';
                ctx.fillText(item.icon, centerX, baseY + 22);
                
                // Label centr√© sous l'ic√¥ne
                ctx.font = 'bold 10px Arial';
                ctx.fillStyle = item.color;
                ctx.fillText(item.label, centerX, baseY + 38);
                
                // Valeur (nom du joueur) centr√©e
                ctx.font = 'bold 16px Arial';
                ctx.fillStyle = '#1a1a1a';
                ctx.fillText(item.value, centerX, baseY + 54);
                
                // Sub (score) centr√©
                ctx.font = 'bold 13px Arial';
                ctx.fillStyle = item.color;
                ctx.fillText(item.sub, centerX, baseY + 68);
            });
            
            ctx.textAlign = 'left';
            return contentY + items.length * (itemH + 8) + 15;
        },
        
        // === STATS ===
        drawStats(ctx, startY, ai, time, animated) {
            const w = this.CONFIG.WIDTH;
            const p = this.CONFIG.PADDING;
            const colors = ai.colors;
            
            // Header
            ctx.fillStyle = colors.gradient[0];
            this.roundRect(ctx, p, startY, w - p*2, 40, 12);
            ctx.fill();
            
            ctx.font = 'bold 18px Arial';
            ctx.fillStyle = '#FFFFFF';
            ctx.textAlign = 'center';
            ctx.fillText('üìä STATISTIQUES üìä', w/2, startY + 26);
            
            const contentY = startY + 55;
            const cardW = w - p*2;
            
            // Carte blanche pour les stats
            ctx.shadowBlur = 8;
            ctx.shadowColor = 'rgba(0,0,0,0.08)';
            ctx.fillStyle = '#FFFFFF';
            this.roundRect(ctx, p, contentY, cardW, 160, 12);
            ctx.fill();
            ctx.shadowBlur = 0;
            
            // Taux victoire avec barre
            if (ai.precision && ai.precision.length > 0) {
                const top = ai.precision[0];
                const topValue = Math.max(0, Math.min(100, top?.value || 0));
                
                ctx.font = 'bold 14px Arial';
                ctx.fillStyle = '#333';
                ctx.textAlign = 'center';
                ctx.fillText(`üéØ Taux victoire: ${top?.name || 'N/A'}`, w/2, contentY + 25);
                
                // Barre
                const barW = cardW - 30;
                const barH = 24;
                const barX = p + 15;
                const barY = contentY + 35;
                
                // Fond barre
                ctx.fillStyle = '#E5E7EB';
                this.roundRect(ctx, barX, barY, barW, barH, 8);
                ctx.fill();
                
                // Barre remplie (avec protection minimum de 1px)
                const fillW = Math.max(1, barW * (topValue / 100));
                const barGrad = ctx.createLinearGradient(barX, barY, barX + fillW, barY);
                barGrad.addColorStop(0, '#22C55E');
                barGrad.addColorStop(1, '#16A34A');
                ctx.fillStyle = barGrad;
                this.roundRect(ctx, barX, barY, fillW, barH, 8);
                ctx.fill();
                
                // Effet brillance (si anim√©)
                if (animated) {
                    const shineX = (time * 150) % barW;
                    const shineGrad = ctx.createLinearGradient(barX + shineX - 30, barY, barX + shineX + 30, barY);
                    shineGrad.addColorStop(0, 'rgba(255,255,255,0)');
                    shineGrad.addColorStop(0.5, 'rgba(255,255,255,0.4)');
                    shineGrad.addColorStop(1, 'rgba(255,255,255,0)');
                    ctx.fillStyle = shineGrad;
                    ctx.fillRect(barX, barY, fillW, barH);
                }
                
                // Valeur centr√©e
                ctx.font = 'bold 14px Arial';
                ctx.fillStyle = '#FFFFFF';
                ctx.textAlign = 'center';
                ctx.fillText(`${topValue}%`, w/2, barY + 17);
            }
            
            // Grille de stats en 2 colonnes centr√©es
            const statsY = contentY + 80;
            const col1X = w/2 - 80;
            const col2X = w/2 + 40;
            
            ctx.font = '14px Arial';
            ctx.fillStyle = '#444';
            ctx.textAlign = 'center';
            
            // Colonne 1
            ctx.fillText('üî• Meilleure', col1X, statsY);
            ctx.font = 'bold 15px Arial';
            ctx.fillStyle = '#1a1a1a';
            ctx.fillText(ai.bestRound.player, col1X, statsY + 20);
            
            // Colonne 2
            ctx.font = '14px Arial';
            ctx.fillStyle = '#444';
            ctx.fillText('üéØ √âcart', col2X, statsY);
            ctx.font = 'bold 15px Arial';
            ctx.fillStyle = '#1a1a1a';
            ctx.fillText(`${ai.finalGap} pts`, col2X, statsY + 20);
            
            // Ligne du bas - manches
            ctx.font = '14px Arial';
            ctx.fillStyle = '#444';
            ctx.fillText(`üìà ${ai.totalManches} manches jou√©es`, w/2, statsY + 55);
            
            // Narrative en bas (phrase d'ambiance)
            if (ai.narrative) {
                ctx.font = 'italic 12px Georgia';
                ctx.fillStyle = colors.primary;
                ctx.textAlign = 'center';
                // Tronquer si trop long
                const maxW = cardW - 30;
                let text = ai.narrative;
                if (ctx.measureText(text).width > maxW) {
                    while (ctx.measureText(text + '...').width > maxW && text.length > 10) {
                        text = text.slice(0, -1);
                    }
                    text += '...';
                }
                ctx.fillText(`"${text}"`, w/2, statsY + 80);
            }
            
            ctx.textAlign = 'left';
            return contentY + 175;
        },
        
        // === WATERMARK ===
        drawWatermark(ctx, w, h, time, animated) {
            const bobY = animated ? Math.sin(time * 1.5) * 2 : 0;
            const bobR = animated ? Math.sin(time * 0.8) * 0.02 : 0;
            
            ctx.save();
            ctx.translate(w/2, h - 30 + bobY);
            ctx.rotate(bobR);
            
            // Fond badge
            ctx.shadowBlur = 8;
            ctx.shadowColor = 'rgba(0,0,0,0.2)';
            ctx.fillStyle = 'rgba(30, 30, 46, 0.85)';
            this.roundRect(ctx, -50, -10, 100, 20, 6);
            ctx.fill();
            ctx.shadowBlur = 0;
            
            // Bordure
            const borderGlow = animated ? 0.5 + Math.sin(time * 2.5) * 0.3 : 0.8;
            ctx.strokeStyle = `rgba(255, 215, 0, ${borderGlow})`;
            ctx.lineWidth = 1;
            this.roundRect(ctx, -50, -10, 100, 20, 6);
            ctx.stroke();
            
            // Texte
            ctx.font = 'bold 11px Arial';
            ctx.fillStyle = '#FFD700';
            ctx.textAlign = 'center';
            ctx.fillText('ScoreMaster‚Ñ¢', 0, 4);
            
            ctx.restore();
        },
        
        // === UTILITAIRES ===
        roundRect(ctx, x, y, w, h, r) {
            if (typeof r === 'number') {
                r = [r, r, r, r];
            }
            ctx.beginPath();
            ctx.moveTo(x + r[0], y);
            ctx.lineTo(x + w - r[1], y);
            ctx.quadraticCurveTo(x + w, y, x + w, y + r[1]);
            ctx.lineTo(x + w, y + h - r[2]);
            ctx.quadraticCurveTo(x + w, y + h, x + w - r[2], y + h);
            ctx.lineTo(x + r[3], y + h);
            ctx.quadraticCurveTo(x, y + h, x, y + h - r[3]);
            ctx.lineTo(x, y + r[0]);
            ctx.quadraticCurveTo(x, y, x + r[0], y);
            ctx.closePath();
        },
        
        async downloadImage(canvas, filename = 'ScoreMaster.png') {
            const blob = await this.canvasToBlobAsync(canvas);
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
        },
        
        // Version synchrone (pour compatibilit√©, mais moins performante)
        canvasToBlob(canvas) {
            const data = canvas.toDataURL('image/png');
            const bytes = atob(data.split(',')[1]);
            const arr = new Uint8Array(bytes.length);
            for (let i = 0; i < bytes.length; i++) arr[i] = bytes.charCodeAt(i);
            return new Blob([arr], { type: 'image/png' });
        },
        
        // Version asynchrone (recommand√©e, ne bloque pas l'UI)
        canvasToBlobAsync(canvas) {
            return new Promise((resolve) => {
                canvas.toBlob((blob) => {
                    resolve(blob);
                }, 'image/png');
            });
        },
        
        async shareImage(canvas) {
            try {
                const blob = await this.canvasToBlobAsync(canvas);
                const file = new File([blob], 'ScoreMaster.png', { type: 'image/png' });
                
                if (navigator.share && navigator.canShare) {
                    await navigator.share({ files: [file], title: 'ScoreMaster' });
                    return true;
                }
            } catch (e) {
                if (e.name !== 'AbortError') console.warn('Partage annul√©');
            }
            return false;
        },
        
        downloadGif(blob) {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `ScoreMaster_${Date.now()}.gif`;
            a.click();
            URL.revokeObjectURL(url);
        }
    };

    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => {
            app.init();
            PWA.init();
        });
    } else {
        app.init();
        PWA.init();
    }
</script>
</body>
</html>
