<!DOCTYPE html>

<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="theme-color" content="#007AFF" media="(prefers-color-scheme: light)">
    <meta name="theme-color" content="#0A84FF" media="(prefers-color-scheme: dark)">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="ScoreMaster">
    <meta name="description" content="Gestionnaire de scores pour belote, coinche et jeux de cartes avec statistiques avanc√©es">
    <meta name="keywords" content="belote, coinche, score, cartes, jeu, statistiques">

<!-- PWA Manifest -->
<link rel="manifest" href="manifest.json">

<!-- Apple Touch Icons -->
<link rel="apple-touch-icon" href="icon-180.png">
<link rel="apple-touch-icon" sizes="180x180" href="icon-180.png">
<link rel="apple-touch-icon" sizes="192x192" href="icon-192.png">
<link rel="apple-touch-icon" sizes="512x512" href="icon-512.png">

<!-- Favicon -->
<link rel="icon" type="image/png" sizes="192x192" href="icon-192.png">
<link rel="icon" type="image/png" sizes="512x512" href="icon-512.png">

<title>ScoreMaster</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/gifshot@0.4.5/dist/gifshot.min.js"></script>
<style>
    /* --- VARIABLES & THEME --- */
    :root {
        --primary: #007AFF; --bg: #F5F5F7; --card: #FFFFFF; --text: #1D1D1F;
        --text-sec: #86868B; --border: #E5E5EA; --dealer: #FF9500; 
        --danger: #FF3B30; --success: #34C759; 
        
        /* Glassmorphism Vars */
        --glass-bg: rgba(255, 255, 255, 0.65);
        --glass-border: rgba(255, 255, 255, 0.5);
        --glass-shadow: 0 15px 35px rgba(0,0,0,0.1), 0 5px 15px rgba(0,0,0,0.05);
        --glass-blur: 20px;
        
        /* Gradients */
        --bg-gradient: radial-gradient(circle at 50% 0%, #ffffff, #F5F5F7);
    }
    :root[data-theme="dark"] {
        --primary: #0A84FF; --bg: #000000; --card: #1C1C1E; --text: #F5F5F7;
        --text-sec: #98989D; --border: #38383A; 
        
        --glass-bg: rgba(28, 28, 30, 0.65);
        --glass-border: rgba(255, 255, 255, 0.1);
        --glass-shadow: 0 15px 35px rgba(0,0,0,0.4), 0 5px 15px rgba(0,0,0,0.2);
        
        --bg-gradient: radial-gradient(circle at 50% 0%, #2c2c2e, #000000);
    }
    @media (prefers-color-scheme: dark) {
        :root:not([data-theme="light"]) {
            --primary: #0A84FF; --bg: #000000; --card: #1C1C1E; --text: #F5F5F7;
            --text-sec: #98989D; --border: #38383A; 
            --glass-bg: rgba(28, 28, 30, 0.65);
            --glass-border: rgba(255, 255, 255, 0.1);
            --glass-shadow: 0 15px 35px rgba(0,0,0,0.4), 0 5px 15px rgba(0,0,0,0.2);
            --bg-gradient: radial-gradient(circle at 50% 0%, #2c2c2e, #000000);
        }
    }
    * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-family: -apple-system, system-ui, sans-serif; }
    
    html {
        height: -webkit-fill-available;
    }
    
    body { 
        margin: 0; 
        background: var(--bg);
        background-attachment: fixed;
        color: var(--text); 
        padding-bottom: 140px; 
        transition: background 0.3s;
        min-height: 100vh;
        min-height: -webkit-fill-available;
    }
    
    body::before {
        content: '';
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: var(--bg-gradient);
        z-index: -1;
    }
    
    .container { 
        max-width: 600px; 
        margin: 0 auto; 
        padding: 20px; 
        padding-top: max(20px, env(safe-area-inset-top)); 
        animation: slideIn 0.4s ease-out; 
        position: relative; 
        z-index: 1; 
    }
    .hidden { display: none !important; }
    
    /* Typography Helpers */
    .text-huge { font-size: 28px; font-weight: 900; }
    .text-center { text-align: center; }

    /* --- ANIMATIONS --- */
    @keyframes slideIn { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }
    @keyframes rankPop { 0% { transform: scale(1); } 50% { transform: scale(1.1); } 100% { transform: scale(1); } }
    @keyframes badgeBounce { 0%, 100% { transform: scale(1) rotate(0deg); } 25% { transform: scale(1.3) rotate(-10deg); } 75% { transform: scale(1.3) rotate(10deg); } }
    @keyframes scoreBump { 0% { transform: scale(1); } 50% { transform: scale(1.15); } 100% { transform: scale(1); } }
    @keyframes victoryPop { 0% { transform: scale(0.8); opacity: 0; } 100% { transform: scale(1); opacity: 1; } }
    
    /* === NOUVELLES ANIMATIONS AM√âLIOR√âES === */
    @keyframes zenFadeIn {
        0% { opacity: 0; transform: scale(0.95); }
        100% { opacity: 1; transform: scale(1); }
    }
    @keyframes zenFadeOut {
        0% { opacity: 1; transform: scale(1); }
        100% { opacity: 0; transform: scale(0.95); }
    }
    @keyframes podiumEntrance {
        0% { transform: translateY(150px) scale(0.5); opacity: 0; }
        60% { transform: translateY(-20px) scale(1.1); opacity: 1; }
        80% { transform: translateY(10px) scale(0.95); }
        100% { transform: translateY(0) scale(1); opacity: 1; }
    }
    @keyframes crownFloat {
        0%, 100% { transform: translateY(0) rotate(0deg); }
        25% { transform: translateY(-8px) rotate(-5deg); }
        75% { transform: translateY(-8px) rotate(5deg); }
    }
    @keyframes podiumGlow {
        0%, 100% { box-shadow: 0 0 20px rgba(255, 215, 0, 0.3); }
        50% { box-shadow: 0 0 40px rgba(255, 215, 0, 0.6), 0 0 60px rgba(255, 215, 0, 0.3); }
    }
    @keyframes spinPulse {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }
    
    /* === INDICATEUR DE CHARGEMENT === */
    .loading-overlay {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.7);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        z-index: 10000;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.3s ease;
    }
    .loading-overlay.active {
        opacity: 1;
        pointer-events: auto;
    }
    .loading-spinner {
        width: 60px;
        height: 60px;
        border: 4px solid var(--glass-border);
        border-top-color: var(--primary);
        border-radius: 50%;
        animation: spinPulse 1s linear infinite;
    }
    .loading-text {
        margin-top: 20px;
        font-size: 16px;
        font-weight: 700;
        color: white;
        text-align: center;
    }
    .loading-progress {
        margin-top: 10px;
        font-size: 24px;
        font-weight: 900;
        color: var(--primary);
    }

    /* --- GLASSMORPHISM COMPONENTS --- */
    .modal-overlay { 
        position: fixed; inset: 0; 
        background: rgba(0,0,0,0.1); 
        backdrop-filter: blur(8px); 
        -webkit-backdrop-filter: blur(8px);
        z-index: 4000; 
        display: flex; 
        align-items: center; 
        justify-content: center; 
        padding: 20px; 
        opacity: 0; 
        pointer-events: none; 
        transition: 0.2s; 
    }
    .modal-overlay.active { opacity: 1; pointer-events: auto; }
    
    .modal-box, .sheet-content, .victory-box { 
        background: var(--glass-bg);
        backdrop-filter: blur(var(--glass-blur)) saturate(180%);
        -webkit-backdrop-filter: blur(var(--glass-blur)) saturate(180%);
        border: 1px solid var(--glass-border);
        box-shadow: var(--glass-shadow);
    }

    .modal-box { 
        width: 100%; max-width: 340px; border-radius: 28px; padding: 25px; text-align: center; 
    }
    .modal-box.large { max-width: 500px; text-align: left; max-height: 80vh; overflow-y: auto; }
    
    /* Suggestions de joueurs r√©cents */
    .modal-player-wrapper { 
        position: relative; 
        display: flex;
        flex-direction: column;
        align-items: center;
    }
    .recent-suggestions {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 8px;
        margin-top: 16px;
        padding: 12px;
        background: var(--glass-bg);
        backdrop-filter: blur(10px);
        border-radius: 16px;
        border: 1px solid var(--glass-border);
    }
    .recent-suggestion-item {
        display: flex;
        align-items: center;
        gap: 8px;
        background: var(--card);
        border: 1px solid var(--border);
        border-radius: 12px;
        padding: 10px 14px;
        font-size: 13px;
        font-weight: 700;
        color: var(--text);
        cursor: pointer;
        white-space: nowrap;
        transition: all 0.2s ease;
    }
    .recent-suggestion-item:active {
        background: var(--primary);
        color: white;
        border-color: var(--primary);
        transform: scale(0.95);
    }
    .recent-suggestion-item .add-icon {
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: var(--success);
        color: white;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 14px;
        font-weight: 900;
        flex-shrink: 0;
    }
    .recent-suggestion-item:active .add-icon {
        background: white;
        color: var(--primary);
    }
    .recent-suggestions-title {
        width: 100%;
        text-align: center;
        font-size: 11px;
        font-weight: 800;
        color: var(--text-sec);
        text-transform: uppercase;
        letter-spacing: 0.5px;
        margin-bottom: 8px;
    }
    
    /* Sur grand √©cran : afficher √† droite */
    @media (min-width: 700px) {
        .modal-player-wrapper {
            flex-direction: row;
            align-items: flex-start;
        }
        .recent-suggestions {
            position: absolute;
            left: calc(50% + 180px);
            top: 0;
            margin-top: 0;
            flex-direction: column;
            flex-wrap: nowrap;
            justify-content: flex-start;
        }
        .recent-suggestion-item:hover {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
            transform: translateX(-4px);
            box-shadow: 0 6px 20px rgba(0,122,255,0.3);
        }
        .recent-suggestion-item:hover .add-icon {
            background: white;
            color: var(--primary);
        }
    }
    .sheet-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.2); z-index: 3000; opacity: 0; pointer-events: none; transition: 0.3s; display: flex; align-items: flex-end; }
    .sheet-overlay.active { opacity: 1; pointer-events: auto; }
    .sheet-content { 
        width: 100%; border-radius: 35px 35px 0 0; padding: 25px 20px calc(25px + env(safe-area-inset-bottom)); 
        transform: translateY(100%); transition: 0.4s cubic-bezier(0.1, 0.9, 0.2, 1);
    }
    .sheet-overlay.active .sheet-content { transform: translateY(0); }

    /* --- UI ELEMENTS --- */
    .header-controls { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; }
    .theme-toggle, .btn-stats, .btn-focus { 
        background: var(--glass-bg);
        backdrop-filter: blur(10px);
        border: 1px solid var(--glass-border); 
        width: 44px; height: 44px; border-radius: 12px; font-size: 20px; cursor: pointer; transition: all 0.3s; display:flex; align-items:center; justify-content:center; box-shadow: 0 4px 10px rgba(0,0,0,0.05);
    }
    .btn-stats:active, .theme-toggle:active, .btn-focus:active { transform: scale(0.9); }
    .btn-stats { color:var(--primary); }
    .btn-focus { color: var(--primary); }

    .welcome-title { font-size: 42px; font-weight: 900; text-align: center; margin-top: 40px; letter-spacing: -2px; background: linear-gradient(120deg, var(--text), var(--primary)); -webkit-background-clip: text; -webkit-text-fill-color: transparent;}

    .mode-btn { background: var(--card); border: 1px solid var(--border); border-radius: 24px; padding: 20px; margin-bottom: 12px; box-shadow: 0 4px 15px rgba(0,0,0,0.05); cursor: pointer; display: flex; align-items: center; gap: 15px; transition: all 0.2s; }
    .mode-btn:hover { transform: translateY(-2px); box-shadow: 0 10px 25px rgba(0,0,0,0.1); }
    .mode-btn:active { transform: translateY(0); }

    .guide-container { margin-top: 30px; background: var(--card); border-radius: 24px; padding: 20px; border: 1px solid var(--border); font-size: 13px; color: var(--text-sec); }

    .game-item { background: var(--card); border: 1px solid var(--border); border-radius: 20px; padding: 16px; margin-bottom: 12px; cursor: pointer; display: flex; justify-content: space-between; align-items: center; transition: all 0.2s; }
    .game-item:hover { border-color: var(--primary); transform: translateX(4px); box-shadow: 0 5px 15px rgba(0,0,0,0.05); }
    .game-mode-badge { display: inline-block; padding: 3px 8px; border-radius: 8px; font-size: 10px; font-weight: 900; margin-left: 8px; }
    .badge-belote { background: #FF9500; color: white; }
    .badge-standard { background: #007AFF; color: white; }
    .game-players-list { display: flex; gap: 8px; margin-top: 8px; flex-wrap: wrap; }
    .game-player-score { font-size: 11px; padding: 4px 8px; border-radius: 8px; font-weight: 700; }
    .game-actions { display: flex; gap: 8px; }
    .game-actions button { background: none; border: none; font-size: 18px; padding: 8px; cursor: pointer; transition: transform 0.2s; }
    .game-actions button:active { transform: scale(0.9); }

    .chart-box { background: var(--glass-bg); backdrop-filter: blur(10px); border-radius: 24px; padding: 15px; height: 200px; margin-bottom: 25px; border: 1px solid var(--border); box-shadow: 0 5px 15px rgba(0,0,0,0.05); transition: opacity 0.5s ease; }
    
    .players-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(130px, 1fr)); gap: 14px; margin-bottom: 30px; transition: all 0.5s cubic-bezier(0.34, 1.56, 0.64, 1); }
    
    .p-card { background: var(--card); padding: 22px 10px; border-radius: 26px; text-align: center; position: relative; border: 3px solid transparent; box-shadow: 0 8px 20px rgba(0,0,0,0.05); transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1), border-color 0.3s; overflow: visible; }
    .p-card.is-dealer { border-color: var(--dealer); }
    .p-card.rank-change { animation: rankPop 0.6s cubic-bezier(0.34, 1.56, 0.64, 1); }
    
    .rank-badge { position: absolute; top: -12px; left: 12px; font-size: 13px; padding: 4px 10px; border-radius: 12px; font-weight: 900; color: white; box-shadow: 0 4px 8px rgba(0,0,0,0.2); transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1); z-index: 10; }
    .rank-badge.bounce { animation: badgeBounce 0.6s cubic-bezier(0.34, 1.56, 0.64, 1); }

    /* Afficher les badges en mode Zen avec style adapt√© */
    .focus-mode .rank-badge {
        top: 8px;
        left: 8px;
        font-size: 16px;
        padding: 4px 8px;
    }

    /* Ajuster les cartes en mode Zen pour que le nom soit visible et le score temp pas coup√© */
    .focus-mode .p-card {
        padding: 12px 8px 22px 8px;
        overflow: visible;
    }
    
    .focus-mode .p-name-btn {
        font-size: 11px;
        margin-bottom: 6px;
        margin-top: 24px;
        padding: 3px 8px;
    }
    
    .focus-mode .p-score {
        font-size: 38px;
    }
    
    .focus-mode .p-temp {
        font-size: 13px;
        margin-top: 4px;
    }
    
    .badge-1 { background: #FFD700; }
    .badge-2 { background: #C0C0C0; }
    .badge-3 { background: #CD7F32; }
    .badge-none { background: var(--text-sec); opacity: 0.5; }

    .p-name-btn { font-size: 12px; font-weight: 900; text-transform: uppercase; cursor: pointer; display: inline-block; padding: 4px 10px; border: 1px solid var(--border); border-radius: 10px; margin-bottom: 8px; }
    .p-score { font-size: 44px; font-weight: 900; cursor: pointer; line-height: 1; letter-spacing: -2px; transition: transform 0.2s ease-out; }
    .p-score.score-bump { animation: scoreBump 0.4s ease-out; }
    .p-temp { font-size: 15px; font-weight: 800; color: var(--primary); min-height: 18px; margin-top: 6px; }

    .h-row { background: var(--card); padding: 12px; border-radius: 18px; display: flex; align-items: center; margin-bottom: 8px; border: 1px solid var(--border); gap: 10px; overflow-x: auto; transition: opacity 0.5s ease; }
    .h-idx { font-size: 10px; font-weight: 900; color: var(--text-sec); min-width: 30px; flex-shrink: 0; }
    .h-scores { display: flex; flex: 1; justify-content: space-between; align-items: center; min-width: max-content; padding-right: 5px; cursor: pointer; }
    .h-score-item { text-align: center; min-width: 50px; padding: 0 5px; }

    .sel-box { 
        background: var(--card); 
        padding: 12px; 
        border-radius: 18px; 
        text-align: center; 
        flex: 1; 
        border: 3px solid transparent; 
        min-width: 80px; 
        transition: transform 0.2s cubic-bezier(0.34, 1.56, 0.64, 1), border-color 0.2s; 
        position: relative;
        z-index: 1;
        margin-bottom: 0;
    }
    .sel-box.active { 
        border-color: var(--p-color); 
        transform: scale(1.04);
        box-shadow: 0 5px 15px rgba(0,0,0,0.05);
        z-index: 2;
    }
    .numpad { display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; }
    .btn-nb { background: var(--card); border: none; height: 58px; border-radius: 16px; font-size: 22px; font-weight: 700; color: var(--text); box-shadow: 0 3px 0 var(--border); cursor: pointer; }
    .btn-nb:active { transform: translateY(3px); box-shadow: none; }

    .dock { 
        position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%); width: 90%; max-width: 450px; z-index: 2000; 
        background: var(--glass-bg);
        backdrop-filter: blur(25px) saturate(200%);
        -webkit-backdrop-filter: blur(25px) saturate(200%);
        border: 1px solid var(--glass-border);
        box-shadow: var(--glass-shadow);
        border-radius: 26px;
        transition: opacity 0.5s ease;
    }
    .btn-main { width: 100%; background: var(--text); color: var(--bg); border: none; padding: 20px; border-radius: 20px; font-size: 16px; font-weight: 900; box-shadow: 0 5px 15px rgba(0,0,0,0.1); cursor: pointer; transition: transform 0.1s; }
    .btn-main:active { transform: scale(0.98); }
    .btn-main.editing { background: var(--dealer); color: #000; }


/* ‚Äî OVERLAY FOND MODE ZEN ‚Äî */
/* Overlay zen SUPPRIM√â - pas n√©cessaire */

    /* === TRANSITIONS DOUCES MODE ZEN === */
    .focus-mode #dock {
        opacity: 1 !important;
        pointer-events: auto !important;
        transform: translateX(-50%) !important;
        z-index: 200;
        animation: dockSlideUp 0.6s cubic-bezier(0.34, 1.56, 0.64, 1) 0.3s backwards;
    }
    
    /* Transition douce pour les cartes en mode Zen */
    .p-card {
        transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
    }
    
    .focus-mode .p-card {
        transition: all 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
    }
    
    /* Transition pour le bouton focus */
    .btn-focus {
        transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
    }
    
    .focus-mode .btn-focus {
        transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
    }

    @keyframes dockSlideUp {
        0% { opacity: 0; transform: translateX(-50%) translateY(50px); }
        100% { opacity: 1; transform: translateX(-50%) translateY(0); }
    }


/* ‚Äî LE BOUTON OEIL EN MODE ZEN ‚Äî */
.focus-mode .btn-focus {
position: fixed;
top: max(15px, env(safe-area-inset-top));
right: 15px;
z-index: 2000;
background: var(--card);
border: 1px solid var(--primary);
color: var(--primary);
box-shadow: 0 5px 15px rgba(0,0,0,0.2);
transform: scale(1.1);
}

.focus-mode header > *:not(.btn-focus) {
opacity: 0;
pointer-events: none;
}

/* Masquer les √©l√©ments non essentiels en mode Zen */
.focus-mode .chart-box,
.focus-mode #history,
.focus-mode #history-header {
opacity: 0;
pointer-events: none;
position: absolute;
}

/* ‚Äî CORRECTION DE LA GRILLE (Plus de fond noir vide) ‚Äî */
.focus-mode .players-grid {
position: fixed;
top: 0;
left: 0;
width: 100%;
height: 100vh;
height: 100dvh;
padding: max(20px, env(safe-area-inset-top)) 15px calc(100px + env(safe-area-inset-bottom)) 15px;
margin: 0;
display: grid;
grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
align-content: center;
gap: 15px;
z-index: 100;
transform: none !important;
opacity: 1 !important;
animation: simpleFadeIn 0.3s ease-out backwards;
overflow-y: auto;
-webkit-overflow-scrolling: touch;
}

@keyframes simpleFadeIn {
from { opacity: 0; }
to { opacity: 1; }
}

.focus-mode .p-card {
display: flex;
flex-direction: column;
justify-content: center;
align-items: center;
height: 100%;
min-height: 140px;
padding: 20px;
box-shadow: 0 10px 40px rgba(0,0,0,0.15);
border-width: 0;
background: var(--card);
animation: none !important;
transition: none !important;
}

.focus-mode .p-card:nth-child(n) { animation-delay: 0s; }

.focus-mode .rank-change { animation: none !important; }

.focus-mode .p-score {
font-size: 68px !important;
letter-spacing: -3px;
}

.focus-mode .p-score:active {
animation: scoreClick 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
}

@keyframes scoreClick {
0% { transform: scale(1); }
50% { transform: scale(0.92); }
100% { transform: scale(1); }
}

@keyframes badgePopIn {
0% { opacity: 0; transform: scale(0) rotate(-180deg); }
100% { opacity: 1; transform: scale(1) rotate(0deg); }
}

.focus-mode .p-name-btn {
font-size: 15px;
padding: 7px 16px;
}

.focus-mode .p-temp {
font-size: 20px;
margin-top: 12px;
}

.focus-mode-cta {
position: fixed;
bottom: 300px;
right: 20px;
top: auto;
background: var(--primary);
color: white;
box-shadow: 0 4px 15px rgba(0,0,0,0.3);
border: none;
padding: 12px 20px;
border-radius: 30px;
font-weight: 800;
font-size: 13px;
z-index: 9999;
cursor: pointer;
opacity: 0;
pointer-events: none;
transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
transform: translateY(20px) scale(0.9);
}

@keyframes ctaSlideIn {
0% { opacity: 0; transform: translateX(100px); }
100% { opacity: 1; transform: translateX(0); }
}

.focus-mode .focus-mode-cta {
opacity: 1;
pointer-events: auto;
transform: translateY(0) scale(1);
}
.focus-mode-cta:active { transform: scale(0.95); }

/* ‚Äî STATS STYLES ‚Äî */
.stats-tabs { display: flex; gap: 10px; margin-bottom: 20px; border-bottom: 1px solid var(--border); padding-bottom: 10px; }
.stats-tab { flex: 1; text-align: center; padding: 10px; border-radius: 10px; cursor: pointer; font-weight: 700; font-size: 14px; opacity: 0.5; transition: 0.3s; }
.stats-tab.active { opacity: 1; background: var(--primary); color: white; box-shadow: 0 4px 10px rgba(0,0,0,0.1); }

.mode-filter {
display: flex;
gap: 8px;
margin-bottom: 15px;
padding: 0 5px;
}

.filter-btn, .filter-btn-records {
flex: 1;
padding: 8px 12px;
border-radius: 10px;
border: 1px solid var(--border);
background: var(--card);
font-size: 12px;
font-weight: 700;
cursor: pointer;
transition: all 0.2s;
color: var(--text);
}

.filter-btn.active, .filter-btn-records.active {
background: var(--primary);
color: white;
border-color: var(--primary);
}

.rank-item { display: flex; align-items: center; padding: 12px; border-bottom: 1px solid var(--border); cursor: pointer; transition: background 0.2s; }
.rank-item:hover { background: rgba(0,0,0,0.03); }
.rank-item:last-child { border-bottom: none; }
.rank-num { font-size: 20px; font-weight: 900; width: 30px; color: var(--text-sec); font-style: italic; }
.rank-1 .rank-num { color: #FFD700; } .rank-2 .rank-num { color: #C0C0C0; } .rank-3 .rank-num { color: #CD7F32; }
.rank-info { flex: 1; }
.rank-name { font-weight: 900; font-size: 16px; }
.rank-sub { font-size: 12px; color: var(--text-sec); }
.rank-val { font-weight: 800; font-size: 18px; }

.stat-detail { background: var(--card); padding: 15px; border-radius: 15px; margin-bottom: 15px; border: 1px solid var(--border); }
.stat-detail h4 { margin: 0 0 5px 0; font-size: 12px; text-transform: uppercase; color: var(--text-sec); }
.stat-detail .value { font-size: 24px; font-weight: 900; color: var(--text); }

.toast {
position: fixed;
top: max(60px, calc(env(safe-area-inset-top) + 40px));
left: 50%;
transform: translateX(-50%) translateY(-100px);
background: var(--glass-bg);
backdrop-filter: blur(20px);
-webkit-backdrop-filter: blur(20px);
border: 1px solid var(--glass-border);
padding: 16px 24px;
border-radius: 20px;
box-shadow: var(--glass-shadow);
font-weight: 700;
z-index: 5000;
opacity: 0;
transition: all 0.3s;
white-space: nowrap;
}
.toast.show { opacity: 1; transform: translateX(-50%) translateY(0); }
.toast.success { border-color: var(--success); background: var(--success); color: white; border: none; }
.toast.warning { border-color: var(--dealer); background: var(--dealer); color: white; border: none; }
.toast.error { border-color: var(--danger); background: var(--danger); color: white; border: none; }
.toast.info { border-color: var(--primary); background: var(--primary); color: white; border: none; }

.victory-overlay {
position: fixed; inset: 0; background: rgba(0,0,0,0.6); backdrop-filter: blur(10px); z-index: 6000;
display: flex; align-items: center; justify-content: center; opacity: 0; pointer-events: none;
transition: 0.3s; overflow-y: auto; padding: 20px;
}
.victory-overlay.active { opacity: 1; pointer-events: auto; }

.podium-container { display: flex; align-items: flex-end; justify-content: center; gap: 8px; margin: 30px 0; height: 180px; }
.podium-place { flex: 1; max-width: 110px; display: flex; flex-direction: column; align-items: center; animation: podiumEntrance 0.8s cubic-bezier(0.34, 1.56, 0.64, 1) backwards; }
.podium-place.p1 { animation-delay: 0.3s; } .podium-place.p2 { animation-delay: 0s; } .podium-place.p3 { animation-delay: 0.15s; }
.podium-avatar {
width: 60px; height: 60px; border-radius: 50%; display: flex; align-items: center; justify-content: center;
font-size: 28px; font-weight: 900; margin-bottom: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.2); position: relative;
transition: transform 0.3s ease;
}
.podium-place.p1 .podium-avatar {
animation: podiumGlow 2s ease-in-out infinite;
}
.podium-avatar:hover {
    transform: scale(1.1);
}
.podium-crown { position: absolute; top: -15px; font-size: 24px; animation: crownFloat 2s ease-in-out infinite; }
.podium-name { font-size: 11px; font-weight: 900; text-align: center; margin-bottom: 6px; }
.podium-score { font-size: 16px; font-weight: 900; margin-bottom: 8px; }
.podium-bar {
width: 100%; border-radius: 12px 12px 0 0; display: flex; align-items: center; justify-content: center;
font-size: 32px; font-weight: 900; color: white; box-shadow: 0 -2px 8px rgba(0,0,0,0.1);
transition: all 0.3s ease;
}
.podium-bar:hover {
    transform: scaleY(1.05);
}
.podium-place.p1 .podium-bar { background: linear-gradient(180deg, #FFD700, #FFA500); height: 100px; }
.podium-place.p2 .podium-bar { background: linear-gradient(180deg, #E8E8E8, #A8A8A8); height: 70px; }
.podium-place.p3 .podium-bar { background: linear-gradient(180deg, #CD7F32, #8B4513); height: 50px; }

.victory-tabs { display: flex; gap: 8px; margin-bottom: 20px; border-bottom: 2px solid var(--border); padding-bottom: 8px; }
.victory-tab { flex: 1; text-align: center; padding: 10px 8px; border-radius: 8px; cursor: pointer; font-weight: 700; font-size: 13px; opacity: 0.5; transition: 0.2s; }
.victory-tab.active { opacity: 1; background: var(--primary); color: white; box-shadow: 0 4px 10px rgba(0,0,0,0.15); }

.highlight-card { background: rgba(0,0,0,0.03); padding: 12px; border-radius: 12px; margin-bottom: 10px; display: flex; align-items: center; gap: 12px; border: 1px solid var(--border); }
.highlight-icon { font-size: 28px; }
.highlight-text { flex: 1; }
.highlight-label { font-size: 11px; color: var(--text-sec); font-weight: 600; }
.highlight-value { font-size: 14px; font-weight: 900; }

.player-stats-row { display: flex; align-items: center; padding: 10px; border-bottom: 1px solid var(--border); }
.player-stats-row:last-child { border-bottom: none; }
.player-stats-rank { width: 30px; font-size: 18px; font-weight: 900; }
.player-stats-info { flex: 1; }
.player-stats-name { font-size: 14px; font-weight: 900; }
.player-stats-score { font-size: 16px; font-weight: 900; }

@keyframes podiumRise { from { transform: translateY(100px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }

#confirm-modal .modal-box { text-align: center; }
#confirm-msg { font-size: 18px; margin: 0 0 25px 0; color: var(--text); }
.confirm-actions { display: flex; gap: 10px; }
.btn-confirm-no { background: var(--card); color: var(--text); border: 1px solid var(--border); }
.btn-confirm-yes { background: var(--danger); color: white; border: 1px solid var(--danger); }
</style>

</head>
<body>
    <div id="toast" class="toast"></div>
    
    <!-- === INDICATEUR DE CHARGEMENT === -->
    <div id="loading-overlay" class="loading-overlay">
        <div class="loading-spinner"></div>
        <div id="loading-text" class="loading-text">G√©n√©ration en cours...</div>
        <div id="loading-progress" class="loading-progress"></div>
    </div>

<div id="confirm-modal" class="modal-overlay">
    <div class="modal-box">
        <h3 id="confirm-msg">Confirmer l'action ?</h3>
        <div class="confirm-actions">
            <button class="btn-main btn-confirm-no" onclick="UI.closeConfirm()">Annuler</button>
            <button id="confirm-yes-btn" class="btn-main btn-confirm-yes">Confirmer</button>
        </div>
    </div>
</div>

<div id="stats-modal" class="modal-overlay" onclick="if(event.target===this) UI.closeStats()">
    <div class="modal-box large">
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:20px;">
            <h2 style="margin:0">üìä Statistiques</h2>
            <button onclick="UI.closeStats()" style="background:none; border:none; font-size:24px; color:var(--text); cursor:pointer;">‚úï</button>
        </div>
        <div class="stats-tabs">
            <div id="tab-rank" class="stats-tab active" onclick="UI.switchStatsTab('rank')">Classement</div>
            <div id="tab-records" class="stats-tab" onclick="UI.switchStatsTab('records')">Records</div>
        </div>
        <div id="stats-content-rank">
            <div class="mode-filter">
                <button class="filter-btn active" onclick="UI.filterStats('all')">Tous</button>
                <button class="filter-btn" onclick="UI.filterStats('belote')">üÉè Belote</button>
                <button class="filter-btn" onclick="UI.filterStats('standard')">üé≤ Standard</button>
            </div>
            <div id="ranking-list"></div>
        </div>
        <div id="stats-content-player" class="hidden">
            <button onclick="UI.showRanking()" style="background:none; border:none; color:var(--primary); font-weight:700; font-size:14px; margin-bottom:10px; cursor:pointer;">‚Üê Retour au classement</button>
            <div id="player-detail-content"></div>
        </div>
        <div id="stats-content-records" class="hidden">
            <div class="mode-filter">
                <button class="filter-btn-records active" onclick="UI.filterRecords('all')">Tous</button>
                <button class="filter-btn-records" onclick="UI.filterRecords('belote')">üÉè Belote</button>
                <button class="filter-btn-records" onclick="UI.filterRecords('standard')">üé≤ Standard</button>
            </div>
            <div id="records-list"></div>
        </div>
    </div>
</div>

<div id="modal-player-count" class="modal-overlay" onclick="if(event.target===this) document.getElementById('modal-player-count').classList.remove('active')">
    <div class="modal-box" style="max-width: 400px;">
        <h2 style="margin:0 0 10px 0" id="mode-setup-title">Mode Standard</h2>
        <p style="color:var(--text-sec); margin-bottom:20px;">Combien de joueurs ?</p>
        <div style="display:grid; grid-template-columns: repeat(3, 1fr); gap:10px; margin-bottom:25px;">
            <button class="btn-nb" onclick="app.selectPlayerCount(2)">2</button>
            <button class="btn-nb" onclick="app.selectPlayerCount(3)">3</button>
            <button class="btn-nb" onclick="app.selectPlayerCount(4)">4</button>
            <button class="btn-nb" onclick="app.selectPlayerCount(5)">5</button>
            <button class="btn-nb" onclick="app.selectPlayerCount(6)">6</button>
            <button id="btn-toggle-players" class="btn-nb" style="background:rgba(120,120,128,0.12); font-size:14px;" onclick="app.toggleMorePlayers()">Plus ‚ñº</button>
            <div id="extra-players" class="hidden" style="grid-column: 1 / -1; display:contents;">
                <button class="btn-nb" onclick="app.selectPlayerCount(7)">7</button>
                <button class="btn-nb" onclick="app.selectPlayerCount(8)">8</button>
                <button class="btn-nb" onclick="app.selectPlayerCount(9)">9</button>
                <button class="btn-nb" onclick="app.selectPlayerCount(10)">10</button>
                <button class="btn-nb" onclick="app.selectPlayerCount(11)">11</button>
                <button class="btn-nb" onclick="app.selectPlayerCount(12)">12</button>
            </div>
        </div>
        
        <!-- Nouvelles options -->
        <div style="border-top: 1px solid var(--border); padding-top: 20px; margin-top: 10px;">
            <div style="margin-bottom: 20px;">
                <label style="font-size: 13px; font-weight: 700; color: var(--text); margin-bottom: 10px; display: block;">üéØ Objectif de victoire</label>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                    <label style="display: flex; align-items: center; justify-content: center; background: var(--card); border: 2px solid var(--border); border-radius: 12px; padding: 12px; cursor: pointer; transition: all 0.2s;" id="victory-highest-label">
                        <input type="radio" name="victory-condition" value="highest" checked style="margin-right: 8px; accent-color: var(--primary);" onchange="app.updateVictoryCondition()">
                        <span style="font-size: 12px; font-weight: 700;">‚¨ÜÔ∏è Plus HAUT</span>
                    </label>
                    <label style="display: flex; align-items: center; justify-content: center; background: var(--card); border: 2px solid var(--border); border-radius: 12px; padding: 12px; cursor: pointer; transition: all 0.2s;" id="victory-lowest-label">
                        <input type="radio" name="victory-condition" value="lowest" style="margin-right: 8px; accent-color: var(--primary);" onchange="app.updateVictoryCondition()">
                        <span style="font-size: 12px; font-weight: 700;">‚¨áÔ∏è Plus BAS</span>
                    </label>
                </div>
            </div>
            
            <div>
                <label style="font-size: 13px; font-weight: 700; color: var(--text); margin-bottom: 10px; display: block;">üèÅ Condition de fin</label>
                <div style="display: grid; gap: 8px;">
                    <label style="display: flex; align-items: center; background: var(--card); border: 2px solid var(--border); border-radius: 12px; padding: 12px; cursor: pointer;" id="end-free-label">
                        <input type="radio" name="end-condition" value="free" checked style="margin-right: 10px; accent-color: var(--primary);" onchange="app.updateEndCondition()">
                        <span style="font-size: 12px; font-weight: 700; flex: 1;">‚ôæÔ∏è Partie libre</span>
                    </label>
                    <label style="display: flex; align-items: center; background: var(--card); border: 2px solid var(--border); border-radius: 12px; padding: 12px; cursor: pointer;" id="end-score-label">
                        <input type="radio" name="end-condition" value="score" style="margin-right: 10px; accent-color: var(--primary);" onchange="app.updateEndCondition()">
                        <span style="font-size: 12px; font-weight: 700; flex: 1;" id="score-label-text">üéØ Score objectif :</span>
                        <input type="number" id="score-target" value="100" min="10" max="9999" style="width: 70px; padding: 6px; border: 1px solid var(--border); border-radius: 8px; font-size: 14px; font-weight: 700; text-align: center; background: var(--bg); color: var(--text);" onclick="event.stopPropagation(); document.querySelector('input[name=end-condition][value=score]').checked = true; app.updateEndCondition();">
                    </label>
                </div>
            </div>
        </div>
    </div>
</div>

<div id="setup" class="container">
    <div class="header-controls">
        <h1 class="welcome-title" style="margin:0; flex:1;">ScoreMaster</h1>
        <div style="display:flex; gap:10px;">
            <button class="btn-stats" onclick="app.showStats()" title="Statistiques">üìä</button>
            <button id="theme-toggle" class="theme-toggle" onclick="app.toggleTheme()">üåô</button>
        </div>
    </div>
    <div class="mode-btn" onclick="app.showModeSelection('belote')">
        <span style="font-size:30px; margin-right:15px;">üÉè</span>
        <div><h2 style="margin:0">Belote / Coinche</h2><p style="margin:4px 0 0; font-size:12px; color:var(--text-sec)">Points √† 162 ‚Ä¢ Capot 252</p></div>
    </div>
    <div class="mode-btn" onclick="app.showModeSelection('standard')">
        <span style="font-size:30px; margin-right:15px;">üé≤</span>
        <div><h2 style="margin:0">Standard</h2><p style="margin:4px 0 0; font-size:12px; color:var(--text-sec)">Scores libres ‚Ä¢ Jusqu'√† 12 joueurs</p></div>
    </div>
    <div style="margin-top: 40px;">
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:15px;">
            <h3 style="margin:0; font-size:18px; font-weight:900;">üìö Historique des parties</h3>
            <button onclick="app.clearAll()" style="background:none; border:none; color:var(--danger); font-weight:900; font-size:12px; cursor:pointer;">TOUT EFFACER</button>
        </div>
        <div id="games-list"></div>
    </div>
    <div class="guide-container">
        <b style="display:block; margin-bottom:8px; color:var(--text)">üìñ Guide Rapide</b>
        ‚Ä¢ Cliquez sur le <b style="color:var(--text)">NOM</b> pour le donneur üÉè<br>
        ‚Ä¢ Cliquez sur le <b style="color:var(--text)">SCORE</b> pour les points ‚úçÔ∏è<br>
        ‚Ä¢ Cliquez sur l'<b style="color:var(--text)">HISTORIQUE</b> pour corriger ‚úèÔ∏è
    </div>
</div>

<div id="game" class="container hidden">
    <header style="display:flex; justify-content:space-between; align-items:center; margin-bottom:20px;">
        <button onclick="app.showSetup()" style="background:var(--card); border:1px solid var(--border); width:40px; height:40px; border-radius:12px; color:var(--text); cursor:pointer;">‚¨ÖÔ∏è</button>
        <div style="flex:1; text-align:center;">
            <h1 id="mode-title" style="margin:0; font-size:22px; font-weight:900;">SCORE</h1>
            <div id="game-info" style="font-size:10px; color:var(--text-sec); font-weight:700; margin-top:3px;"></div>
        </div>
        <button class="btn-focus" onclick="app.toggleFocusMode()" title="Mode Zen">üëÅÔ∏è</button>
    </header>
    <div class="chart-box"><canvas id="chart"></canvas></div>
    <div id="grid" class="players-grid"></div>
    <div id="history-header" style="display:flex; justify-content:space-between; margin: 30px 0 10px; font-size:11px; font-weight:900; color:var(--text-sec);">
        <span>HISTORIQUE DES MANCHES</span>
        <div style="display:flex; gap:12px;">
            <button onclick="app.finishGame()" style="background:none; border:none; color:var(--success); font-weight:900; cursor:pointer;">‚úì TERMINER</button>
            <button onclick="app.undo()" style="background:none; border:none; color:var(--danger); font-weight:900; cursor:pointer;">ANNULER</button>
        </div>
    </div>
    <div id="history"></div>
</div>

<div id="dock" class="dock hidden">
    <button id="save-btn" class="btn-main" onclick="app.validateRound()">ENREGISTRER MANCHE 1</button>
</div>

<div id="modal-player" class="modal-overlay" onclick="if(event.target===this) app.closeModal()">
    <div class="modal-player-wrapper">
        <div class="modal-box" style="max-width: 340px;">
            <h2 id="modal-title" style="margin:0 0 20px 0">Joueur</h2>
            <input type="text" id="edit-name" style="width:100%; padding:15px; border-radius:12px; border:2px solid var(--border); font-size:18px; font-weight:700; outline:none; background:var(--bg); color:var(--text);" placeholder="Nom du joueur">
            <label style="display:flex; align-items:center; justify-content:space-between; background:var(--bg); padding:15px; border-radius:12px; font-weight:700; cursor:pointer; margin-top:20px;">
                Donneur üÉè <input type="checkbox" id="edit-dealer" style="width:20px; height:20px; accent-color:var(--dealer);">
            </label>
            <button class="btn-main" style="margin-top:20px; background:var(--primary); color:white" onclick="app.savePlayer()">VALIDER</button>
        </div>
        <div id="recent-players-suggestions" class="recent-suggestions"></div>
    </div>
</div>

<div id="sheet" class="sheet-overlay" onclick="app.closeSheet()">
    <div class="sheet-content" onclick="event.stopPropagation()">
        <div id="input-switcher" style="display:flex; gap:8px; margin-bottom:20px; overflow-x:auto; padding: 10px 20px 5px 20px; scroll-snap-type: x mandatory;"></div>
        <div style="display:grid; grid-template-columns: repeat(4, 1fr); gap:8px; margin-bottom:12px;">
            <button id="calc-btn" class="btn-nb hidden" style="grid-column:span 4; background:var(--success); color:white; font-size:14px; box-shadow:none;" onclick="app.calcRest()">‚ú® RESTE √Ä 162</button>
            <button class="btn-nb" style="background:rgba(120,120,128,0.12); font-size:14px; box-shadow:none;" onclick="app.addVal(10)">+10</button>
            <button class="btn-nb" style="background:rgba(120,120,128,0.12); font-size:14px; box-shadow:none;" onclick="app.addVal(20)">+20</button>
            <button id="btn-82" class="btn-nb hidden" style="background:rgba(120,120,128,0.12); font-size:14px; box-shadow:none;" onclick="app.addVal(82)">+82</button>
            <button id="btn-50" class="btn-nb hidden" style="background:rgba(120,120,128,0.12); font-size:14px; box-shadow:none;" onclick="app.addVal(50)">+50</button>
            <button id="smart-btn" class="btn-nb" style="background:var(--text); color:var(--bg); font-size:14px; box-shadow:none;" onclick="app.handleSmart()">+/-</button>
        </div>
        <div class="numpad">
            <button class="btn-nb" onclick="app.typeNum(1)">1</button><button class="btn-nb" onclick="app.typeNum(2)">2</button><button class="btn-nb" onclick="app.typeNum(3)">3</button>
            <button class="btn-nb" onclick="app.typeNum(4)">4</button><button class="btn-nb" onclick="app.typeNum(5)">5</button><button class="btn-nb" onclick="app.typeNum(6)">6</button>
            <button class="btn-nb" onclick="app.typeNum(7)">7</button><button class="btn-nb" onclick="app.typeNum(8)">8</button><button class="btn-nb" onclick="app.typeNum(9)">9</button>
            <button class="btn-nb" style="color:var(--danger)" onclick="app.clearInput()">C</button>
            <button class="btn-nb" onclick="app.typeNum(0)">0</button>
            <button class="btn-nb" onclick="app.backspace()">‚å´</button>
        </div>
        <button class="btn-main" style="margin-top:15px; background:var(--primary); color:white" onclick="app.closeSheet()">OK</button>
    </div>
</div>

<div id="victory" class="victory-overlay">
    <div class="victory-box">
        <h2 class="text-center" style="margin:0 0 10px 0; font-size:28px;">üèÜ PARTIE TERMIN√âE</h2>
        
        <div class="victory-tabs">
            <div class="victory-tab active" onclick="UI.switchVictoryTab('podium')">üèÜ Podium</div>
            <div class="victory-tab" onclick="UI.switchVictoryTab('stats')">üìä Stats</div>
            <div class="victory-tab" onclick="UI.switchVictoryTab('highlights')">‚≠ê Highlights</div>
        </div>

        <div id="victory-tab-podium">
            <div class="podium-container" id="podium"></div>
        </div>

        <div id="victory-tab-stats" class="hidden">
            <div id="victory-all-players"></div>
        </div>

        <div id="victory-tab-highlights" class="hidden">
            <div id="victory-highlights"></div>
        </div>

        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin: 20px 0 12px;">
            <button class="btn-main" style="background:linear-gradient(135deg, #2B5AA0 0%, #1E3F6E 100%); color:white; font-size:16px;" onclick="app.shareRecapPNG()">
                üì∏ PNG
            </button>
            <button class="btn-main" style="background:linear-gradient(135deg, #667eea 0%, #764ba2 100%); color:white; font-size:16px;" onclick="app.shareRecapGIF()">
                üé¨ GIF
                <div style="font-size:10px; opacity:0.8; margin-top:2px;">~30s</div>
            </button>
        </div>
        <button class="btn-main" style="background:var(--primary); color:white; margin:0 0 12px;" onclick="app.restartWithSamePlayers()">üîÑ REJOUER (m√™mes joueurs)</button>
        <button class="btn-main" style="background:var(--card); border:1px solid var(--border); color:var(--text);" onclick="app.showSetup()">üè† RETOUR MENU</button>
    </div>
</div>

<script>
    // ==================== SOUND ENGINE AM√âLIOR√â ====================
    const SoundFX = {
        ctx: null, 
        enabled: true,
        audioAvailable: false,
        
        init() {
            // V√©rifier si l'API Audio est disponible
            try {
                if (window.AudioContext || window.webkitAudioContext) {
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                    this.audioAvailable = true;
                    if (this.ctx.state === 'suspended') {
                        // Tenter de r√©sumer sur interaction utilisateur
                        document.addEventListener('click', () => {
                            if (this.ctx && this.ctx.state === 'suspended') {
                                this.ctx.resume().catch(() => {});
                            }
                        }, { once: true });
                    }
                } else {
                    console.warn("AudioContext non support√© - mode silencieux");
                    this.enabled = false;
                    this.audioAvailable = false;
                }
            } catch (e) { 
                console.warn("Audio API non disponible:", e.message);
                this.enabled = false;
                this.audioAvailable = false;
            }
        },
        
        playTone(freq, type, duration) {
            if (!this.enabled || !this.audioAvailable || !this.ctx) return;
            
            try {
                if (this.ctx.state === 'suspended') {
                    this.ctx.resume().catch(() => {});
                }
                
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + duration);
            } catch (e) {
                // Silencieux en cas d'erreur
            }
        },
        
        click() { 
            if (this.enabled) this.playTone(800, 'sine', 0.1); 
        },
        
        slide() { 
            if (!this.enabled || !this.audioAvailable || !this.ctx) return;
            try {
                const bufferSize = this.ctx.sampleRate * 0.15; 
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
                const noise = this.ctx.createBufferSource();
                noise.buffer = buffer;
                const gain = this.ctx.createGain();
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 400;
                gain.gain.setValueAtTime(0.05, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.15);
                noise.connect(filter);
                filter.connect(gain);
                gain.connect(this.ctx.destination);
                noise.start();
            } catch (e) {}
        },
        
        success() { 
            if (this.enabled) {
                this.playTone(600, 'sine', 0.1); 
                setTimeout(() => this.playTone(900, 'sine', 0.2), 100);
            }
        },
        
        error() { 
            if (this.enabled) this.playTone(150, 'sawtooth', 0.3); 
        }
    };

    // ==================== DATA LAYER ====================
    const GameState = {
        create(mode, playerCount) {
            const colors = ['#007AFF', '#FF2D55', '#34C759', '#FF9500', '#AF52DE', '#5AC8FA', '#FFCC00', '#5856D6', '#FF3B30', '#30B0C7', '#8E8E93', '#4CD964'];
            // CORRECTION BUG #6 : Force minimum 2 joueurs, maximum 12
            const validPlayerCount = Math.max(2, Math.min(playerCount, 12));
            return {
                mode,
                victoryCondition: 'highest',
                players: Array.from({length: validPlayerCount}, (_, i) => ({
                    id: i + 1, 
                    name: mode === 'belote' ? (i === 0 ? 'NOUS' : 'EUX') : `J${i + 1}`, 
                    color: colors[i] || '#000000',
                    total: 0, previousRank: null
                })),
                history: [], temp: {}, dealerId: 1, celebratedMilestones: {}
            };
        },
        addRound(state, scores) {
            const round = {};
            state.players.forEach(p => {
                const score = scores[p.id] || 0;
                round[p.id] = score;
                p.total += score;
            });
            state.history.push(round);
            return state;
        },
        updateRound(state, index, scores) {
            const oldRound = state.history[index];
            state.players.forEach(p => p.total -= (oldRound[p.id] || 0));
            const newRound = {};
            state.players.forEach(p => {
                const score = scores[p.id] || 0;
                newRound[p.id] = score;
                p.total += score;
            });
            state.history[index] = newRound;
            return state;
        },
        deleteRound(state, index) {
            const round = state.history[index];
            state.players.forEach(p => p.total -= (round[p.id] || 0));
            state.history.splice(index, 1);
            return state;
        },
        getSortedPlayers(state) {
            const isLowest = state.victoryCondition === 'lowest';
            return [...state.players].sort((a, b) => 
                isLowest ? a.total - b.total : b.total - a.total
            );
        },
        validate(scores, mode) {
            const values = Object.values(scores);
            if(values.some(v => v > 9999)) return { valid: false, error: 'Score trop √©lev√© (max 9999)' };
            if(mode === 'belote' && values.some(v => v < 0)) return { valid: false, error: 'Score n√©gatif impossible en Belote' };
            return { valid: true };
        }
    };

    // ==================== STORAGE LAYER AM√âLIOR√â ====================
    const Storage = {
        GAMES_KEY: 'sm_v12_games', 
        CURRENT_KEY: 'sm_v12_current',
        memoryFallback: null, // Fallback en m√©moire si localStorage d√©sactiv√©
        storageAvailable: true,
        
        // V√©rifier la disponibilit√© du localStorage
        checkStorageAvailability() {
            try {
                const testKey = '__storage_test__';
                localStorage.setItem(testKey, testKey);
                localStorage.removeItem(testKey);
                this.storageAvailable = true;
                return true;
            } catch (e) {
                console.warn("localStorage non disponible - utilisation m√©moire tampon");
                this.storageAvailable = false;
                if (!this.memoryFallback) {
                    this.memoryFallback = { games: [], current: null };
                }
                return false;
            }
        },
        
        migrateData() {
            if (!this.storageAvailable && !this.checkStorageAvailability()) return;
            
            const v12Data = localStorage.getItem(this.GAMES_KEY);
            if (!v12Data) {
                const v11Data = localStorage.getItem('sm_v11_games');
                if (v11Data) {
                    try {
                        const parsed = JSON.parse(v11Data);
                        if (Array.isArray(parsed) && parsed.length > 0) {
                            localStorage.setItem(this.GAMES_KEY, v11Data);
                            console.log("SM: Migration v11->v12 OK");
                            const v11Current = localStorage.getItem('sm_v11_current');
                            if (v11Current && parsed.find(g => g.id === v11Current)) {
                                localStorage.setItem(this.CURRENT_KEY, v11Current);
                            }
                        }
                    } catch(e) { console.error("SM: Migration √©chou√©e", e); }
                }
            }
        },
        
        // Valider les donn√©es avant sauvegarde
        validateGameData(game) {
            if (!game || typeof game !== 'object') return false;
            if (!game.id || !game.mode || !game.state) return false;
            if (!Array.isArray(game.state.players)) return false;
            if (!Array.isArray(game.state.history)) return false;
            
            // Valider chaque joueur
            for (const player of game.state.players) {
                if (!player.id || typeof player.name !== 'string') return false;
                if (typeof player.total !== 'number') return false;
            }
            
            return true;
        },
        
        // Nettoyer les donn√©es corrompues
        sanitizeGame(game) {
            if (!game) return null;
            
            const sanitized = {
                id: game.id || Date.now().toString(),
                name: String(game.name || 'Partie'),
                mode: game.mode || 'standard',
                date: game.date || new Date().toISOString(),
                victoryCondition: game.victoryCondition || 'highest',
                endCondition: game.endCondition || { type: 'free', value: null },
                finished: Boolean(game.finished),
                state: {
                    mode: game.state?.mode || game.mode || 'standard',
                    players: [],
                    history: [],
                    temp: {},
                    dealerId: game.state?.dealerId || 1,
                    celebratedMilestones: game.state?.celebratedMilestones || {}
                }
            };
            
            // Sanitiser les joueurs
            if (Array.isArray(game.state?.players)) {
                sanitized.state.players = game.state.players.map((p, i) => ({
                    id: p.id || (i + 1),
                    name: String(p.name || `J${i + 1}`).toUpperCase().substring(0, 20),
                    color: p.color || ['#007AFF', '#FF2D55', '#34C759', '#FF9500', '#AF52DE', '#5AC8FA'][i % 6],
                    total: typeof p.total === 'number' ? p.total : 0,
                    previousRank: p.previousRank || null
                }));
            }
            
            // Sanitiser l'historique
            if (Array.isArray(game.state?.history)) {
                sanitized.state.history = game.state.history.map(round => {
                    const sanitizedRound = {};
                    for (const [playerId, score] of Object.entries(round)) {
                        const numScore = Number(score);
                        if (!isNaN(numScore)) {
                            sanitizedRound[playerId] = numScore;
                        }
                    }
                    return sanitizedRound;
                });
            }
            
            return sanitized;
        },
        
        saveGame(game) {
            // Valider d'abord
            if (!this.validateGameData(game)) {
                console.error("SM: Donn√©es invalides, tentative de r√©paration");
                game = this.sanitizeGame(game);
                if (!game) {
                    console.error("SM: Impossible de r√©parer les donn√©es");
                    return false;
                }
            }
            
            // Utiliser le fallback m√©moire si localStorage indisponible
            if (!this.storageAvailable && !this.checkStorageAvailability()) {
                if (!this.memoryFallback) this.memoryFallback = { games: [], current: null };
                const existing = this.memoryFallback.games.findIndex(g => g.id === game.id);
                if (existing >= 0) this.memoryFallback.games[existing] = game;
                else this.memoryFallback.games.push(game);
                this.memoryFallback.current = game.id;
                return true;
            }
            
            try {
                const games = this.loadGames() || [];
                const existing = games.findIndex(g => g.id === game.id);
                if (existing >= 0) games[existing] = game;
                else games.push(game);
                localStorage.setItem(this.GAMES_KEY, JSON.stringify(games));
                localStorage.setItem(this.CURRENT_KEY, game.id);
                return true;
            } catch(e) {
                console.error("SM: Save failed", e);
                // Erreur quota - essayer de nettoyer les vieilles parties
                if (e.name === 'QuotaExceededError') {
                    try {
                        const games = this.loadGames() || [];
                        if (games.length > 5) {
                            // Garder seulement les 5 derni√®res parties
                            const recentGames = games.slice(-5);
                            localStorage.setItem(this.GAMES_KEY, JSON.stringify(recentGames));
                            // R√©essayer la sauvegarde
                            return this.saveGame(game);
                        }
                    } catch (e2) {
                        console.error("SM: Impossible de nettoyer", e2);
                    }
                }
                return false;
            }
        },
        
        loadGames() {
            // Utiliser le fallback m√©moire si localStorage indisponible
            if (!this.storageAvailable && !this.checkStorageAvailability()) {
                return this.memoryFallback?.games || [];
            }
            
            try {
                const data = localStorage.getItem(this.GAMES_KEY);
                if (!data) return [];
                
                const parsed = JSON.parse(data);
                if (!Array.isArray(parsed)) {
                    console.warn("SM: Donn√©es corrompues, r√©initialisation");
                    localStorage.removeItem(this.GAMES_KEY);
                    return [];
                }
                
                // Valider et nettoyer chaque partie
                return parsed.map(game => {
                    try {
                        return this.sanitizeGame(game);
                    } catch (e) {
                        console.warn("SM: Partie corrompue ignor√©e", e);
                        return null;
                    }
                }).filter(g => g !== null);
                
            } catch(e) { 
                console.error("SM: Corrupt data", e); 
                return []; 
            }
        },
        
        loadCurrentGame() {
            // Utiliser le fallback m√©moire si localStorage indisponible
            if (!this.storageAvailable && !this.checkStorageAvailability()) {
                if (!this.memoryFallback) return null;
                return this.memoryFallback.games.find(g => g.id === this.memoryFallback.current);
            }
            
            try {
                const currentId = localStorage.getItem(this.CURRENT_KEY);
                if (!currentId) return null;
                return this.loadGames().find(g => g.id === currentId);
            } catch(e) { return null; }
        },
        
        deleteGame(gameId) {
            // Utiliser le fallback m√©moire si localStorage indisponible
            if (!this.storageAvailable && !this.checkStorageAvailability()) {
                if (this.memoryFallback) {
                    this.memoryFallback.games = this.memoryFallback.games.filter(g => g.id !== gameId);
                    if (this.memoryFallback.current === gameId) {
                        this.memoryFallback.current = null;
                    }
                }
                return;
            }
            
            const games = this.loadGames().filter(g => g.id !== gameId);
            localStorage.setItem(this.GAMES_KEY, JSON.stringify(games));
            const currentId = localStorage.getItem(this.CURRENT_KEY);
            if (currentId === gameId) localStorage.removeItem(this.CURRENT_KEY);
        }
    };

    // ==================== STATS ENGINE ====================
    const StatsEngine = {
        calculateStats(mode = 'all') {
            const games = Storage.loadGames().filter(g =>
                g.finished && (mode === 'all' || g.mode === mode)
            );

            const stats = {};

            games.forEach(game => {
                const isLowest = game.victoryCondition === 'lowest';
                const sortedPlayers = [...game.state.players].sort((a,b) => isLowest ? a.total - b.total : b.total - a.total);
                const winner = sortedPlayers[0];

                game.state.players.forEach(p => {
                    const key = p.name.toUpperCase();
                    if(!stats[key]) {
                        stats[key] = { 
                            wins: 0, 
                            played: 0, 
                            totalScoreSum: 0, 
                            highestScore: 0, 
                            highestRound: 0,
                            lowestRound: Infinity,
                            roundScores: [],
                            totalRounds: 0,
                            gameScores: [],
                            currentStreak: 0,
                            bestStreak: 0
                        };
                    }

                    stats[key].played++;
                    stats[key].totalScoreSum += p.total;
                    stats[key].highestScore = Math.max(stats[key].highestScore, p.total);
                    stats[key].gameScores.push(p.total);

                    // Collecter tous les scores de manches
                    game.state.history.forEach(round => {
                        const roundScore = round[p.id] || 0;
                        stats[key].roundScores.push(roundScore);
                        stats[key].totalRounds++;
                        stats[key].highestRound = Math.max(stats[key].highestRound, roundScore);
                        if(roundScore > 0) {
                            stats[key].lowestRound = Math.min(stats[key].lowestRound, roundScore);
                        }
                    });
                });

                if(winner && stats[winner.name.toUpperCase()]) {
                    stats[winner.name.toUpperCase()].wins++;
                }
            });

            // Calculer les s√©ries de victoires
            const sortedGames = games.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
            const streaks = {};
            
            sortedGames.forEach(game => {
                const isLowest = game.victoryCondition === 'lowest';
                const sortedPlayers = [...game.state.players].sort((a,b) => isLowest ? a.total - b.total : b.total - a.total);
                const winner = sortedPlayers[0];
                
                game.state.players.forEach(p => {
                    const key = p.name.toUpperCase();
                    if(!streaks[key]) streaks[key] = { current: 0, best: 0, counting: true };
                    
                    if(p.id === winner.id && streaks[key].counting) {
                        streaks[key].current++;
                        streaks[key].best = Math.max(streaks[key].best, streaks[key].current);
                    } else {
                        streaks[key].counting = false;
                    }
                });
            });

            return Object.entries(stats).map(([name, data]) => {
                // Calculer la moyenne par manche
                const avgPerRound = data.totalRounds > 0 ? Math.round(data.roundScores.reduce((a,b)=>a+b,0) / data.totalRounds) : 0;
                
                // Calculer la r√©gularit√© (√©cart-type)
                const mean = avgPerRound;
                const variance = data.roundScores.length > 0 
                    ? data.roundScores.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0) / data.roundScores.length 
                    : 0;
                const stdDev = Math.sqrt(variance);
                
                // Convertir l'√©cart-type en score de r√©gularit√© (0-5 √©toiles)
                const maxStdDev = 50;
                const regularityScore = Math.max(0, Math.min(5, 5 - Math.floor((stdDev / maxStdDev) * 5)));
                
                // Calculer la forme r√©cente (5 derni√®res parties)
                const recentGames = data.gameScores.slice(-5);
                const olderGames = data.gameScores.slice(0, -5);
                const recentAvg = recentGames.length > 0 ? recentGames.reduce((a,b)=>a+b,0) / recentGames.length : 0;
                const olderAvg = olderGames.length > 0 ? olderGames.reduce((a,b)=>a+b,0) / olderGames.length : recentAvg;
                const formPercent = olderAvg > 0 ? Math.round(((recentAvg - olderAvg) / olderAvg) * 100) : 0;
                
                return {
                    name,
                    ...data,
                    winRate: data.played ? Math.round((data.wins / data.played) * 100) : 0,
                    avgPerRound,
                    lowestRound: data.lowestRound === Infinity ? 0 : data.lowestRound,
                    regularityScore,
                    regularityStars: '‚≠ê'.repeat(regularityScore) + '‚òÜ'.repeat(5 - regularityScore),
                    currentStreak: streaks[name]?.current || 0,
                    bestStreak: streaks[name]?.best || 0,
                    formPercent,
                    formTrend: formPercent > 0 ? '‚ÜóÔ∏è' : formPercent < 0 ? '‚ÜòÔ∏è' : '‚û°Ô∏è'
                };
            })
            .sort((a,b)=>b.winRate - a.winRate);
        },
        getRecordScores(mode = 'all') {
            const stats = this.calculateStats(mode);
            return stats.sort((a,b) => b.highestScore - a.highestScore).slice(0, 10);
        },
        calculateGameHighlights(state, victoryCondition = 'highest') {
            const isLowest = victoryCondition === 'lowest';
            const highlights = [];
            let bestRound = { score: 0, player: null, roundIdx: 0 };
            state.history.forEach((round, idx) => {
                state.players.forEach(p => {
                    if(round[p.id] > bestRound.score) bestRound = { score: round[p.id], player: p, roundIdx: idx + 1 };
                });
            });
            if(bestRound.player) highlights.push({ icon: 'üî•', label: 'Meilleure manche', value: `${bestRound.player.name} - ${bestRound.score} pts (M${bestRound.roundIdx})`, color: bestRound.player.color });
            
            const rankProgression = {};
            state.players.forEach(p => {
                const ranks = [state.players.length];
                state.history.forEach((round, histIdx) => {
                    const totals = state.players.map(pl => {
                        let c = 0;
                        state.history.slice(0, histIdx + 1).forEach(r => c += r[pl.id] || 0);
                        return { id: pl.id, total: c };
                    }).sort((a,b) => isLowest ? a.total - b.total : b.total - a.total);
                    ranks.push(totals.findIndex(t => t.id === p.id) + 1);
                });
                const maxRank = Math.max(...ranks);
                const finalRank = ranks[ranks.length - 1];
                rankProgression[p.id] = { player: p, improvement: maxRank - finalRank, maxRank, finalRank };
            });
            const comeback = Object.values(rankProgression).sort((a,b) => b.improvement - a.improvement)[0];
            if(comeback && comeback.improvement > 0) highlights.push({ icon: '‚ö°', label: 'Comeback King', value: `${comeback.player.name} (${comeback.maxRank}e ‚Üí ${comeback.finalRank}e)`, color: comeback.player.color });

            const consistency = state.players.map(p => {
                const scores = state.history.map(r => r[p.id] || 0).filter(s => s > 0);
                if(scores.length === 0) return { player: p, std: Infinity };
                const mean = scores.reduce((a,b) => a+b, 0) / scores.length;
                const variance = scores.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0) / scores.length;
                return { player: p, std: Math.sqrt(variance), mean };
            }).sort((a,b) => a.std - b.std)[0];
            if(consistency && consistency.std !== Infinity) highlights.push({ icon: 'üéØ', label: 'Joueur r√©gulier', value: `${consistency.player.name} (${Math.round(consistency.mean)} pts/manche)`, color: consistency.player.color });
            
            if(state.history.length >= 20) highlights.push({ icon: 'üèÉ', label: 'Partie Marathon', value: `${state.history.length} manches jou√©es`, color: 'var(--primary)' });
            return highlights;
        }
    };

    // ==================== UI LAYER AM√âLIOR√â ====================
    const UI = {
        currentStatsMode: 'all',
        
        // === INDICATEUR DE CHARGEMENT ===
        showLoading(message = 'G√©n√©ration en cours...') {
            const overlay = document.getElementById('loading-overlay');
            const textEl = document.getElementById('loading-text');
            const progressEl = document.getElementById('loading-progress');
            if (overlay) {
                if (textEl) textEl.textContent = message;
                if (progressEl) progressEl.textContent = '';
                overlay.classList.add('active');
            }
        },
        
        updateLoadingProgress(progress, message = null) {
            const textEl = document.getElementById('loading-text');
            const progressEl = document.getElementById('loading-progress');
            if (textEl && message) textEl.textContent = message;
            if (progressEl && progress !== null) {
                progressEl.textContent = `${Math.round(progress)}%`;
            }
        },
        
        hideLoading() {
            const overlay = document.getElementById('loading-overlay');
            if (overlay) overlay.classList.remove('active');
        },
        
        showToast(message, type = 'default') {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.className = 'toast show';
            if(type !== 'default') toast.classList.add(type);
            setTimeout(() => toast.classList.remove('show'), 2500);
            if(type === 'success') SoundFX.success();
            else if(type === 'error') SoundFX.error();
        },
        confirm(message, onYes) {
            SoundFX.click();
            const modal = document.getElementById('confirm-modal');
            const msgEl = document.getElementById('confirm-msg');
            const yesBtn = document.getElementById('confirm-yes-btn');
            msgEl.textContent = message;
            modal.classList.add('active');
            const newBtn = yesBtn.cloneNode(true);
            yesBtn.parentNode.replaceChild(newBtn, yesBtn);
            newBtn.addEventListener('click', () => {
                modal.classList.remove('active');
                onYes();
            });
        },
        closeConfirm() { document.getElementById('confirm-modal').classList.remove('active'); },
        
        showStats() {
            SoundFX.click();
            document.getElementById('stats-modal').classList.add('active');
            this.switchStatsTab('rank'); 
        },
        closeStats() { document.getElementById('stats-modal').classList.remove('active'); },
        switchStatsTab(tab) {
            SoundFX.click();
            document.getElementById('tab-rank').classList.remove('active');
            document.getElementById('tab-records').classList.remove('active');
            document.getElementById('stats-content-rank').classList.add('hidden');
            document.getElementById('stats-content-records').classList.add('hidden');
            document.getElementById('stats-content-player').classList.add('hidden');

            if(tab === 'rank') {
                document.getElementById('tab-rank').classList.add('active');
                this.renderRanking();
                document.getElementById('stats-content-rank').classList.remove('hidden');
            } else if (tab === 'records') {
                document.getElementById('tab-records').classList.add('active');
                this.renderRecords();
                document.getElementById('stats-content-records').classList.remove('hidden');
            }
        },
        showRanking() {
            SoundFX.click();
            this.switchStatsTab('rank');
        },
        filterStats(mode) {
            this.currentStatsMode = mode;
            document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
            document.querySelector(`.filter-btn[onclick="UI.filterStats('${mode}')"]`)?.classList.add('active');
            this.renderRanking();
        },
        renderRanking() {
            const data = StatsEngine.calculateStats(this.currentStatsMode);
            const container = document.getElementById('stats-content-rank');
            container.innerHTML = '';
            if(data.length === 0) { container.innerHTML = '<p class="text-center" style="color:var(--text-sec); padding:20px;">Aucune statistique disponible</p>'; return; }
            data.forEach((p, idx) => {
                const streakEmoji = p.currentStreak >= 3 ? 'üî•' : p.currentStreak > 0 ? '‚ö°' : '';
                const formIndicator = p.formPercent > 10 ? '‚ÜóÔ∏è' : p.formPercent < -10 ? '‚ÜòÔ∏è' : '';
                
                const el = document.createElement('div');
                el.className = `rank-item rank-${idx+1}`;
                el.onclick = () => this.renderPlayerDetail(p.name);
                el.innerHTML = `
                    <div class="rank-num">${idx+1}</div>
                    <div class="rank-info">
                        <div class="rank-name">${p.name} ${streakEmoji}${p.currentStreak > 0 ? p.currentStreak : ''}</div>
                        <div class="rank-sub">${p.played} parties ‚Ä¢ Moy. ${p.avgPerRound} pts/manche ${formIndicator}</div>
                    </div>
                    <div class="rank-val" style="color:${p.winRate >= 50 ? 'var(--success)' : 'var(--text)'}">${p.winRate}%</div>
                `;
                container.appendChild(el);
            });
        },
        renderPlayerDetail(name) {
            const allStats = StatsEngine.calculateStats();
            const p = allStats.find(s => s.name === name);
            if(!p) return;
            document.getElementById('stats-content-rank').classList.add('hidden');
            document.getElementById('stats-content-player').classList.remove('hidden');
            document.getElementById('stats-content-records').classList.add('hidden');
            const container = document.getElementById('player-detail-content');
            
            const streakColor = p.currentStreak >= 3 ? 'var(--danger)' : p.currentStreak > 0 ? 'var(--primary)' : 'var(--text)';
            const formColor = p.formPercent > 10 ? 'var(--success)' : p.formPercent < -10 ? 'var(--danger)' : 'var(--text)';
            
            container.innerHTML = `
                <h2 class="text-huge" style="margin:0 0 20px 0;">${name}</h2>
                
                <div style="display:grid; grid-template-columns: 1fr 1fr; gap:12px; margin-bottom:20px;">
                    <div class="stat-detail">
                        <h4 style="font-size:11px; color:var(--text-sec); margin:0 0 5px 0; font-weight:600;">TAUX VICTOIRE</h4>
                        <div class="value" style="font-size:32px; font-weight:900; color:var(--primary);">${p.winRate}%</div>
                    </div>
                    <div class="stat-detail">
                        <h4 style="font-size:11px; color:var(--text-sec); margin:0 0 5px 0; font-weight:600;">S√âRIE ACTUELLE</h4>
                        <div class="value" style="font-size:32px; font-weight:900; color:${streakColor};">${p.currentStreak > 0 ? 'üî• ' : ''}${p.currentStreak}</div>
                    </div>
                </div>
                
                <div style="background:var(--card); border:1px solid var(--border); border-radius:16px; padding:15px; margin-bottom:15px;">
                    <h3 style="font-size:14px; font-weight:700; margin:0 0 12px 0; color:var(--text);">üìä Statistiques D√©taill√©es</h3>
                    <div style="display:grid; gap:10px;">
                        <div style="display:flex; justify-content:space-between; align-items:center;">
                            <span style="font-size:13px; color:var(--text-sec);">Score moyen/manche</span>
                            <span style="font-size:15px; font-weight:700;">${p.avgPerRound} pts</span>
                        </div>
                        <div style="display:flex; justify-content:space-between; align-items:center;">
                            <span style="font-size:13px; color:var(--text-sec);">Meilleur score (manche)</span>
                            <span style="font-size:15px; font-weight:700; color:var(--success);">üèÜ ${p.highestRound} pts</span>
                        </div>
                        <div style="display:flex; justify-content:space-between; align-items:center;">
                            <span style="font-size:13px; color:var(--text-sec);">Pire score (manche)</span>
                            <span style="font-size:15px; font-weight:700; color:var(--danger);">${p.lowestRound} pts</span>
                        </div>
                        <div style="display:flex; justify-content:space-between; align-items:center;">
                            <span style="font-size:13px; color:var(--text-sec);">R√©gularit√©</span>
                            <span style="font-size:15px; font-weight:700;">${p.regularityStars}</span>
                        </div>
                        <div style="display:flex; justify-content:space-between; align-items:center;">
                            <span style="font-size:13px; color:var(--text-sec);">Meilleure s√©rie</span>
                            <span style="font-size:15px; font-weight:700;">üèÖ ${p.bestStreak} victoire${p.bestStreak > 1 ? 's' : ''}</span>
                        </div>
                        <div style="display:flex; justify-content:space-between; align-items:center;">
                            <span style="font-size:13px; color:var(--text-sec);">Forme r√©cente</span>
                            <span style="font-size:15px; font-weight:700; color:${formColor};">${p.formTrend} ${p.formPercent > 0 ? '+' : ''}${p.formPercent}%</span>
                        </div>
                    </div>
                </div>
                
                <div style="background:var(--card); border:1px solid var(--border); border-radius:16px; padding:15px;">
                    <h3 style="font-size:14px; font-weight:700; margin:0 0 12px 0; color:var(--text);">üéÆ Historique</h3>
                    <div style="display:grid; gap:10px;">
                        <div style="display:flex; justify-content:space-between; align-items:center;">
                            <span style="font-size:13px; color:var(--text-sec);">Victoires</span>
                            <span style="font-size:15px; font-weight:700; color:var(--success);">${p.wins} üèÜ</span>
                        </div>
                        <div style="display:flex; justify-content:space-between; align-items:center;">
                            <span style="font-size:13px; color:var(--text-sec);">Parties jou√©es</span>
                            <span style="font-size:15px; font-weight:700;">${p.played}</span>
                        </div>
                        <div style="display:flex; justify-content:space-between; align-items:center;">
                            <span style="font-size:13px; color:var(--text-sec);">Manches jou√©es</span>
                            <span style="font-size:15px; font-weight:700;">${p.totalRounds}</span>
                        </div>
                        <div style="display:flex; justify-content:space-between; align-items:center;">
                            <span style="font-size:13px; color:var(--text-sec);">Record (partie)</span>
                            <span style="font-size:15px; font-weight:700; color:var(--primary);">${p.highestScore} pts</span>
                        </div>
                    </div>
                </div>
            `;
        },
        filterRecords(mode) {
            this.currentStatsMode = mode;
            document.querySelectorAll('.filter-btn-records').forEach(b => b.classList.remove('active'));
            document.querySelector(`.filter-btn-records[onclick="UI.filterRecords('${mode}')"]`)?.classList.add('active');
            this.renderRecords();
        },
        renderRecords() {
            const data = StatsEngine.getRecordScores(this.currentStatsMode || 'all');
            const container = document.getElementById('stats-content-records');
            container.innerHTML = '';
            if(data.length === 0) { container.innerHTML = '<p class="text-center" style="color:var(--text-sec); padding:20px;">Aucun record.</p>'; return; }
            
            // Trouver les records sp√©ciaux
            const bestAvg = [...data].sort((a,b) => b.avgPerRound - a.avgPerRound)[0];
            const bestStreak = [...data].sort((a,b) => b.bestStreak - a.bestStreak)[0];
            const mostRegular = [...data].sort((a,b) => b.regularityScore - a.regularityScore)[0];
            
            // Afficher les records sp√©ciaux en haut
            container.innerHTML += `
                <div style="margin-bottom:20px;">
                    <h3 style="font-size:14px; font-weight:700; margin:0 0 12px 0; color:var(--text);">üèÜ Records Sp√©ciaux</h3>
                    <div style="display:grid; gap:8px;">
                        <div style="background:var(--card); border:1px solid var(--border); border-radius:12px; padding:12px; display:flex; justify-content:space-between; align-items:center;">
                            <div>
                                <div style="font-size:11px; color:var(--text-sec); font-weight:600;">MEILLEURE MOYENNE</div>
                                <div style="font-size:15px; font-weight:700; margin-top:3px;">${bestAvg.name}</div>
                            </div>
                            <div style="font-size:20px; font-weight:900; color:var(--primary);">${bestAvg.avgPerRound}</div>
                        </div>
                        <div style="background:var(--card); border:1px solid var(--border); border-radius:12px; padding:12px; display:flex; justify-content:space-between; align-items:center;">
                            <div>
                                <div style="font-size:11px; color:var(--text-sec); font-weight:600;">MEILLEURE S√âRIE</div>
                                <div style="font-size:15px; font-weight:700; margin-top:3px;">${bestStreak.name}</div>
                            </div>
                            <div style="font-size:20px; font-weight:900; color:var(--danger);">üî• ${bestStreak.bestStreak}</div>
                        </div>
                        <div style="background:var(--card); border:1px solid var(--border); border-radius:12px; padding:12px; display:flex; justify-content:space-between; align-items:center;">
                            <div>
                                <div style="font-size:11px; color:var(--text-sec); font-weight:600;">PLUS R√âGULIER</div>
                                <div style="font-size:15px; font-weight:700; margin-top:3px;">${mostRegular.name}</div>
                            </div>
                            <div style="font-size:18px; font-weight:900;">${mostRegular.regularityStars}</div>
                        </div>
                    </div>
                </div>
                
                <h3 style="font-size:14px; font-weight:700; margin:0 0 12px 0; color:var(--text);">üéØ Meilleurs Scores (Partie)</h3>
            `;
            
            data.forEach((p, idx) => {
                const el = document.createElement('div');
                el.className = 'rank-item';
                el.innerHTML = `
                    <div class="rank-info">
                        <div class="rank-name">${p.name}</div>
                        <div class="rank-sub">Meilleure manche: ${p.highestRound} pts</div>
                    </div>
                    <div class="rank-val">${p.highestScore}</div>
                `;
                container.appendChild(el);
            });
        },
        renderScoreCards(state) {
            const isLowest = app.currentGame.victoryCondition === 'lowest';
            // Toujours trier selon victoryCondition, m√™me en mode Zen
            const sorted = [...state.players].sort((a,b) => {
                const scoreA = a.total + (state.temp[a.id]||0);
                const scoreB = b.total + (state.temp[b.id]||0);
                return isLowest ? scoreA - scoreB : scoreB - scoreA;
            });
            const grid = document.getElementById('grid');
            const rankChanges = new Set();
            app.lastRanks = app.lastRanks || {};

            state.players.forEach(p => {
                const newRank = sorted.findIndex(s => s.id === p.id);
                if(app.lastRanks[p.id] !== undefined && app.lastRanks[p.id] !== newRank) {
                    rankChanges.add(p.id);
                }
                app.lastRanks[p.id] = newRank;
            });
            grid.innerHTML = '';
            // En mode Zen, afficher dans l'ordre tri√© pour que les badges soient corrects
            const displayOrder = sorted;
            displayOrder.forEach(p => {
                const tempScore = state.temp[p.id] || 0;
                const totalScore = p.total + tempScore;
                const rankIdx = sorted.findIndex(s => s.id === p.id);
                let badgeClass = 'badge-none', badgeText = '#' + (rankIdx + 1);
                if(rankIdx === 0) { badgeClass = 'badge-1'; badgeText = 'ü•á'; }
                else if(rankIdx === 1) { badgeClass = 'badge-2'; badgeText = 'ü•à'; }
                else if(rankIdx === 2) { badgeClass = 'badge-3'; badgeText = 'ü•â'; }
                const card = document.createElement('div');
                card.className = `p-card ${state.dealerId === p.id ? 'is-dealer' : ''}`;
                if(rankChanges.has(p.id) && !app.focusMode) card.classList.add('rank-change');
                card.innerHTML = `
                    <div class="rank-badge ${badgeClass} ${rankChanges.has(p.id) ? 'bounce' : ''}">${badgeText}</div>
                    <div class="p-name-btn" style="color:${p.color}; border-color:${p.color}40" onclick="app.openModal(${p.id})">${p.name}</div>
                    <div class="p-score ${tempScore !== 0 ? 'score-bump' : ''}" onclick="app.openSheet(${p.id})">${totalScore}</div>
                    <div class="p-temp">${tempScore ? (tempScore > 0 ? '+' + tempScore : tempScore) : ''}</div>
                    ${state.dealerId === p.id ? '<div style="position:absolute; top:8px; right:8px; font-size:12px;">üÉè</div>' : ''}
                `;
                grid.appendChild(card);
            });
        },
        renderHistory(state, editIdx) {
            const hist = document.getElementById('history');
            hist.innerHTML = '';
            state.history.slice().reverse().forEach((r, i) => {
                const idx = state.history.length - 1 - i;
                const isEditing = idx === editIdx;
                const row = document.createElement('div');
                row.className = 'h-row';
                row.style.borderColor = isEditing ? 'var(--dealer)' : 'var(--border)';
                let scoresHtml = '';
                state.players.forEach(p => {
                    const score = isEditing && state.temp[p.id] !== undefined ? state.temp[p.id] : (r[p.id] || 0);
                    scoresHtml += `
                        <div class="h-score-item">
                            <div style="font-size:7px; color:${p.color}; font-weight:900; opacity:0.7">${p.name.substring(0,4)}</div>
                            <div style="color:${p.color}; font-weight:800; font-size:14px;">${score}</div>
                        </div>
                    `;
                });
                row.innerHTML = `
                    <div class="h-idx">M${idx+1}</div>
                    <div class="h-scores" onclick="app.startEdit(${idx})">${scoresHtml}</div>
                    <button onclick="app.delRound(${idx})" style="border:none; background:none; color:var(--danger); font-size:18px; padding-left:10px; flex-shrink:0;">√ó</button>
                `;
                hist.appendChild(row);
            });
        },
        renderChart(state, editIdx) {
            const ctx = document.getElementById('chart');
            if(!ctx || typeof Chart === 'undefined') return;
            if(app.chart) app.chart.destroy();
            
            // Collecter toutes les valeurs pour d√©terminer les limites
            let allValues = [0];
            const datasets = state.players.map(p => {
                let cumul = 0;
                const data = [0];
                state.history.forEach((h, idx) => {
                    if(idx === editIdx && state.temp[p.id] !== undefined) cumul += state.temp[p.id];
                    else cumul += (h[p.id] || 0);
                    data.push(cumul);
                    allValues.push(cumul);
                });
                if(Object.keys(state.temp).length > 0 && editIdx === null) {
                    const tempTotal = cumul + (state.temp[p.id] || 0);
                    data.push(tempTotal);
                    allValues.push(tempTotal);
                }
                return {
                    label: p.name, data, borderColor: p.color, backgroundColor: p.color + '20', tension: 0.4, pointRadius: 3, pointHoverRadius: 6, borderWidth: 2.5, fill: false
                };
            });
            
            // Calculer les limites min/max pour g√©rer les scores n√©gatifs
            const minValue = Math.min(...allValues);
            const maxValue = Math.max(...allValues);
            const padding = Math.max(Math.abs(maxValue - minValue) * 0.1, 10);
            
            // D√©terminer si on a des scores n√©gatifs
            const hasNegativeScores = minValue < 0;
            const yMin = hasNegativeScores ? Math.floor((minValue - padding) / 50) * 50 : 0;
            const yMax = Math.ceil((maxValue + padding) / 50) * 50;
            
            const labels = ['0', ...state.history.map((_, i) => 'M' + (i + 1))];
            if(Object.keys(state.temp).length > 0 && editIdx === null) labels.push('...');
            
            app.chart = new Chart(ctx, {
                type: 'line',
                data: { labels, datasets },
                options: {
                    responsive: true, maintainAspectRatio: false,
                    interaction: { mode: 'index', intersect: false },
                    plugins: { legend: { display: false }, tooltip: { backgroundColor: 'rgba(0,0,0,0.8)', padding: 12, titleFont: { size: 14, weight: 'bold' }, bodyFont: { size: 13 } } },
                    scales: { 
                        x: { grid: { display: false }, ticks: { font: { size: 10, weight: '700' }, color: '#86868B' } }, 
                        y: { 
                            min: yMin,
                            max: yMax,
                            beginAtZero: !hasNegativeScores, 
                            grid: { color: 'rgba(128,128,128,0.08)' }, 
                            ticks: { font: { size: 10, weight: '600' }, color: '#86868B' } 
                        } 
                    },
                    animation: { duration: 400 }
                }
            });
        },
        switchVictoryTab(tab) {
            SoundFX.click();
            document.querySelectorAll('.victory-tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('[id^="victory-tab-"]').forEach(t => t.classList.add('hidden'));
            const tabIndex = { podium: 1, stats: 2, highlights: 3 };
            document.querySelector(`.victory-tab:nth-child(${tabIndex[tab]})`).classList.add('active');
            document.getElementById(`victory-tab-${tab}`).classList.remove('hidden');
        },
        showVictory(winner, score, state) {
            SoundFX.success();
            const overlay = document.getElementById('victory');
            const isLowest = app.currentGame.victoryCondition === 'lowest';
            const sorted = [...state.players].sort((a,b) => isLowest ? a.total - b.total : b.total - a.total);
            const podium = document.getElementById('podium');
            podium.innerHTML = '';
            
            // === D√âTECTION DES √âGALIT√âS ===
            const ties = [];
            const winningScore = sorted[0].total;
            sorted.forEach((p, idx) => {
                if (p.total === winningScore) {
                    ties.push({ player: p, rank: idx + 1 });
                }
            });
            
            // Si √©galit√©, afficher un message sp√©cial
            if (ties.length > 1) {
                UI.showToast(`ü§ù √âGALIT√â ! ${ties.length} joueurs √† ${winningScore} pts`, 'info');
            }
            
            // Ordre podium: 2√®me (gauche), 1er (centre), 3√®me (droite)
            const top3 = [sorted[1], sorted[0], sorted[2]].filter(p => p);
            top3.forEach((p) => {
                if(!p) return;
                // Calculer le rang correct en tenant compte des √©galit√©s
                let realRank = 1;
                for(let i = 0; i < sorted.length; i++) {
                    // Pour les √©galit√©s, tous les joueurs avec le m√™me score ont le m√™me rang
                    if(sorted[i].total === p.total) {
                        realRank = i + 1;
                        break;
                    }
                    if(sorted[i].id === p.id) {
                        realRank = i + 1;
                        break;
                    }
                }
                
                // V√©rifier si ce joueur est √† √©galit√©
                const isTied = ties.length > 1 && ties.find(t => t.player.id === p.id);
                
                const place = document.createElement('div');
                place.className = `podium-place p${realRank}`;
                place.innerHTML = `
                    <div class="podium-avatar" style="background:${p.color}30; border:3px solid ${p.color};">
                        ${realRank === 1 ? '<div class="podium-crown">üëë</div>' : ''}
                        ${isTied ? '<div style="position:absolute; top:-8px; right:-8px; font-size:12px;">ü§ù</div>' : ''}
                        <span style="color:${p.color}">${p.name.substring(0,2)}</span>
                    </div>
                    <div class="podium-name" style="color:${p.color}">${p.name}${isTied ? ' ü§ù' : ''}</div>
                    <div class="podium-score" style="color:${p.color}">${p.total}</div>
                    <div class="podium-bar">
                        ${realRank === 1 ? 'ü•á' : realRank === 2 ? 'ü•à' : 'ü•â'}
                    </div>
                `;
                podium.appendChild(place);
            });

            const allPlayersDiv = document.getElementById('victory-all-players');
            allPlayersDiv.innerHTML = '';
            sorted.forEach((p, idx) => {
                const stats = this.calculatePlayerGameStats(p, state);
                const bestLabel = isLowest ? 'Pire' : 'Meilleur';
                const row = document.createElement('div');
                row.className = 'player-stats-row';
                row.innerHTML = `
                    <div class="player-stats-rank" style="color:${idx < 3 ? p.color : 'var(--text-sec)'}">${idx+1}</div>
                    <div class="player-stats-info">
                        <div class="player-stats-name" style="color:${p.color}">${p.name}</div>
                        <div style="font-size:11px; color:var(--text-sec);">${bestLabel}: ${stats.best} ‚Ä¢ Moy: ${stats.avg} ‚Ä¢ Manches gagn√©es: ${stats.roundsWon}</div>
                    </div>
                    <div class="player-stats-score" style="color:${p.color}">${p.total}</div>
                `;
                allPlayersDiv.appendChild(row);
            });

            const highlights = StatsEngine.calculateGameHighlights(state, app.currentGame.victoryCondition);
            const highlightsDiv = document.getElementById('victory-highlights');
            highlightsDiv.innerHTML = '';
            if(highlights.length === 0) {
                highlightsDiv.innerHTML = '<p class="text-center" style="color:var(--text-sec); padding:20px;">Aucun highlight.</p>';
            } else {
                highlights.forEach(h => {
                    const card = document.createElement('div');
                    card.className = 'highlight-card';
                    card.innerHTML = `
                        <div class="highlight-icon">${h.icon}</div>
                        <div class="highlight-text">
                            <div class="highlight-label">${h.label}</div>
                            <div class="highlight-value" style="color:${h.color}">${h.value}</div>
                        </div>
                    `;
                    highlightsDiv.appendChild(card);
                });
            }
            overlay.classList.add('active');
            this.switchVictoryTab('podium');
            this.launchFireworks();
            if(navigator.vibrate) navigator.vibrate([100, 50, 100, 50, 200]);
        },
        calculatePlayerGameStats(player, state) {
            const isLowest = app.currentGame?.victoryCondition === 'lowest';
            const scores = state.history.map(r => r[player.id] || 0);
            const nonZero = scores.filter(s => s > 0);
            const best = isLowest ? Math.min(...scores.filter(s => s > 0), 0) : Math.max(...scores, 0);
            const avg = nonZero.length > 0 ? Math.round(nonZero.reduce((a,b) => a+b, 0) / nonZero.length) : 0;
            let roundsWon = 0;
            state.history.forEach(round => {
                const roundScores = state.players.map(p => round[p.id] || 0);
                const targetScore = isLowest ? Math.min(...roundScores.filter(s => s > 0)) : Math.max(...roundScores);
                if(round[player.id] === targetScore && targetScore > 0) roundsWon++;
            });
            return { best, avg, roundsWon };
        },
        closeVictory() { document.getElementById('victory').classList.remove('active'); },
        launchFireworks() {
            const duration = 5000;
            const end = Date.now() + duration;
            const colors = ['#007AFF', '#FF2D55', '#34C759', '#FF9500', '#AF52DE', '#FFD700'];
            (function frame() {
                confetti({ particleCount:3, angle: 60, spread: 55, origin: { x: 0, y: 0.8 }, colors: colors });
                confetti({ particleCount:3, angle: 120, spread: 55, origin: { x: 1, y: 0.8 }, colors: colors });
                if (Date.now() < end) requestAnimationFrame(frame);
            })();
            confetti({ particleCount: 100, spread: 70, origin: { y: 0.6 }, colors: colors });
        },
        launchMilestoneConfetti(score) {
            const colors = ['#007AFF', '#FF2D55', '#34C759', '#FF9500', '#AF52DE', '#FFD700'];
            confetti({ particleCount: 60, spread: 60, origin: { y: 0.6 }, colors: colors });
            let milestone = '';
            if(score >= 1000) milestone = 'üéâ 1000 POINTS !';
            else if(score >= 500) milestone = 'üéä 500 POINTS !';
            else if(score >= 200) milestone = '‚ú® 200 POINTS !';
            if(navigator.vibrate) {
                if(score >= 1000) navigator.vibrate([50, 100, 50, 100, 50]);
                else if(score >= 500) navigator.vibrate([50, 100, 50]);
                else navigator.vibrate(100);
            }
            if(milestone) this.showToast(milestone);
        }
    };

    // ==================== APP CONTROLLER ====================
    const app = {
        currentGame: null, activePlayerId: null, editIdx: null, chart: null, savedPlayers: {}, focusMode: false,
        recentPlayers: [], // Les 8 derniers noms de joueurs utilis√©s

        // Noms par d√©faut √† ne pas sugg√©rer
        defaultNames: ['NOUS', 'EUX', 'J1', 'J2', 'J3', 'J4', 'J5', 'J6', 'J7', 'J8', 'J9', 'J10', 'J11', 'J12'],

        init() {
            Storage.migrateData();
            const savedTheme = localStorage.getItem('sm_theme');
            if(savedTheme) { document.documentElement.setAttribute('data-theme', savedTheme); this.updateThemeIcon(); }
            
            try {
                const savedPlayersData = localStorage.getItem('sm_saved_players');
                if(savedPlayersData) { this.savedPlayers = JSON.parse(savedPlayersData); }
            } catch(e) { console.warn("Corrupt saved players data", e); this.savedPlayers = {}; }

            // Charger les joueurs r√©cents
            try {
                const recentData = localStorage.getItem('sm_recent_players');
                if(recentData) { this.recentPlayers = JSON.parse(recentData); }
            } catch(e) { console.warn("Corrupt recent players data", e); this.recentPlayers = []; }

            const game = Storage.loadCurrentGame();
            if(game) { 
                // Migration des anciennes parties
                if(!game.victoryCondition) {
                    game.victoryCondition = 'highest';
                }
                if(!game.endCondition) {
                    game.endCondition = game.mode === 'belote' ? { type: 'score', value: 1000 } : { type: 'free', value: null };
                }
                this.currentGame = game; 
                this.showGame(); 
            } else { 
                this.showSetup(); 
            }
            this.renderGamesList();
        },
        toggleTheme() {
            const root = document.documentElement;
            const currentTheme = root.getAttribute('data-theme');
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            root.setAttribute('data-theme', newTheme);
            localStorage.setItem('sm_theme', newTheme);
            this.updateThemeIcon();
            if(navigator.vibrate) navigator.vibrate(30);
        },
        updateThemeIcon() {
            const theme = document.documentElement.getAttribute('data-theme');
            const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
            const isDark = theme === 'dark' || (theme !== 'light' && prefersDark);
            document.getElementById('theme-toggle').textContent = isDark ? '‚òÄÔ∏è' : 'üåô';
        },
        updateThemeColor() {
            const theme = document.documentElement.getAttribute('data-theme');
            const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
            const isDark = theme === 'dark' || (theme !== 'light' && prefersDark);
            const metaTheme = document.querySelector('meta[name="theme-color"]');
            if(metaTheme) {
                metaTheme.setAttribute('content', isDark ? '#000000' : '#F5F5F7');
            }
        },
        showSetup() {
            UI.closeVictory();
            this.focusMode = false;
            document.getElementById('game').classList.remove('focus-mode');
            document.getElementById('dock').classList.add('hidden');
            this.currentGame = null;
            this.editIdx = null;
            document.getElementById('setup').classList.remove('hidden');
            document.getElementById('game').classList.add('hidden');
            this.renderGamesList();
        },
        showModeSelection(mode) {
            SoundFX.click();
            if(mode === 'belote') { this.createGame(mode, 2); }
            else { 
                document.getElementById('mode-setup-title').textContent = 'Mode Standard';
                document.getElementById('modal-player-count').classList.add('active'); 
                this.updateVictoryCondition();
                this.updateEndCondition();
            }
        },
        updateVictoryCondition() {
            const isLowest = document.querySelector('input[name="victory-condition"]:checked')?.value === 'lowest';
            const scoreLabel = document.getElementById('score-label-text');
            const highestLabel = document.getElementById('victory-highest-label');
            const lowestLabel = document.getElementById('victory-lowest-label');
            
            if (this.currentGame?.state) {
                this.currentGame.state.victoryCondition = isLowest ? 'lowest' : 'highest';
            }
            
            highestLabel.style.borderColor = !isLowest ? 'var(--primary)' : 'var(--border)';
            lowestLabel.style.borderColor = isLowest ? 'var(--primary)' : 'var(--border)';
            
            if(isLowest) {
                scoreLabel.textContent = '‚ö†Ô∏è Limite de d√©faite :';
            } else {
                scoreLabel.textContent = 'üéØ Score objectif :';
            }
        },
        updateEndCondition() {
            const endType = document.querySelector('input[name="end-condition"]:checked')?.value;
            const freeLabel = document.getElementById('end-free-label');
            const scoreLabel = document.getElementById('end-score-label');
            
            freeLabel.style.borderColor = endType === 'free' ? 'var(--primary)' : 'var(--border)';
            scoreLabel.style.borderColor = endType === 'score' ? 'var(--primary)' : 'var(--border)';
        },
        toggleMorePlayers() {
            const extraDiv = document.getElementById('extra-players');
            const btn = document.getElementById('btn-toggle-players');
            if (extraDiv.classList.contains('hidden')) { extraDiv.classList.remove('hidden'); btn.textContent = 'Moins ‚ñ≤'; }
            else { extraDiv.classList.add('hidden'); btn.textContent = 'Plus ‚ñº'; }
        },
        selectPlayerCount(count) {
            const victoryCondition = document.querySelector('input[name="victory-condition"]:checked')?.value || 'highest';
            const endType = document.querySelector('input[name="end-condition"]:checked')?.value || 'free';
            const scoreTarget = endType === 'score' ? parseInt(document.getElementById('score-target').value) || 100 : null;
            
            document.getElementById('modal-player-count').classList.remove('active');
            document.getElementById('extra-players').classList.add('hidden');
            document.getElementById('btn-toggle-players').textContent = 'Plus ‚ñº';
            
            this.createGame('standard', count, victoryCondition, endType, scoreTarget);
        },
        createGame(mode, playerCount, victoryCondition = 'highest', endType = 'free', scoreTarget = null) {
            this.currentGame = {
                id: Date.now().toString(),
                name: mode === 'belote' ? 'Belote' : 'Partie Standard',
                mode, 
                date: new Date().toISOString(),
                victoryCondition: mode === 'belote' ? 'highest' : victoryCondition,
                endCondition: mode === 'belote' ? { type: 'score', value: 1000 } : { type: endType, value: scoreTarget },
                state: GameState.create(mode, playerCount), 
                finished: false
            };
            // Appliquer les joueurs sauvegard√©s uniquement si le nombre correspond
            const savedKey = `${mode}_${playerCount}`;
            if(this.savedPlayers[savedKey]) {
                const saved = this.savedPlayers[savedKey];
                this.currentGame.state.players.forEach((p, idx) => {
                    if(saved[idx]) { p.name = saved[idx].name; p.color = saved[idx].color; }
                });
            }
            if(!Storage.saveGame(this.currentGame)) {
                UI.showToast('‚ö†Ô∏è Erreur de sauvegarde (M√©moire pleine)', 'error');
                return;
            }
            this.showGame();
        },
        showGame() {
            document.getElementById('setup').classList.add('hidden');
            document.getElementById('game').classList.remove('hidden');
            document.getElementById('dock').classList.remove('hidden');
            const isBelote = this.currentGame.mode === 'belote';
            document.getElementById('mode-title').textContent = isBelote ? 'BELOTE' : 'STANDARD';
            
            // Afficher les infos de la partie
            const gameInfo = document.getElementById('game-info');
            const isLowest = this.currentGame.victoryCondition === 'lowest';
            const endCond = this.currentGame.endCondition;
            let infoText = '';
            
            if(isBelote) {
                infoText = 'üéØ Premier √† 1000 pts';
            } else {
                infoText = isLowest ? '‚¨áÔ∏è Score le plus BAS' : '‚¨ÜÔ∏è Score le plus HAUT';
                if(endCond.type === 'score') {
                    infoText += isLowest ? ` ‚Ä¢ Limite ${endCond.value} pts` : ` ‚Ä¢ Objectif ${endCond.value} pts`;
                }
            }
            gameInfo.textContent = infoText;
            
            document.getElementById('calc-btn').classList.toggle('hidden', !isBelote);
            document.getElementById('btn-82').classList.toggle('hidden', !isBelote);
            document.getElementById('btn-50').classList.toggle('hidden', isBelote);
            document.getElementById('smart-btn').textContent = isBelote ? 'CAPOT' : '+/-';
            this.render();
        },
        toggleFocusMode() {
            SoundFX.click();
            this.focusMode = !this.focusMode;
            const root = document.body;

            if(this.focusMode) { 
                root.classList.add('focus-mode');
                if(navigator.vibrate) navigator.vibrate(20);
            }
            else { 
                root.classList.remove('focus-mode');
            }
        },
        showStats() { UI.showStats(); },
        render() {
            if(!this.currentGame) return;
            UI.renderScoreCards(this.currentGame.state);
            UI.renderHistory(this.currentGame.state, this.editIdx);
            UI.renderChart(this.currentGame.state, this.editIdx);
            
            // Mettre √† jour le texte du bouton avec le num√©ro de manche
            const saveBtn = document.getElementById('save-btn');
            if(saveBtn && this.editIdx === null) {
                const nextRound = this.currentGame.state.history.length + 1;
                saveBtn.textContent = `ENREGISTRER MANCHE ${nextRound}`;
            }
        },
        renderGamesList() {
            const games = Storage.loadGames();
            const list = document.getElementById('games-list');
            if(!games || games.length === 0) { list.innerHTML = '<p class="text-center" style="color:var(--text-sec); padding:20px;">Aucune partie enregistr√©e</p>'; return; }
            list.innerHTML = '';
            games.slice().reverse().forEach(game => {
                const isLowest = game.victoryCondition === 'lowest';
                const sortedPlayers = [...game.state.players].sort((a,b) => isLowest ? a.total - b.total : b.total - a.total);
                const winner = sortedPlayers[0];
                const date = new Date(game.date).toLocaleDateString('fr-FR', { day: 'numeric', month: 'short', hour: '2-digit', minute: '2-digit' });
                const modeBadge = game.mode === 'belote' ? '<span class="game-mode-badge badge-belote">üÉè BELOTE</span>' : '<span class="game-mode-badge badge-standard">üé≤ STANDARD</span>';
                const item = document.createElement('div');
                item.className = 'game-item';
                let playersScoresHtml = '';
                sortedPlayers.forEach((p, idx) => {
                    const isWinner = idx === 0;
                    playersScoresHtml += `<div class="game-player-score" style="background:${p.color}20; color:${p.color}; border: 1px solid ${p.color}40;">${isWinner ? 'üèÜ ' : ''}${p.name}: ${p.total}</div>`;
                });
                item.innerHTML = `
                    <div onclick="app.loadGame('${game.id}')" style="flex:1; cursor:pointer;">
                        <div style="font-weight:900; font-size:16px; margin-bottom:6px;">${game.name} ${game.finished ? '‚úì' : ''} ${modeBadge}</div>
                        <div style="font-size:12px; color:var(--text-sec); margin-bottom:8px;">${date} ‚Ä¢ ${game.state.history.length} manches</div>
                        <div class="game-players-list">${playersScoresHtml}</div>
                    </div>
                    <div class="game-actions"><button onclick="event.stopPropagation(); app.deleteGame('${game.id}')" title="Supprimer">üóëÔ∏è</button></div>
                `;
                list.appendChild(item);
            });
        },
        loadGame(id) {
            SoundFX.click();
            const game = Storage.loadGames().find(g => g.id === id);
            if(game) {
                // CORRECTION BUG #3 : Protection localStorage
                try {
                    const playerCount = game.state.players.length;
                    const savedKey = `${game.mode}_${playerCount}`;
                    this.savedPlayers[savedKey] = game.state.players.map(p => ({ name: p.name, color: p.color }));
                    localStorage.setItem('sm_saved_players', JSON.stringify(this.savedPlayers));
                    localStorage.setItem(Storage.CURRENT_KEY, id);
                } catch(e) {
                    if (e.name === 'QuotaExceededError') {
                        UI.showToast('‚ö†Ô∏è M√©moire pleine ! Supprimez des parties.', 'error');
                    } else {
                        console.error('localStorage error:', e);
                    }
                }
                
                this.currentGame = game;
                this.showGame();
            } else {
                UI.showToast('‚ö†Ô∏è Partie introuvable', 'error');
            }
        },
        deleteGame(gameId) {
            UI.confirm('Supprimer cette partie ?', () => {
                Storage.deleteGame(gameId);
                UI.showToast('‚úÖ Partie supprim√©e', 'success');
                this.renderGamesList();
            });
        },
        clearAll() {
            UI.confirm("‚ö†Ô∏è Supprimer TOUTES les parties ?", () => {
                localStorage.removeItem(Storage.GAMES_KEY);
                localStorage.removeItem(Storage.CURRENT_KEY);
                UI.showToast('‚úÖ Historique effac√©', 'success');
                this.renderGamesList();
            });
        },
        restartWithSamePlayers() {
            UI.closeVictory();
            if(!this.currentGame) return;
            if(!this.currentGame.finished) { this.currentGame.finished = true; Storage.saveGame(this.currentGame); }
            const oldState = this.currentGame.state;
            const newGame = {
                id: Date.now().toString(),
                name: this.currentGame.mode === 'belote' ? 'Belote' : 'Partie Standard',
                mode: this.currentGame.mode, date: new Date().toISOString(),
                victoryCondition: this.currentGame.victoryCondition || 'highest',
                endCondition: this.currentGame.endCondition || { type: 'free', value: null },
                state: { mode: oldState.mode, players: oldState.players.map(p => ({ ...p, total: 0, previousRank: null })), history: [], temp: {}, dealerId: oldState.dealerId, celebratedMilestones: {} },
                finished: false
            };
            this.currentGame = newGame;
            if(!Storage.saveGame(newGame)) {
                UI.showToast('‚ö†Ô∏è Erreur de sauvegarde (M√©moire pleine)', 'error');
                return;
            }
            UI.showToast('üéÆ Nouvelle partie lanc√©e !', 'success');
            this.render();
        },
        finishGame() {
            if(this.currentGame.state.history.length === 0) { UI.showToast('‚ö†Ô∏è Aucune manche jou√©e', 'warning'); return; }
            this.currentGame.finished = true;
            Storage.saveGame(this.currentGame);
            
            // CORRECTION BUG #3 : Protection localStorage
            try {
                const playerCount = this.currentGame.state.players.length;
                const savedKey = `${this.currentGame.mode}_${playerCount}`;
                this.savedPlayers[savedKey] = this.currentGame.state.players.map(p => ({ name: p.name, color: p.color }));
                localStorage.setItem('sm_saved_players', JSON.stringify(this.savedPlayers));
            } catch(e) {
                console.error('localStorage error:', e);
            }
            
            const isLowest = this.currentGame.victoryCondition === 'lowest';
            const winner = [...this.currentGame.state.players].sort((a,b) => isLowest ? a.total - b.total : b.total - a.total)[0];
            UI.showVictory(winner, winner.total, this.currentGame.state);
        },
        async shareRecapPNG() {
            if(!this.currentGame || !this.currentGame.finished) {
                UI.showToast("‚ö†Ô∏è Terminez d'abord la partie", 'warning');
                return;
            }
            
            SoundFX.click();
            
            try {
                // Afficher l'indicateur de chargement
                UI.showLoading('üì∏ G√©n√©ration du PNG...');
                UI.updateLoadingProgress(10, 'Analyse des donn√©es...');
                
                const gameStateWithConfig = { ...this.currentGame.state, victoryCondition: this.currentGame.victoryCondition };
                
                UI.updateLoadingProgress(30, 'Cr√©ation du visuel...');
                const canvas = await RecapGenerator.generate(gameStateWithConfig);
                
                if(!canvas) {
                    UI.hideLoading();
                    return;
                }
                
                UI.updateLoadingProgress(80, 'Pr√©paration du partage...');
                const shared = await RecapGenerator.shareImage(canvas);
                
                UI.updateLoadingProgress(100, 'Termin√© !');
                
                setTimeout(() => {
                    UI.hideLoading();
                    
                    if(!shared) {
                        RecapGenerator.downloadImage(canvas, `ScoreMaster_${new Date().toISOString().split('T')[0]}.png`);
                        UI.showToast('üì• PNG t√©l√©charg√© !', 'success');
                    } else {
                        UI.showToast('‚úÖ PNG partag√© !', 'success');
                    }
                    
                    if(navigator.vibrate) navigator.vibrate([50, 30, 50]);
                }, 300);
                
            } catch (error) {
                UI.hideLoading();
                console.error('[ScoreMaster] Erreur PNG:', error);
                UI.showToast('‚ùå Erreur PNG', 'error');
            }
        },
        debugLog(msg) {
            const debugConsole = document.getElementById('debug-console');
            const debugLogDiv = document.getElementById('debug-log');
            if (debugConsole && debugLogDiv) {
                debugConsole.style.display = 'block';
                const time = new Date().toLocaleTimeString();
                debugLogDiv.innerHTML += `<div>[${time}] ${msg}</div>`;
                debugLogDiv.scrollTop = debugLogDiv.scrollHeight;
            }
            window.console.log('[App] ' + msg);
        },
        async shareRecapGIF() {
            try {
                this.debugLog('üé¨ shareRecapGIF() appel√©');
            } catch (e) { alert('ERREUR ligne 1: ' + e.message); return; }
            
            try {
                this.debugLog('üîç V√©rif currentGame...');
                if(!this.currentGame || !this.currentGame.finished) {
                    this.debugLog('‚ùå Partie non termin√©e');
                    UI.showToast("‚ö†Ô∏è Terminez d'abord la partie", 'warning');
                    return;
                }
                this.debugLog('‚úÖ Partie termin√©e OK');
            } catch (e) { alert('ERREUR v√©rif partie: ' + e.message); return; }
            
            try {
                this.debugLog('üîç Appel SoundFX.click()...');
                SoundFX.click();
                this.debugLog('‚úÖ SoundFX OK');
            } catch (e) { alert('ERREUR SoundFX: ' + e.message); }
            
            try {
                this.debugLog('üîç V√©rification gifshot...');
                if (typeof gifshot === 'undefined') {
                    this.debugLog('‚ùå gifshot non charg√© !');
                    UI.showToast('‚ùå Biblioth√®que GIF non charg√©e', 'error');
                    alert("ERREUR: gifshot n'est pas charg√©. V√©rifiez votre connexion internet.");
                    return;
                }
                this.debugLog('‚úÖ gifshot charg√© OK');
            } catch (e) { alert('ERREUR v√©rif gifshot: ' + e.message); return; }
            
            try {
                this.debugLog('‚ùì Demande confirmation...');
                const userConfirmed = confirm('Le GIF prendra ~30 secondes √† g√©n√©rer. Continuer ?');
                if (!userConfirmed) {
                    this.debugLog('‚ùå Annul√© par utilisateur');
                    return;
                }
                this.debugLog('‚úÖ Confirmation OK');
            } catch (e) { alert('ERREUR confirmation: ' + e.message); return; }
            
            try {
                this.debugLog('üöÄ Appel RecapGifGenerator.generateAnimated()');
                // Afficher l'indicateur de chargement
                UI.showLoading('üé¨ G√©n√©ration du GIF...');
                UI.updateLoadingProgress(0, 'Initialisation...');
                
                RecapGifGenerator.generateAnimated(this.currentGame.state, (progress, message) => {
                    UI.updateLoadingProgress(progress, message);
                });
                this.debugLog('‚úÖ Appel lanc√©');
            } catch (error) {
                this.debugLog('‚ùå ERREUR generateAnimated: ' + error.message);
                this.debugLog('Stack: ' + error.stack);
                UI.hideLoading();
                UI.showToast('‚ùå Erreur: ' + error.message, 'error');
                alert('ERREUR generateAnimated:\n' + error.message + '\n\nStack:\n' + error.stack);
            }
        },
        openModal(playerId) {
            SoundFX.click();
            this.editPlayerId = playerId;
            const player = this.currentGame.state.players.find(p => p.id === playerId);
            document.getElementById('modal-title').textContent = player.name;
            document.getElementById('modal-title').style.color = player.color;
            document.getElementById('edit-name').value = player.name;
            document.getElementById('edit-dealer').checked = (this.currentGame.state.dealerId === playerId);
            this.renderRecentSuggestions(player.name);
            document.getElementById('modal-player').classList.add('active');
        },
        renderRecentSuggestions(currentName) {
            const container = document.getElementById('recent-players-suggestions');
            container.innerHTML = '';
            
            // Noms d√©j√† dans la partie
            const namesInGame = this.currentGame.state.players.map(p => p.name);
            
            // Filtrer les suggestions : pas les noms par d√©faut, pas le nom actuel, pas d√©j√† dans la partie
            const suggestions = this.recentPlayers
                .filter(name => 
                    !this.defaultNames.includes(name) && 
                    name !== currentName &&
                    !namesInGame.includes(name)
                )
                .slice(0, 5);
            
            if(suggestions.length === 0) {
                container.style.display = 'none';
                return;
            }
            
            container.style.display = 'flex';
            
            // Titre de la section
            const title = document.createElement('div');
            title.className = 'recent-suggestions-title';
            title.textContent = 'R√©cents';
            container.appendChild(title);
            
            suggestions.forEach(name => {
                const item = document.createElement('div');
                item.className = 'recent-suggestion-item';
                item.innerHTML = `<span class="add-icon">+</span><span>${name}</span>`;
                item.onclick = () => this.selectSuggestion(name);
                container.appendChild(item);
            });
        },
        selectSuggestion(name) {
            SoundFX.click();
            document.getElementById('edit-name').value = name;
            this.renderRecentSuggestions(name);
        },
        addRecentPlayer(name) {
            // Ne pas ajouter les noms par d√©faut
            if(this.defaultNames.includes(name)) return;
            
            // Retirer si d√©j√† pr√©sent, puis ajouter en premier
            this.recentPlayers = this.recentPlayers.filter(n => n !== name);
            this.recentPlayers.unshift(name);
            
            // Garder seulement les 8 derniers
            this.recentPlayers = this.recentPlayers.slice(0, 8);
            
            // Sauvegarder
            try {
                localStorage.setItem('sm_recent_players', JSON.stringify(this.recentPlayers));
            } catch(e) { console.warn('Erreur sauvegarde recentPlayers', e); }
        },
        closeModal() { document.getElementById('modal-player').classList.remove('active'); },
        savePlayer() {
            SoundFX.click();
            const player = this.currentGame.state.players.find(p => p.id === this.editPlayerId);
            let newName = document.getElementById('edit-name').value.trim().toUpperCase();
            
            // === VALIDATION DU NOM ===
            
            // V√©rifier si le nom est vide
            if (!newName || newName.length === 0) {
                UI.showToast('‚ö†Ô∏è Le nom ne peut pas √™tre vide', 'warning');
                return;
            }
            
            // Limiter la longueur du nom
            if (newName.length > 20) {
                newName = newName.substring(0, 20);
                UI.showToast('‚ö†Ô∏è Nom limit√© √† 20 caract√®res', 'warning');
            }
            
            // V√©rifier les doublons (sauf pour le joueur actuel)
            const duplicate = this.currentGame.state.players.find(p => 
                p.id !== this.editPlayerId && 
                p.name.toUpperCase() === newName
            );
            
            if (duplicate) {
                UI.showToast(`‚ö†Ô∏è "${newName}" existe d√©j√† !`, 'warning');
                return;
            }
            
            // V√©rifier les caract√®res interdits
            const forbiddenChars = /[<>\"'&]/;
            if (forbiddenChars.test(newName)) {
                newName = newName.replace(forbiddenChars, '');
                UI.showToast('‚ö†Ô∏è Caract√®res sp√©ciaux supprim√©s', 'warning');
            }
            
            // Assigner le nom valid√©
            player.name = newName;
            this.addRecentPlayer(newName);
            
            if(document.getElementById('edit-dealer').checked) { 
                this.currentGame.state.dealerId = player.id; 
            }
            
            this.closeModal();
            this.render();
            UI.showToast(`‚úÖ ${newName} mis √† jour`, 'success');
        },
        openSheet(playerId) {
            SoundFX.click();
            this.activePlayerId = playerId;
            const isBelote = this.currentGame.mode === 'belote';
            document.getElementById('calc-btn').classList.toggle('hidden', !isBelote);
            document.getElementById('btn-82').classList.toggle('hidden', !isBelote);
            document.getElementById('btn-50').classList.toggle('hidden', isBelote);
            this.renderSwitcher();
            document.getElementById('sheet').classList.add('active');
        },
        closeSheet() { document.getElementById('sheet').classList.remove('active'); this.render(); },
        renderSwitcher() {
            const cont = document.getElementById('input-switcher');
            cont.innerHTML = '';
            this.currentGame.state.players.forEach(p => {
                const isActive = p.id === this.activePlayerId;
                const tempScore = this.currentGame.state.temp[p.id] || 0;
                const div = document.createElement('div');
                div.className = `sel-box ${isActive ? 'active' : ''}`;
                if(isActive) div.style.setProperty('--p-color', p.color);
                div.onclick = () => { this.activePlayerId = p.id; this.renderSwitcher(); SoundFX.click(); };
                div.innerHTML = `<div style="font-size:10px; font-weight:800; color:${isActive ? p.color : 'var(--text-sec)'}">${p.name}</div><div style="font-size:20px; font-weight:900">${tempScore}</div>`;
                cont.appendChild(div);
            });
        },
        typeNum(n) {
            const current = (this.currentGame.state.temp[this.activePlayerId] || 0).toString();
            const newVal = parseInt((current === '0' ? '' : current) + n);
            if(newVal > 9999) { if(navigator.vibrate) navigator.vibrate([50, 50, 50]); UI.showToast('‚ö†Ô∏è Maximum 9999 points', 'warning'); return; }
            if(navigator.vibrate) navigator.vibrate(10);
            this.currentGame.state.temp[this.activePlayerId] = newVal;
            this.renderSwitcher();
            this.render();
        },
        addVal(value) {
            const current = this.currentGame.state.temp[this.activePlayerId] || 0;
            const newVal = current + value;
            if(newVal > 9999) { if(navigator.vibrate) navigator.vibrate([50, 50, 50]); UI.showToast('‚ö†Ô∏è Maximum 9999 points', 'warning'); return; }
            if(navigator.vibrate) navigator.vibrate(20);
            this.currentGame.state.temp[this.activePlayerId] = Math.max(0, newVal);
            this.renderSwitcher();
            this.render();
        },
        backspace() {
            const current = (this.currentGame.state.temp[this.activePlayerId] || 0).toString();
            this.currentGame.state.temp[this.activePlayerId] = current.length > 1 ? parseInt(current.slice(0, -1)) : 0;
            if(navigator.vibrate) navigator.vibrate(15);
            this.renderSwitcher();
            this.render();
        },
        clearInput() {
            this.currentGame.state.temp[this.activePlayerId] = 0;
            if(navigator.vibrate) navigator.vibrate([30, 50, 30]);
            this.renderSwitcher();
            this.render();
        },
        handleSmart() {
            SoundFX.click();
            if(this.currentGame.mode === 'belote') { this.currentGame.state.temp[this.activePlayerId] = 252; }
            else { const current = this.currentGame.state.temp[this.activePlayerId] || 0; this.currentGame.state.temp[this.activePlayerId] = current * -1; }
            this.renderSwitcher();
            this.render();
        },
        calcRest() {
            SoundFX.click();
            const otherPlayer = this.currentGame.state.players.find(p => p.id !== this.activePlayerId);
            if(otherPlayer) {
                const currentScore = this.currentGame.state.temp[this.activePlayerId] || 0;
                this.currentGame.state.temp[otherPlayer.id] = Math.max(0, 162 - currentScore);
                this.activePlayerId = otherPlayer.id;
                this.renderSwitcher();
                this.render();
            }
        },
        validateRound() {
            SoundFX.click();
            const state = this.currentGame.state;
            if(Object.keys(state.temp).length === 0) { UI.showToast('‚ö†Ô∏è Aucun score saisi', 'warning'); return; }
            const validation = GameState.validate(state.temp, this.currentGame.mode);
            if(!validation.valid) { UI.showToast(validation.error, 'error'); return; }
            const previousTotals = {};
            state.players.forEach(p => previousTotals[p.id] = p.total);
            
            let roundNumber;
            
            if(this.editIdx !== null) {
                roundNumber = this.editIdx + 1;
                GameState.updateRound(state, this.editIdx, state.temp);
                this.editIdx = null;
                document.getElementById('save-btn').textContent = `ENREGISTRER MANCHE ${state.history.length + 1}`;
                document.getElementById('save-btn').classList.remove('editing');
                UI.showToast(`‚úÖ Manche ${roundNumber} modifi√©e`, 'success');
            } else {
                roundNumber = state.history.length + 1;
                GameState.addRound(state, state.temp);
                
                // CORRECTION BUG #5 : Protection findIndex = -1
                const currentIdx = state.players.findIndex(p => p.id === state.dealerId);
                if (currentIdx === -1) {
                    console.warn('Dealer not found, resetting to first player');
                    state.dealerId = state.players[0].id;
                } else {
                    state.dealerId = state.players[(currentIdx + 1) % state.players.length].id;
                }
                
                UI.showToast(`‚úÖ Manche ${roundNumber} enregistr√©e`, 'success');
            }
            // Milestones uniquement en mode 'highest' (pas en mode lowest)
            if(this.currentGame.mode === 'standard' && this.currentGame.victoryCondition === 'highest') {
                state.players.forEach(p => {
                    const milestones = [200, 500, 1000];
                    milestones.forEach(milestone => {
                        const key = `${p.id}-${milestone}`;
                        if(!state.celebratedMilestones[key] && previousTotals[p.id] < milestone && p.total >= milestone) {
                            state.celebratedMilestones[key] = true;
                            setTimeout(() => UI.launchMilestoneConfetti(milestone), 300);
                        }
                    });
                });
            }
            
            // V√©rifier les conditions de fin de partie
            const endCond = this.currentGame.endCondition;
            const victCond = this.currentGame.victoryCondition;
            let gameEnded = false;
            let winner = null;
            
            if(this.currentGame.mode === 'belote') {
                winner = state.players.find(p => p.total >= 1000);
                if(winner) gameEnded = true;
            } else if(endCond.type === 'score') {
                if(victCond === 'highest') {
                    // Premier √† atteindre l'objectif gagne
                    winner = state.players.find(p => p.total >= endCond.value);
                    if(winner) gameEnded = true;
                } else {
                    // Premier √† d√©passer la limite perd, le plus petit score parmi les autres gagne
                    const overLimit = state.players.filter(p => p.total >= endCond.value);
                    if(overLimit.length > 0) {
                        gameEnded = true;
                        const remaining = state.players.filter(p => p.total < endCond.value);
                        if(remaining.length > 0) {
                            winner = remaining.sort((a,b) => a.total - b.total)[0];
                        } else {
                            // Tous ont d√©pass√©, le plus petit gagne
                            winner = [...state.players].sort((a,b) => a.total - b.total)[0];
                        }
                    }
                }
            }
            
            if(gameEnded && winner) {
                // CORRECTION BUG #3 : Protection localStorage
                try {
                    const playerCount = state.players.length;
                    const savedKey = `${this.currentGame.mode}_${playerCount}`;
                    this.savedPlayers[savedKey] = state.players.map(p => ({ name: p.name, color: p.color }));
                    localStorage.setItem('sm_saved_players', JSON.stringify(this.savedPlayers));
                } catch(e) {
                    console.error('localStorage error:', e);
                }
                
                this.currentGame.finished = true;
                // CORRECTION BUG #4 : Une seule sauvegarde ici (la double sauvegarde est enlev√©e plus bas)
                setTimeout(() => { UI.showVictory(winner, winner.total, state); }, 500);
            }
            
            // Une seule sauvegarde pour tous les cas
            if(!Storage.saveGame(this.currentGame)) {
                UI.showToast('‚ö†Ô∏è Erreur de sauvegarde (M√©moire pleine)', 'error');
            }
            state.temp = {};
            this.render();
        },
        startEdit(idx) {
            SoundFX.click();
            const state = this.currentGame.state;
            if(Object.keys(state.temp).length > 0) {
                UI.confirm('Abandonner la saisie en cours ?', () => {
                    this.editIdx = idx;
                    state.temp = {...state.history[idx]};
                    document.getElementById('save-btn').textContent = `MODIFIER MANCHE ${idx + 1}`;
                    document.getElementById('save-btn').classList.add('editing');
                    this.openSheet(state.players[0].id);
                });
                return;
            }
            this.editIdx = idx;
            state.temp = {...state.history[idx]};
            document.getElementById('save-btn').textContent = `MODIFIER MANCHE ${idx + 1}`;
            document.getElementById('save-btn').classList.add('editing');
            this.openSheet(state.players[0].id);
        },
        delRound(idx) {
            UI.confirm('Supprimer cette manche ?', () => {
                GameState.deleteRound(this.currentGame.state, idx);
                
                // CORRECTION BUG #1 : Reset editIdx si n√©cessaire
                if (this.editIdx !== null) {
                    if (this.editIdx === idx) {
                        // On supprime la manche en cours d'√©dition
                        this.editIdx = null;
                        this.currentGame.state.temp = {};
                        document.getElementById('save-btn').textContent = `ENREGISTRER MANCHE ${this.currentGame.state.history.length + 1}`;
                        document.getElementById('save-btn').classList.remove('editing');
                    } else if (this.editIdx > idx) {
                        // La manche √©dit√©e est apr√®s celle supprim√©e, d√©caler l'index
                        this.editIdx--;
                    }
                }
                
                // Sauvegarder apr√®s suppression
                Storage.saveGame(this.currentGame);
                UI.showToast('‚úÖ Manche supprim√©e', 'success');
                this.render();
            });
        },
        undo() {
            const history = this.currentGame.state.history;
            if(history.length > 0) {
                // Undo direct sans confirmation pour une action plus fluide
                GameState.deleteRound(this.currentGame.state, history.length - 1);
                this.lastRanks = {}; // Reset les ranks pour √©viter les animations incorrectes
                Storage.saveGame(this.currentGame);
                UI.showToast('‚Ü©Ô∏è Manche annul√©e', 'success');
                this.render();
            }
        }
    };
    
    // ==================== PWA MANAGER ====================
    const PWA = {
        deferredPrompt: null,
        isInstalled: false,
        
        init() {
            this.checkIfInstalled();
            this.registerServiceWorker();
            this.setupInstallPrompt();
            this.setupUpdateNotification();
            this.addInstallButton();
        },
        
        checkIfInstalled() {
            // V√©rifier si l'app est install√©e
            if (window.matchMedia('(display-mode: standalone)').matches || window.navigator.standalone === true) {
                this.isInstalled = true;
                console.log('[PWA] App install√©e');
            }
        },
        
        async registerServiceWorker() {
            if ('serviceWorker' in navigator) {
                try {
                    const registration = await navigator.serviceWorker.register('./service-worker.js');
                    console.log('[PWA] Service Worker enregistr√©:', registration.scope);
                    
                    // V√©rifier les mises √† jour
                    registration.addEventListener('updatefound', () => {
                        console.log('[PWA] Mise √† jour trouv√©e');
                        const newWorker = registration.installing;
                        newWorker.addEventListener('statechange', () => {
                            if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                                this.showUpdateNotification();
                            }
                        });
                    });
                } catch (error) {
                    console.error('[PWA] Erreur Service Worker:', error);
                }
            }
        },
        
        setupInstallPrompt() {
            window.addEventListener('beforeinstallprompt', (e) => {
                e.preventDefault();
                this.deferredPrompt = e;
                console.log('[PWA] Installation disponible');
                this.showInstallButton();
            });
            
            window.addEventListener('appinstalled', () => {
                console.log('[PWA] App install√©e avec succ√®s');
                this.isInstalled = true;
                this.hideInstallButton();
                UI.showToast('‚úÖ ScoreMaster install√© !', 'success');
            });
        },
        
        async installApp() {
            if (!this.deferredPrompt) {
                console.log('[PWA] Pas de prompt disponible');
                return;
            }
            
            this.deferredPrompt.prompt();
            const { outcome } = await this.deferredPrompt.userChoice;
            console.log('[PWA] Installation:', outcome);
            
            if (outcome === 'accepted') {
                SoundFX.success();
            }
            
            this.deferredPrompt = null;
            this.hideInstallButton();
        },
        
        addInstallButton() {
            // Cr√©er le bouton d'installation si pas encore install√©
            if (!this.isInstalled) {
                const setupContainer = document.getElementById('setup');
                if (setupContainer) {
                    const installBanner = document.createElement('div');
                    installBanner.id = 'install-banner';
                    installBanner.style.cssText = `
                        background: linear-gradient(135deg, var(--primary), #0051D5);
                        color: white;
                        padding: 15px 20px;
                        border-radius: 16px;
                        margin: 20px 0;
                        display: none;
                        align-items: center;
                        gap: 15px;
                        box-shadow: 0 8px 20px rgba(0,122,255,0.3);
                        cursor: pointer;
                        transition: transform 0.2s;
                    `;
                    installBanner.innerHTML = `
                        <div style="font-size: 32px;">üì±</div>
                        <div style="flex: 1;">
                            <div style="font-weight: 900; font-size: 16px; margin-bottom: 3px;">Installer ScoreMaster</div>
                            <div style="font-size: 12px; opacity: 0.9;">Acc√©dez rapidement depuis votre √©cran d'accueil</div>
                        </div>
                        <div style="font-size: 24px;">‚Üí</div>
                    `;
                    installBanner.onclick = () => this.installApp();
                    
                    const firstChild = setupContainer.querySelector('.header-controls');
                    if (firstChild && firstChild.nextSibling) {
                        setupContainer.insertBefore(installBanner, firstChild.nextSibling);
                    }
                }
            }
        },
        
        showInstallButton() {
            const banner = document.getElementById('install-banner');
            if (banner) {
                banner.style.display = 'flex';
                setTimeout(() => {
                    banner.style.animation = 'slideIn 0.4s ease-out';
                }, 100);
            }
        },
        
        hideInstallButton() {
            const banner = document.getElementById('install-banner');
            if (banner) {
                banner.style.display = 'none';
            }
        },
        
        setupUpdateNotification() {
            // √âcouter les messages du Service Worker
            navigator.serviceWorker?.addEventListener('message', (event) => {
                if (event.data.type === 'UPDATE_AVAILABLE') {
                    this.showUpdateNotification();
                }
            });
        },
        
        showUpdateNotification() {
            const updateBanner = document.createElement('div');
            updateBanner.style.cssText = `
                position: fixed;
                top: max(20px, env(safe-area-inset-top));
                left: 50%;
                transform: translateX(-50%);
                background: var(--card);
                border: 2px solid var(--primary);
                padding: 12px 20px;
                border-radius: 16px;
                box-shadow: 0 8px 20px rgba(0,0,0,0.2);
                z-index: 9999;
                display: flex;
                align-items: center;
                gap: 12px;
                max-width: 90%;
                animation: slideIn 0.4s ease-out;
            `;
            updateBanner.innerHTML = `
                <div style="font-size: 20px;">üÜï</div>
                <div style="flex: 1;">
                    <div style="font-weight: 700; font-size: 14px; color: var(--text);">Mise √† jour disponible</div>
                    <div style="font-size: 12px; color: var(--text-sec);">Rechargez pour la derni√®re version</div>
                </div>
                <button onclick="location.reload()" style="background: var(--primary); color: white; border: none; padding: 8px 16px; border-radius: 8px; font-weight: 700; font-size: 12px; cursor: pointer;">
                    RECHARGER
                </button>
            `;
            document.body.appendChild(updateBanner);
            
            // Auto-hide apr√®s 10 secondes
            setTimeout(() => {
                updateBanner.style.opacity = '0';
                updateBanner.style.transition = 'opacity 0.3s';
                setTimeout(() => updateBanner.remove(), 300);
            }, 10000);
        }
    };
    







    // ==================== RECAP GENERATOR V4.0 STABLE ====================
    // OPTIMISATIONS MAJEURES :
    // - Un seul rendu au lieu de deux (performance √ó2)
    // - Une seule boucle sur l'historique (optimisation)
    // - Map pour les joueurs (pas de find() r√©p√©t√©)
    // - Fonctions de mesure s√©par√©es (architecture propre)
    // - Gestion d'erreur compl√®te (try/catch)
    // - Citations raccourcies (pas de d√©passement)
    
    const RecapGenerator = {
        SPACING: {
            AFTER_BANNER: 40,           
            BEFORE_CHAMPION: 40,        
            AFTER_CHAMPION: 20,         
            SECTION_HEADER: 15,
            BETWEEN_SECTIONS: 30,
            SECTION_PADDING: 25,
            ITEM_SPACING: 20
        },
        
        GENRE_COLORS: {
            DOMINATION: { primary: '#8B0000', secondary: '#FFD700', accent: '#FF4500', bg: 'rgba(139, 0, 0, 0.1)' },
            THRILLER: { primary: '#FF6B35', secondary: '#F7931E', accent: '#FDC830', bg: 'rgba(255, 107, 53, 0.1)' },
            CHAOS: { primary: '#6A0572', secondary: '#AB47BC', accent: '#E91E63', bg: 'rgba(106, 5, 114, 0.1)' },
            COMEBACK: { primary: '#2B5AA0', secondary: '#5B9BD5', accent: '#1E88E5', bg: 'rgba(43, 90, 160, 0.1)' }
        },
        
        StoryBrain: {
            analyze(history, players, victoryCondition = 'highest') {
                const totals = {};
                players.forEach((p, i) => totals[i] = 0);
                const leaders = [];
                const curves = players.map(() => []);
                const isLowest = victoryCondition === 'lowest';
                
                history.forEach(r => {
                    players.forEach((p, i) => {
                        totals[i] += r[p.id] || 0;
                        curves[i].push(totals[i]);
                    });
                    // Tri selon victoryCondition
                    const sorted = players.map((p, i) => ({ i, t: totals[i] })).sort((a, b) => {
                        return isLowest ? a.t - b.t : b.t - a.t;
                    });
                    leaders.push(sorted[0].i);
                });
                
                let changes = 0;
                for (let i = 1; i < leaders.length; i++) {
                    if (leaders[i] != leaders[i - 1]) changes++;
                }
                
                const last = leaders[leaders.length - 1];
                const first = leaders[0];
                const finals = curves.map(c => c[c.length - 1]);
                // Tri final selon victoryCondition
                const sortedF = finals.map((t, i) => ({ i, t })).sort((a, b) => {
                    return isLowest ? a.t - b.t : b.t - a.t;
                });
                // CORRECTION BUG #2 : Protection contre 1 seul joueur
                const gap = sortedF.length > 1 ? Math.abs(sortedF[0].t - sortedF[1].t) : 0;
                
                let genre;
                if (changes >= 3) genre = "CHAOS";
                else if (first !== last) genre = "COMEBACK";
                else if (gap <= 100) genre = "THRILLER";
                else genre = "DOMINATION";
                
                return { genre, winner: players[last].name, winnerIdx: last, first: players[first].name, changes, gap, curves };
            }
        },
        
        PlayerCasting: {
            analyze(history, players, victoryCondition = 'highest') {
                const isLowest = victoryCondition === 'lowest';
                const stats = players.map(p => ({ name: p.name, color: p.color, total: 0, best: -999, worst: 999, wins: 0 }));
                
                history.forEach(r => {
                    const scores = players.map((p, i) => ({ i, score: r[p.id] || 0 }));
                    // En mode lowest, chercher le min, sinon le max
                    const winningScore = isLowest 
                        ? Math.min(...scores.map(s => s.score))
                        : Math.max(...scores.map(s => s.score));
                    
                    players.forEach((p, i) => {
                        const score = r[p.id] || 0;
                        stats[i].total += score;
                        stats[i].best = Math.max(stats[i].best, score);
                        stats[i].worst = Math.min(stats[i].worst, score);
                        // Compter les victoires selon le bon crit√®re
                        if (score === winningScore && (isLowest ? score >= 0 : score > 0)) {
                            stats[i].wins++;
                        }
                    });
                });
                
                // Trier selon victoryCondition
                const sorted = [...stats].sort((a, b) => {
                    return isLowest ? a.total - b.total : b.total - a.total;
                });
                
                const precision = sorted.map(s => ({
                    name: s.name,
                    value: history.length > 0 ? Math.round((s.wins / history.length) * 100) : 0
                }));
                
                return { hero: sorted[0].name, boulet: sorted[sorted.length - 1].name, stats: sorted, precision };
            }
        },
        
        NarrativeEngine: {
            pick: a => a[Math.floor(Math.random() * a.length)],
            templates: {
                DOMINATION: [
                    "Une bataille jusqu'√† la derni√®re manche. {b} a confondu strat√©gie et catastrophe.",
                    "Match √† sens unique du d√©but √† la fin. {b} n'a jamais exist√© dans cette partie.",
                    "Performance de tr√®s haut niveau. {b} devrait peut-√™tre changer de jeu.",
                    "D√©monstration absolue. {b} a √©t√© balay√© comme un f√©tu de paille.",
                    "Aucune piti√©, aucune chance. {b} a subi de bout en bout."
                ],
                THRILLER: [
                    "Une fin irrespirable. {b} a offert un grand moment de solitude.",
                    "Chaque point comptait. {b} s'est effondr√© au mauvais moment.",
                    "Un match de folie. {b} a craqu√© sous la pression.",
                    "Suspense insoutenable. {b} n'a pas tenu la distance.",
                    "Combat acharn√©. {b} a abandonn√© trop t√¥t."
                ],
                CHAOS: [
                    "Un chaos total du d√©but √† la fin. {b} a jou√© comme un pied.",
                    "Rebondissements √† chaque manche. {b} n'a rien compris au jeu.",
                    "Un joyeux bordel indescriptible. {b} s'est perdu en route.",
                    "Sc√©nario compl√®tement fou. {b} a fait n'importe quoi.",
                    "Impr√©visible de bout en bout. {b} a coul√© tout seul."
                ],
                COMEBACK: [
                    "Incroyable remont√©e. {b} devrait envisager un autre jeu.",
                    "Retour spectaculaire. {b} s'est fait avoir comme un bleu.",
                    "Renversement de situation. {b} pensait avoir gagn√©, quelle erreur.",
                    "Comeback l√©gendaire. {b} a vu la victoire lui √©chapper.",
                    "Remontada inoubliable. {b} va ruminer cette d√©faite longtemps."
                ]
            },
            reactions: {
                winner: [
                    "Trop facile",
                    "J'ai gagn√© facile",
                    "Pas transpir√©",
                    "Jou√© √† 50%",
                    "Merci l'entra√Ænement",
                    "Une vraie partie ?",
                    "Attendais mieux",
                    "Presque dormi"
                ],
                loser: [
                    "Pas de chance",
                    "Il/elle a trich√©",
                    "Cartes pourries",
                    "Pas concentr√©",
                    "Prochaine fois",
                    "Chance pure",
                    "Mauvais tirage",
                    "Mauvaises cartes !"
                ]
            },
            build(brain, cast) {
                return this.pick(this.templates[brain.genre]).replace("{b}", cast.boulet);
            },
            getWinnerQuote() {
                return this.pick(this.reactions.winner);
            },
            getLoserQuote() {
                return this.pick(this.reactions.loser);
            }
        },
        
        async generate(gameState) {
            try {
                UI.showToast('üé® G√©n√©ration r√©cap V4.0...', 'info');
                
                const canvas = document.createElement('canvas');
                canvas.width = 1080;
                
                // Analyse des donn√©es (UNE SEULE FOIS)
                const ai = this.analyzeGameData(gameState);
                
                // Calcul de la hauteur (SANS dessiner)
                const ctx = canvas.getContext('2d');
                const height = this.calculateTotalHeight(ctx, ai, gameState);
                canvas.height = height;
                
                // Dessin (UNE SEULE FOIS)
                this.draw(ctx, ai, gameState);
                
                UI.showToast('‚úÖ R√©cap V4.0 g√©n√©r√© !', 'success');
                return canvas;
                
            } catch(error) {
                console.error('[RecapGenerator V4.0] Erreur:', error);
                UI.showToast('‚ùå Erreur g√©n√©ration: ' + error.message, 'error');
                return null;
            }
        },
        
        // Analyse optimis√©e : UNE SEULE passe sur l'historique
        analyzeGameData(gameState) {
            const victoryCondition = gameState.victoryCondition || 'highest';
            const brain = this.StoryBrain.analyze(gameState.history, gameState.players, victoryCondition);
            const cast = this.PlayerCasting.analyze(gameState.history, gameState.players, victoryCondition);
            const narrative = this.NarrativeEngine.build(brain, cast);
            
            // Map des joueurs pour √©viter find() r√©p√©t√©
            const playerMap = new Map(gameState.players.map(p => [p.id.toString(), p]));
            
            let bestRound = { player: null, score: -999, round: 0 };
            let worstRound = { player: null, score: 999, round: 0 };
            let secondBestRound = { player: null, score: -999, round: 0 };
            
            // Initialiser les streaks
            const streaks = new Map();
            gameState.players.forEach(p => {
                streaks.set(p.id, { current: 0, max: 0 });
            });
            
            const isLowest = victoryCondition === 'lowest';
            
            // UNE SEULE BOUCLE pour tout calculer
            gameState.history.forEach((round, idx) => {
                const roundScores = Object.entries(round).map(([id, score]) => ({
                    id: parseInt(id),
                    score
                }));
                
                // Trouver le gagnant de la manche selon victoryCondition
                const winningScore = isLowest
                    ? Math.min(...roundScores.map(s => s.score))
                    : Math.max(...roundScores.map(s => s.score));
                const winner = roundScores.find(s => s.score === winningScore);
                
                // Mettre √† jour les streaks
                roundScores.forEach(({ id, score }) => {
                    const streak = streaks.get(id);
                    if (id === winner.id && (isLowest ? score >= 0 : score > 0)) {
                        streak.current++;
                        streak.max = Math.max(streak.max, streak.current);
                    } else {
                        streak.current = 0;
                    }
                    
                    // Mettre √† jour best/worst
                    const player = playerMap.get(id.toString());
                    if (player) {
                        if (score > bestRound.score) {
                            secondBestRound = {...bestRound};
                            bestRound = { player: player.name, score, round: idx + 1 };
                        } else if (score > secondBestRound.score && score !== bestRound.score) {
                            secondBestRound = { player: player.name, score, round: idx + 1 };
                        }
                        if (score < worstRound.score) {
                            worstRound = { player: player.name, score, round: idx + 1 };
                        }
                    }
                });
            });
            
            // Trouver le meilleur streak
            let bestStreak = { player: null, count: 0 };
            streaks.forEach((streak, playerId) => {
                if (streak.max > bestStreak.count) {
                    const player = gameState.players.find(p => p.id === playerId);
                    bestStreak = { player: player.name, count: streak.max };
                }
            });
            
            // Trier selon victoryCondition pour calculer l'√©cart
            const sorted = [...gameState.players].sort((a,b) => {
                return isLowest ? a.total - b.total : b.total - a.total;
            });
            // CORRECTION BUG #2 : Protection contre 1 seul joueur
            const finalGap = sorted.length > 1 ? Math.abs(sorted[0].total - sorted[1].total) : sorted[0].total;
            
            return {
                brain,
                cast,
                narrative,
                bestRound,
                secondBestRound,
                worstRound,
                bestStreak,
                finalGap
            };
        },
        
        // Calculer la hauteur totale SANS dessiner
        calculateTotalHeight(ctx, ai, gameState) {
            const width = 1080;
            const sp = this.SPACING;
            let y = 50;
            
            // Bandeau
            y += 4 + 130 + 4 + 140 + 35;
            y += sp.AFTER_BANNER;
            
            // Confetti
            y += 20;
            y += sp.BEFORE_CHAMPION;
            
            // Champion
            y += 100;
            y += sp.AFTER_CHAMPION;
            
            // Titre
            y += 65;
            
            // Narratif (estimation)
            const words = ai.narrative.split(' ');
            const estimatedLines = Math.ceil(words.length / 10);
            y += estimatedLines * 30 + 35;
            
            // Ligne
            y += 30;
            
            // Graphique
            y += 360;
            
            // Double ligne
            y += 40;
            
            const leftCol = 55;
            const colWidth = 465;
            const rightCol = leftCol + colWidth + 30;
            
            // Podium (fixe)
            const podiumHeight = 45 + sp.SECTION_HEADER + 320;
            
            // R√©actions (mesurer)
            const { height: reactionsHeight } = this.measureReactionsContent(ctx, colWidth, ai);
            const reactionsTotal = 45 + sp.SECTION_HEADER + reactionsHeight;
            
            const yLeft = podiumHeight + sp.BETWEEN_SECTIONS + reactionsTotal;
            
            // Temps forts (mesurer)
            const { height: tempsFortsHeight } = this.measureTempsFortsContent(ctx, colWidth, ai, gameState);
            const tempsFortsTotal = 45 + sp.SECTION_HEADER + tempsFortsHeight;
            
            // Stats (mesurer)
            const { height: statsHeight } = this.measureStatsContent(ctx, colWidth, ai, gameState);
            const statsTotal = 45 + sp.SECTION_HEADER + statsHeight;
            
            const yRight = tempsFortsTotal + sp.BETWEEN_SECTIONS + statsTotal;
            
            const finalY = y + Math.max(yLeft, yRight) + 60;
            
            return finalY + 80;
        },
        
        // Mesurer les r√©actions
        measureReactionsContent(ctx, w, ai) {
            const sp = this.SPACING;
            
            const winnerQuote = this.NarrativeEngine.getWinnerQuote();
            const loserQuote = this.NarrativeEngine.getLoserQuote();
            
            ctx.font = 'italic 17px Georgia';
            const winnerLines = this.wrapText(ctx, `"${winnerQuote}"`, w - 40);
            const loserLines = this.wrapText(ctx, `"${loserQuote}"`, w - 40);
            
            let height = sp.SECTION_PADDING;
            height += 24;  // Titre gagnant
            height += winnerLines.length * 22 + 20;
            height += 20;  // S√©parateur
            height += 24;  // Titre perdant
            height += loserLines.length * 22 + sp.SECTION_PADDING;
            
            return { height, winnerLines, loserLines, winnerQuote, loserQuote };
        },
        
        // Mesurer les temps forts
        measureTempsFortsContent(ctx, w, ai, gameState) {
            const sp = this.SPACING;
            
            ctx.font = '18px Arial';
            const feuLines = this.wrapText(ctx, `${ai.bestRound.player} a explos√©`, w - 40);
            ctx.font = 'bold 20px Arial';
            const mancheLines = this.wrapText(ctx, `‚ñ∂ ${ai.bestRound.score} pts (M${ai.bestRound.round})`, w - 40);
            
            let dramaLines = [], dramaScoreLines = [];
            let exploitLines = [], exploitScoreLines = [];
            let serieLines = [], autoLines = [];
            let manchesLines = [];
            
            if (ai.worstRound.score < 0) {
                ctx.font = '18px Arial';
                dramaLines = this.wrapText(ctx, `${ai.worstRound.player} catastrophique`, w - 40);
                ctx.font = 'bold 20px Arial';
                dramaScoreLines = this.wrapText(ctx, `‚ñ∂ ${ai.worstRound.score} pts (M${ai.worstRound.round})`, w - 40);
            } else {
                ctx.font = '18px Arial';
                exploitLines = this.wrapText(ctx, `${ai.secondBestRound.player} en feu`, w - 40);
                ctx.font = 'bold 20px Arial';
                exploitScoreLines = this.wrapText(ctx, `‚ñ∂ ${ai.secondBestRound.score} pts (M${ai.secondBestRound.round})`, w - 40);
            }
            
            if (ai.bestStreak.count > 1) {
                ctx.font = '18px Arial';
                serieLines = this.wrapText(ctx, `${ai.bestStreak.player} : ${ai.bestStreak.count} victoires`, w - 40);
                ctx.font = 'bold 20px Arial';
                autoLines = this.wrapText(ctx, '‚ñ∂ Mode auto', w - 40);
            } else {
                ctx.font = 'bold 20px Arial';
                manchesLines = this.wrapText(ctx, `‚ñ∂ ${gameState.history.length} manches`, w - 40);
            }
            
            let height = sp.SECTION_PADDING;
            height += 24 + feuLines.length * 20 + 4 + mancheLines.length * 20 + sp.ITEM_SPACING;
            height += sp.ITEM_SPACING;
            
            if (ai.worstRound.score < 0) {
                height += 24 + dramaLines.length * 20 + 4 + dramaScoreLines.length * 20 + sp.ITEM_SPACING;
            } else {
                height += 24 + exploitLines.length * 20 + 4 + exploitScoreLines.length * 20 + sp.ITEM_SPACING;
            }
            
            height += sp.ITEM_SPACING;
            
            if (ai.bestStreak.count > 1) {
                height += 24 + serieLines.length * 20 + 4 + autoLines.length * 20 + sp.SECTION_PADDING;
            } else {
                height += 24 + 24 + manchesLines.length * 20 + sp.SECTION_PADDING;
            }
            
            return {
                height,
                feuLines, mancheLines,
                dramaLines, dramaScoreLines,
                exploitLines, exploitScoreLines,
                serieLines, autoLines,
                manchesLines
            };
        },
        
        async draw(ctx, ai, gameState) {
            const width = 1080;
            const colors = this.GENRE_COLORS[ai.brain.genre];
            const sp = this.SPACING;
            
            ctx.fillStyle = '#F5F1E8';
            ctx.fillRect(0, 0, width, ctx.canvas.height);
            
            ctx.fillStyle = 'rgba(139, 119, 101, 0.03)';
            for (let i = 0; i < 5000; i++) {
                ctx.fillRect(Math.random() * width, Math.random() * ctx.canvas.height, 1, 1);
            }
            
            this.drawFoldedPaper(ctx, width, ctx.canvas.height);
            
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 4;
            
            let y = 50;
            
            y = this.drawBanner3D(ctx, y, width, colors);
            y += sp.AFTER_BANNER;
            
            y = this.drawConfetti(ctx, width / 2, y + 20, 30);
            y += sp.BEFORE_CHAMPION;
            
            y = this.drawChampionBlock(ctx, y, width, ai.brain.winner, gameState.players.find(p => p.name === ai.brain.winner).total, colors);
            y += sp.AFTER_CHAMPION;
            
            ctx.font = 'italic 900 48px Arial';
            ctx.fillStyle = colors.primary;
            ctx.textAlign = 'center';
            ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
            ctx.shadowBlur = 4;
            ctx.shadowOffsetY = 2;
            ctx.fillText('√âCRASE LA CONCURRENCE', width / 2, y);
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            ctx.shadowOffsetY = 0;
            y += 65;
            
            ctx.font = 'italic 700 22px Georgia';
            ctx.fillStyle = '#1A1A1A';
            const words = ai.narrative.split(' ');
            let lines = [];
            let line = '';
            words.forEach(word => {
                const test = line + word + ' ';
                const m = ctx.measureText(test);
                if (m.width > width - 140) {
                    if (line) lines.push(line.trim());
                    line = word + ' ';
                } else {
                    line = test;
                }
            });
            if (line) lines.push(line.trim());
            lines.forEach((l, idx) => {
                ctx.fillText(l, width / 2, y + (idx * 30));
            });
            y += lines.length * 30 + 35;
            
            ctx.fillStyle = '#000000';
            ctx.fillRect(55, y, width - 110, 3);
            y += 30;
            
            y = this.drawGraphWithZones(ctx, 55, y, width - 110, ai, gameState, colors);
            y += 30;
            
            ctx.fillStyle = '#000000';
            ctx.fillRect(55, y, width - 110, 2);
            ctx.fillRect(55, y + 5, width - 110, 2);
            y += 40;
            
            const leftCol = 55;
            const colWidth = 465;
            const rightCol = leftCol + colWidth + 30;
            
            let yLeft = y;
            let yRight = y;
            
            yLeft = this.drawPodium3DImproved(ctx, leftCol, yLeft, colWidth, gameState.players, colors, gameState.victoryCondition);
            yLeft += sp.BETWEEN_SECTIONS;
            yLeft = this.drawReactionsClean(ctx, leftCol, yLeft, colWidth, ai, colors);
            
            yRight = this.drawTempsFortsClean(ctx, rightCol, yRight, colWidth, ai, colors, gameState);
            yRight += sp.BETWEEN_SECTIONS;
            yRight = this.drawStatsClean(ctx, rightCol, yRight, colWidth, ai, gameState, colors);
            
            const finalY = Math.max(yLeft, yRight) + 60;
            
            ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
            ctx.shadowBlur = 5;
            ctx.shadowOffsetY = 2;
            ctx.font = 'bold 26px Arial';
            ctx.fillStyle = colors.primary;
            ctx.textAlign = 'center';
            ctx.fillText('ScoreMaster Sports‚Ñ¢', width / 2, finalY);
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            ctx.shadowOffsetY = 0;
            
            ctx.font = 'italic 20px Georgia';
            ctx.fillStyle = '#666';
            ctx.fillText('"On immortalise vos d√©faites depuis 2026"', width / 2, finalY + 35);
            
            const totalHeight = finalY + 80;
            
            ctx.strokeRect(25, 25, width - 50, totalHeight - 50);
        },
        
        drawFoldedPaper(ctx, width, height) {
            const foldX = width / 2;
            const foldGradient = ctx.createLinearGradient(foldX - 3, 0, foldX + 3, 0);
            foldGradient.addColorStop(0, 'rgba(0, 0, 0, 0)');
            foldGradient.addColorStop(0.5, 'rgba(0, 0, 0, 0.05)');
            foldGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = foldGradient;
            ctx.fillRect(foldX - 3, 0, 6, height);
            
            for (let i = 0; i < 15; i++) {
                const x = Math.random() * width;
                const y = Math.random() * height;
                const w = Math.random() * 100 + 50;
                const angle = Math.random() * Math.PI / 6;
                
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(angle);
                ctx.fillStyle = 'rgba(0, 0, 0, 0.015)';
                ctx.fillRect(0, 0, w, 1);
                ctx.restore();
            }
        },
        
        drawBanner3D(ctx, y, width, colors) {
            ctx.fillStyle = '#000000';
            ctx.fillRect(55, y, width - 110, 4);
            y += 4;
            
            const gradient = ctx.createLinearGradient(0, y, 0, y + 130);
            gradient.addColorStop(0, colors.primary);
            gradient.addColorStop(0.5, colors.primary + 'DD');
            gradient.addColorStop(1, colors.primary + 'BB');
            ctx.fillStyle = gradient;
            
            ctx.shadowColor = 'rgba(0, 0, 0, 0.4)';
            ctx.shadowBlur = 15;
            ctx.shadowOffsetY = 8;
            ctx.fillRect(55, y, width - 110, 130);
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            ctx.shadowOffsetY = 0;
            
            ctx.fillStyle = '#000000';
            ctx.fillRect(55, y + 130, width - 110, 4);
            
            ctx.font = 'italic 900 95px Georgia';
            ctx.textAlign = 'center';
            
            ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
            ctx.shadowBlur = 3;
            ctx.shadowOffsetX = 6;
            ctx.shadowOffsetY = 6;
            ctx.fillStyle = '#000000';
            ctx.fillText('LE SCORE', width / 2, y + 87);
            
            ctx.shadowColor = 'rgba(255, 255, 255, 0.3)';
            ctx.shadowBlur = 5;
            ctx.shadowOffsetX = -2;
            ctx.shadowOffsetY = -2;
            ctx.fillStyle = '#FFFFFF';
            ctx.fillText('LE SCORE', width / 2, y + 85);
            
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
            
            y += 140;
            y += 35;
            
            ctx.font = 'bold 21px Arial';
            ctx.fillStyle = '#000000';
            const date = new Date().toLocaleDateString('fr-FR', {
                weekday: 'long',
                day: 'numeric',
                month: 'long',
                year: 'numeric'
            });
            ctx.fillText(`√âDITION SP√âCIALE ‚Äî ${date.toUpperCase()}`, width / 2, y);
            
            return y;
        },
        
        drawConfetti(ctx, cx, cy, count) {
            const confettiColors = ['#FF6B35', '#F7931E', '#FDC830', '#4CAF50', '#2196F3', '#9C27B0'];
            for (let i = 0; i < count; i++) {
                const x = cx + Math.random() * 300 - 150;
                const y = cy + Math.random() * 80 - 40;
                const size = Math.random() * 8 + 4;
                const rotation = Math.random() * Math.PI * 2;
                
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation);
                ctx.fillStyle = confettiColors[Math.floor(Math.random() * confettiColors.length)];
                ctx.globalAlpha = 0.7;
                ctx.fillRect(-size/2, -size/2, size, size);
                ctx.globalAlpha = 1;
                ctx.restore();
            }
            return cy;
        },
        
        drawChampionBlock(ctx, y, width, name, score, colors) {
            const blockWidth = 450;
            const blockHeight = 100;
            const x = (width - blockWidth) / 2;
            
            const gradient = ctx.createLinearGradient(x, y, x, y + blockHeight);
            gradient.addColorStop(0, colors.secondary);
            gradient.addColorStop(0.5, colors.accent);
            gradient.addColorStop(1, colors.secondary);
            ctx.fillStyle = gradient;
            
            ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
            ctx.shadowBlur = 20;
            ctx.shadowOffsetY = 10;
            ctx.fillRect(x, y, blockWidth, blockHeight);
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            ctx.shadowOffsetY = 0;
            
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 4;
            ctx.strokeRect(x, y, blockWidth, blockHeight);
            
            ctx.font = 'bold 50px Arial';
            ctx.fillStyle = '#000';
            ctx.textAlign = 'center';
            ctx.shadowColor = 'rgba(255, 255, 255, 0.5)';
            ctx.shadowBlur = 3;
            ctx.fillText(`üèÜ ${name.toUpperCase()} üèÜ`, width / 2, y + 45);
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            
            ctx.font = 'bold 32px Arial';
            ctx.fillText(`${score} pts`, width / 2, y + 80);
            
            return y + blockHeight;
        },
        
        drawGraphWithZones(ctx, x, y, w, ai, gameState, colors) {
            const h = 340;
            const padding = 50;
            
            ctx.fillStyle = '#FFFFFF';
            ctx.shadowColor = 'rgba(0, 0, 0, 0.15)';
            ctx.shadowBlur = 15;
            ctx.shadowOffsetY = 5;
            ctx.fillRect(x, y, w, h);
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            ctx.shadowOffsetY = 0;
            
            ctx.strokeStyle = '#CCCCCC';
            ctx.lineWidth = 2;
            ctx.strokeRect(x, y, w, h);
            
            ctx.font = 'bold 26px Arial';
            ctx.fillStyle = colors.primary;
            ctx.textAlign = 'center';
            ctx.fillText('üìà √âVOLUTION DES SCORES', x + w / 2, y + 30);
            
            const gx = x + padding;
            const gy = y + 60;
            const gw = w - padding * 2;
            const gh = h - 110;
            
            const curves = ai.brain.curves;
            const maxScore = Math.max(...curves.flat());
            const minScore = Math.min(...curves.flat(), 0);
            const nbRounds = gameState.history.length;
            
            const winGradient = ctx.createLinearGradient(0, gy, 0, gy + gh/3);
            winGradient.addColorStop(0, 'rgba(76, 175, 80, 0.15)');
            winGradient.addColorStop(1, 'rgba(76, 175, 80, 0)');
            ctx.fillStyle = winGradient;
            ctx.fillRect(gx, gy, gw, gh/3);
            
            const loseGradient = ctx.createLinearGradient(0, gy + 2*gh/3, 0, gy + gh);
            loseGradient.addColorStop(0, 'rgba(244, 67, 54, 0)');
            loseGradient.addColorStop(1, 'rgba(244, 67, 54, 0.15)');
            ctx.fillStyle = loseGradient;
            ctx.fillRect(gx, gy + 2*gh/3, gw, gh/3);
            
            const avgScore = (maxScore + minScore) / 2;
            const avgY = gy + gh - ((avgScore - minScore) / (maxScore - minScore || 1)) * gh;
            ctx.strokeStyle = '#999';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(gx, avgY);
            ctx.lineTo(gx + gw, avgY);
            ctx.stroke();
            ctx.setLineDash([]);
            
            ctx.strokeStyle = '#E5E5E5';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 4; i++) {
                const gridY = gy + (gh / 4) * i;
                ctx.beginPath();
                ctx.moveTo(gx, gridY);
                ctx.lineTo(gx + gw, gridY);
                ctx.stroke();
                
                const value = maxScore - ((maxScore - minScore) / 4) * i;
                ctx.font = '14px Arial';
                ctx.fillStyle = '#666';
                ctx.textAlign = 'right';
                ctx.fillText(Math.round(value), gx - 10, gridY + 5);
            }
            
            ctx.font = '14px Arial';
            ctx.fillStyle = '#666';
            ctx.textAlign = 'center';
            ctx.fillText('0', gx, y + h - 25);
            for (let i = 0; i < nbRounds; i++) {
                const labelX = gx + ((gw / nbRounds) * (i + 1));
                ctx.fillText(`M${i + 1}`, labelX, y + h - 25);
            }
            
            curves.forEach((curve, playerIdx) => {
                const player = gameState.players[playerIdx];
                ctx.strokeStyle = player.color;
                ctx.lineWidth = 5;
                ctx.beginPath();
                
                ctx.moveTo(gx, gy + gh);
                
                curve.forEach((score, roundIdx) => {
                    const px = gx + ((gw / nbRounds) * (roundIdx + 1));
                    const py = gy + gh - ((score - minScore) / (maxScore - minScore || 1)) * gh;
                    ctx.lineTo(px, py);
                });
                
                ctx.stroke();
                
                ctx.fillStyle = player.color + '40';
                curve.forEach((score, roundIdx) => {
                    const px = gx + ((gw / nbRounds) * (roundIdx + 1));
                    const py = gy + gh - ((score - minScore) / (maxScore - minScore || 1)) * gh;
                    ctx.beginPath();
                    ctx.arc(px, py, 10, 0, Math.PI * 2);
                    ctx.fill();
                });
                
                ctx.fillStyle = player.color;
                curve.forEach((score, roundIdx) => {
                    const px = gx + ((gw / nbRounds) * (roundIdx + 1));
                    const py = gy + gh - ((score - minScore) / (maxScore - minScore || 1)) * gh;
                    ctx.beginPath();
                    ctx.arc(px, py, 6, 0, Math.PI * 2);
                    ctx.fill();
                });
                
                const lastScore = curve[curve.length - 1];
                const lastX = gx + gw;
                const lastY = gy + gh - ((lastScore - minScore) / (maxScore - minScore || 1)) * gh;
                ctx.fillStyle = player.color + '60';
                ctx.beginPath();
                ctx.arc(lastX, lastY, 14, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = player.color;
                ctx.beginPath();
                ctx.arc(lastX, lastY, 9, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.font = 'bold 16px Arial';
                ctx.fillStyle = player.color;
                ctx.textAlign = 'left';
                ctx.fillText(player.name, lastX + 18, lastY + 5);
            });
            
            return y + h + 20;
        },
        
        drawPodium3DImproved(ctx, x, y, w, players, colors, victoryCondition = 'highest') {
            const isLowest = victoryCondition === 'lowest';
            const sorted = [...players].sort((a,b) => isLowest ? a.total - b.total : b.total - a.total);
            
            ctx.shadowColor = 'rgba(0, 0, 0, 0.2)';
            ctx.shadowBlur = 10;
            ctx.shadowOffsetY = 3;
            ctx.fillStyle = colors.primary;
            ctx.fillRect(x, y, w, 45);
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            ctx.shadowOffsetY = 0;
            
            ctx.font = 'bold 24px Arial';
            ctx.fillStyle = '#FFFFFF';
            ctx.textAlign = 'center';
            ctx.fillText('üèÜ LE CLASSEMENT FINAL', x + w / 2, y + 30);
            
            y += 45 + this.SPACING.SECTION_HEADER;
            
            const podiumY = y;
            const podiumHeight = 320;
            
            ctx.fillStyle = '#FFFFFF';
            ctx.shadowColor = 'rgba(0, 0, 0, 0.15)';
            ctx.shadowBlur = 15;
            ctx.shadowOffsetY = 5;
            ctx.fillRect(x, y, w, podiumHeight);
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            ctx.shadowOffsetY = 0;
            
            ctx.strokeStyle = '#CCCCCC';
            ctx.lineWidth = 2;
            ctx.strokeRect(x, y, w, podiumHeight);
            
            y += 25;
            
            const blockWidth = 130;
            const spacing = 10;
            const totalWidth = blockWidth * 3 + spacing * 2;
            const startX = x + (w - totalWidth) / 2;
            
            const pos2X = startX;
            const pos1X = startX + blockWidth + spacing;
            const pos3X = startX + (blockWidth + spacing) * 2;
            
            if (sorted.length > 1) {
                const h2 = 120;
                const y2 = podiumY + podiumHeight - h2 - 30;
                
                ctx.save();
                ctx.shadowColor = 'rgba(0, 0, 0, 0.25)';
                ctx.shadowBlur = 8;
                ctx.shadowOffsetY = 4;
                
                const grad2 = ctx.createLinearGradient(pos2X, y2, pos2X, y2 + h2);
                grad2.addColorStop(0, '#E0E0E0');
                grad2.addColorStop(0.3, '#C0C0C0');
                grad2.addColorStop(0.7, '#A8A8A8');
                grad2.addColorStop(1, '#909090');
                ctx.fillStyle = grad2;
                ctx.fillRect(pos2X, y2, blockWidth, h2);
                ctx.restore();
                
                ctx.strokeStyle = '#666';
                ctx.lineWidth = 3;
                ctx.strokeRect(pos2X, y2, blockWidth, h2);
                
                ctx.font = '40px Arial';
                ctx.fillText('ü•à', pos2X + blockWidth/2, y2 - 10);
                
                ctx.font = 'bold 20px Arial';
                ctx.fillStyle = '#000';
                const name2 = sorted[1].name.length > 7 ? sorted[1].name.substring(0, 7) : sorted[1].name;
                ctx.fillText(name2, pos2X + blockWidth/2, y2 + h2/2 - 5);
                
                ctx.font = 'bold 24px Arial';
                ctx.fillStyle = '#333';
                ctx.fillText(sorted[1].total, pos2X + blockWidth/2, y2 + h2/2 + 22);
                
                ctx.font = '16px Arial';
                ctx.fillStyle = '#666';
                const diff1 = sorted[0].total - sorted[1].total;
                ctx.fillText(`-${diff1}`, pos2X + blockWidth/2, y2 + h2/2 + 42);
            }
            
            const h1 = 180;
            const y1 = podiumY + podiumHeight - h1 - 30;
            
            ctx.save();
            ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
            ctx.shadowBlur = 12;
            ctx.shadowOffsetY = 6;
            
            const grad1 = ctx.createLinearGradient(pos1X, y1, pos1X, y1 + h1);
            grad1.addColorStop(0, '#FFD700');
            grad1.addColorStop(0.3, '#FFED4E');
            grad1.addColorStop(0.5, '#FFC107');
            grad1.addColorStop(0.7, '#FFB300');
            grad1.addColorStop(1, '#FF8F00');
            ctx.fillStyle = grad1;
            ctx.fillRect(pos1X, y1, blockWidth, h1);
            ctx.restore();
            
            ctx.strokeStyle = '#CC8800';
            ctx.lineWidth = 4;
            ctx.strokeRect(pos1X, y1, blockWidth, h1);
            
            ctx.font = '45px Arial';
            ctx.fillText('üèÜ', pos1X + blockWidth/2, y1 - 10);
            
            ctx.font = 'bold 22px Arial';
            ctx.fillStyle = '#000';
            const name1 = sorted[0].name.length > 7 ? sorted[0].name.substring(0, 7) : sorted[0].name;
            ctx.fillText(name1, pos1X + blockWidth/2, y1 + h1/2 - 18);
            
            ctx.font = 'bold 28px Arial';
            ctx.fillStyle = '#000';
            ctx.fillText(sorted[0].total, pos1X + blockWidth/2, y1 + h1/2 + 10);
            
            ctx.font = 'bold 18px Arial';
            ctx.fillStyle = '#8B4513';
            ctx.fillText('CHAMPION', pos1X + blockWidth/2, y1 + h1/2 + 35);
            
            if (sorted.length > 2) {
                const h3 = 90;
                const y3 = podiumY + podiumHeight - h3 - 30;
                
                ctx.save();
                ctx.shadowColor = 'rgba(0, 0, 0, 0.2)';
                ctx.shadowBlur = 6;
                ctx.shadowOffsetY = 3;
                
                const grad3 = ctx.createLinearGradient(pos3X, y3, pos3X, y3 + h3);
                grad3.addColorStop(0, '#E4A853');
                grad3.addColorStop(0.4, '#CD7F32');
                grad3.addColorStop(0.7, '#B87333');
                grad3.addColorStop(1, '#8B5A2B');
                ctx.fillStyle = grad3;
                ctx.fillRect(pos3X, y3, blockWidth, h3);
                ctx.restore();
                
                ctx.strokeStyle = '#8B5A2B';
                ctx.lineWidth = 3;
                ctx.strokeRect(pos3X, y3, blockWidth, h3);
                
                ctx.font = '35px Arial';
                ctx.fillText('ü•â', pos3X + blockWidth/2, y3 - 8);
                
                ctx.font = 'bold 18px Arial';
                ctx.fillStyle = '#000';
                const name3 = sorted[2].name.length > 7 ? sorted[2].name.substring(0, 7) : sorted[2].name;
                ctx.fillText(name3, pos3X + blockWidth/2, y3 + h3/2 - 2);
                
                ctx.font = 'bold 22px Arial';
                ctx.fillStyle = '#333';
                ctx.fillText(sorted[2].total, pos3X + blockWidth/2, y3 + h3/2 + 22);
                
                const diff2 = sorted[0].total - sorted[2].total;
                ctx.font = '14px Arial';
                ctx.fillStyle = '#666';
                ctx.fillText(`-${diff2}`, pos3X + blockWidth/2, y3 + h3/2 + 40);
            }
            
            return podiumY + podiumHeight;
        },
        
        // ========== NOUVELLES FONCTIONS CLEAN (calcul puis dessin) ==========
        
        drawReactionsClean(ctx, x, y, w, ai, colors) {
            const sp = this.SPACING;
            
            // √âTAPE 1 : Calculer la hauteur SANS dessiner
            const winnerQuote = this.NarrativeEngine.getWinnerQuote();
            const loserQuote = this.NarrativeEngine.getLoserQuote();
            
            ctx.font = 'italic 17px Georgia';
            const winnerLines = this.wrapText(ctx, `"${winnerQuote}"`, w - 40);
            const loserLines = this.wrapText(ctx, `"${loserQuote}"`, w - 40);
            
            let calcH = sp.SECTION_PADDING;
            calcH += 24; // Titre gagnant
            calcH += winnerLines.length * 22 + 20;
            calcH += 20; // S√©parateur
            calcH += 24; // Titre perdant
            calcH += loserLines.length * 22 + sp.SECTION_PADDING;
            
            // √âTAPE 2 : Dessiner le bandeau
            const gradient = ctx.createLinearGradient(x, y, x + w, y);
            gradient.addColorStop(0, colors.accent);
            gradient.addColorStop(1, colors.primary);
            ctx.fillStyle = gradient;
            
            ctx.shadowColor = 'rgba(0, 0, 0, 0.2)';
            ctx.shadowBlur = 10;
            ctx.shadowOffsetY = 3;
            ctx.fillRect(x, y, w, 45);
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            ctx.shadowOffsetY = 0;
            
            ctx.font = 'bold 24px Arial';
            ctx.fillStyle = '#FFFFFF';
            ctx.textAlign = 'center';
            ctx.fillText('üí¨ LES R√âACTIONS', x + w / 2, y + 30);
            
            y += 45 + sp.SECTION_HEADER;
            const contentY = y;
            
            // √âTAPE 3 : Dessiner le cadre blanc
            ctx.fillStyle = '#FFFFFF';
            ctx.shadowColor = 'rgba(0, 0, 0, 0.15)';
            ctx.shadowBlur = 15;
            ctx.shadowOffsetY = 5;
            ctx.fillRect(x, contentY, w, calcH);
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            ctx.shadowOffsetY = 0;
            
            ctx.strokeStyle = '#CCCCCC';
            ctx.lineWidth = 2;
            ctx.strokeRect(x, contentY, w, calcH);
            
            // √âTAPE 4 : Dessiner le contenu (UNE SEULE FOIS !)
            y = contentY + sp.SECTION_PADDING;
            
            ctx.font = 'bold 19px Arial';
            ctx.fillStyle = colors.primary;
            ctx.textAlign = 'left';
            ctx.fillText(`üé§ ${ai.brain.winner.toUpperCase()}`, x + 20, y);
            y += 24;
            
            ctx.font = 'italic 17px Georgia';
            ctx.fillStyle = '#555';
            winnerLines.forEach((line, idx) => {
                ctx.fillText(line, x + 20, y + (idx * 22));
            });
            y += winnerLines.length * 22 + 20;
            
            ctx.strokeStyle = '#EEEEEE';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(x + 20, y);
            ctx.lineTo(x + w - 20, y);
            ctx.stroke();
            y += 20;
            
            ctx.font = 'bold 19px Arial';
            ctx.fillStyle = '#C8102E';
            ctx.fillText(`üò≠ ${ai.cast.boulet.toUpperCase()}`, x + 20, y);
            y += 24;
            
            ctx.font = 'italic 17px Georgia';
            ctx.fillStyle = '#555';
            loserLines.forEach((line, idx) => {
                ctx.fillText(line, x + 20, y + (idx * 22));
            });
            
            return contentY + calcH;
        },
        
        drawTempsFortsClean(ctx, x, y, w, ai, colors, gameState) {
            const sp = this.SPACING;
            
            // √âTAPE 1 : Calculer la hauteur SANS dessiner
            ctx.font = '18px Arial';
            const feuLines = this.wrapText(ctx, `${ai.bestRound.player} a explos√©`, w - 40);
            ctx.font = 'bold 20px Arial';
            const mancheLines = this.wrapText(ctx, `‚ñ∂ ${ai.bestRound.score} pts (M${ai.bestRound.round})`, w - 40);
            
            let dramaLines = [], dramaScoreLines = [];
            let exploitLines = [], exploitScoreLines = [];
            let serieLines = [], autoLines = [];
            let manchesLines = [];
            
            if (ai.worstRound.score < 0) {
                ctx.font = '18px Arial';
                dramaLines = this.wrapText(ctx, `${ai.worstRound.player} catastrophique`, w - 40);
                ctx.font = 'bold 20px Arial';
                dramaScoreLines = this.wrapText(ctx, `‚ñ∂ ${ai.worstRound.score} pts (M${ai.worstRound.round})`, w - 40);
            } else {
                ctx.font = '18px Arial';
                exploitLines = this.wrapText(ctx, `${ai.secondBestRound.player} en feu`, w - 40);
                ctx.font = 'bold 20px Arial';
                exploitScoreLines = this.wrapText(ctx, `‚ñ∂ ${ai.secondBestRound.score} pts (M${ai.secondBestRound.round})`, w - 40);
            }
            
            if (ai.bestStreak.count > 1) {
                ctx.font = '18px Arial';
                serieLines = this.wrapText(ctx, `${ai.bestStreak.player} : ${ai.bestStreak.count} victoires`, w - 40);
                ctx.font = 'bold 20px Arial';
                autoLines = this.wrapText(ctx, '‚ñ∂ Mode auto', w - 40);
            } else {
                ctx.font = 'bold 20px Arial';
                manchesLines = this.wrapText(ctx, `‚ñ∂ ${gameState.history.length} manches`, w - 40);
            }
            
            let calcH = sp.SECTION_PADDING;
            calcH += 24 + feuLines.length * 20 + 4 + mancheLines.length * 20 + sp.ITEM_SPACING;
            calcH += sp.ITEM_SPACING;
            
            if (ai.worstRound.score < 0) {
                calcH += 24 + dramaLines.length * 20 + 4 + dramaScoreLines.length * 20 + sp.ITEM_SPACING;
            } else {
                calcH += 24 + exploitLines.length * 20 + 4 + exploitScoreLines.length * 20 + sp.ITEM_SPACING;
            }
            
            calcH += sp.ITEM_SPACING;
            
            if (ai.bestStreak.count > 1) {
                calcH += 24 + serieLines.length * 20 + 4 + autoLines.length * 20 + sp.SECTION_PADDING;
            } else {
                calcH += 24 + 24 + manchesLines.length * 20 + sp.SECTION_PADDING;
            }
            
            // √âTAPE 2 : Dessiner le bandeau
            const gradient = ctx.createLinearGradient(x, y, x + w, y);
            gradient.addColorStop(0, colors.primary);
            gradient.addColorStop(1, colors.accent);
            ctx.fillStyle = gradient;
            
            ctx.shadowColor = 'rgba(0, 0, 0, 0.2)';
            ctx.shadowBlur = 10;
            ctx.shadowOffsetY = 3;
            ctx.fillRect(x, y, w, 45);
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            ctx.shadowOffsetY = 0;
            
            ctx.font = 'bold 24px Arial';
            ctx.fillStyle = '#FFFFFF';
            ctx.textAlign = 'center';
            ctx.fillText('‚≠ê LES TEMPS FORTS', x + w / 2, y + 30);
            
            y += 45 + sp.SECTION_HEADER;
            const contentY = y;
            
            // √âTAPE 3 : Dessiner le cadre blanc
            ctx.fillStyle = '#FFFFFF';
            ctx.shadowColor = 'rgba(0, 0, 0, 0.15)';
            ctx.shadowBlur = 15;
            ctx.shadowOffsetY = 5;
            ctx.fillRect(x, contentY, w, calcH);
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            ctx.shadowOffsetY = 0;
            
            ctx.strokeStyle = '#CCCCCC';
            ctx.lineWidth = 2;
            ctx.strokeRect(x, contentY, w, calcH);
            
            // √âTAPE 4 : Dessiner le contenu (UNE SEULE FOIS !)
            y = contentY + sp.SECTION_PADDING;
            
            this.drawFlame(ctx, x + 30, y - 5, 18);
            ctx.font = 'bold 22px Arial';
            ctx.fillStyle = '#FF6600';
            ctx.textAlign = 'left';
            ctx.fillText('LE MOMENT FEU', x + 60, y);
            y += 24;
            
            ctx.font = '18px Arial';
            ctx.fillStyle = '#333';
            feuLines.forEach((line, idx) => {
                ctx.fillText(line, x + 20, y + (idx * 20));
            });
            y += feuLines.length * 20 + 4;
            
            ctx.font = 'bold 20px Arial';
            ctx.fillStyle = '#FF6600';
            mancheLines.forEach((line, idx) => {
                ctx.fillText(line, x + 20, y + (idx * 20));
            });
            y += mancheLines.length * 20 + sp.ITEM_SPACING;
            
            ctx.strokeStyle = '#DDDDDD';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(x + 20, y);
            ctx.lineTo(x + w - 20, y);
            ctx.stroke();
            y += sp.ITEM_SPACING;
            
            if (ai.worstRound.score < 0) {
                ctx.font = '28px Arial';
                ctx.fillText('üíÄ', x + 20, y);
                ctx.font = 'bold 22px Arial';
                ctx.fillStyle = '#8B0000';
                ctx.fillText('LE DRAMA', x + 60, y);
                y += 24;
                
                ctx.font = '18px Arial';
                ctx.fillStyle = '#333';
                dramaLines.forEach((line, idx) => {
                    ctx.fillText(line, x + 20, y + (idx * 20));
                });
                y += dramaLines.length * 20 + 4;
                
                ctx.font = 'bold 20px Arial';
                ctx.fillStyle = '#8B0000';
                dramaScoreLines.forEach((line, idx) => {
                    ctx.fillText(line, x + 20, y + (idx * 20));
                });
                y += dramaScoreLines.length * 20 + sp.ITEM_SPACING;
            } else {
                ctx.font = '28px Arial';
                ctx.fillText('üéØ', x + 20, y);
                ctx.font = 'bold 22px Arial';
                ctx.fillStyle = '#4CAF50';
                ctx.fillText('EXPLOIT #2', x + 60, y);
                y += 24;
                
                ctx.font = '18px Arial';
                ctx.fillStyle = '#333';
                exploitLines.forEach((line, idx) => {
                    ctx.fillText(line, x + 20, y + (idx * 20));
                });
                y += exploitLines.length * 20 + 4;
                
                ctx.font = 'bold 20px Arial';
                ctx.fillStyle = '#4CAF50';
                exploitScoreLines.forEach((line, idx) => {
                    ctx.fillText(line, x + 20, y + (idx * 20));
                });
                y += exploitScoreLines.length * 20 + sp.ITEM_SPACING;
            }
            
            ctx.strokeStyle = '#DDDDDD';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(x + 20, y);
            ctx.lineTo(x + w - 20, y);
            ctx.stroke();
            y += sp.ITEM_SPACING;
            
            if (ai.bestStreak.count > 1) {
                this.drawLightning(ctx, x + 25, y - 20, 20);
                ctx.font = 'bold 22px Arial';
                ctx.fillStyle = '#FFD700';
                ctx.fillText('LA S√âRIE', x + 60, y);
                y += 24;
                
                ctx.font = '18px Arial';
                ctx.fillStyle = '#333';
                serieLines.forEach((line, idx) => {
                    ctx.fillText(line, x + 20, y + (idx * 20));
                });
                y += serieLines.length * 20 + 4;
                
                ctx.font = 'bold 20px Arial';
                ctx.fillStyle = '#FFD700';
                autoLines.forEach((line, idx) => {
                    ctx.fillText(line, x + 20, y + (idx * 20));
                });
            } else {
                ctx.font = '28px Arial';
                ctx.fillText('üìä', x + 20, y);
                ctx.font = 'bold 22px Arial';
                ctx.fillStyle = colors.primary;
                ctx.fillText('R√âGULARIT√â', x + 60, y);
                y += 24;
                
                ctx.font = '18px Arial';
                ctx.fillStyle = '#333';
                ctx.fillText(`Match √©quilibr√©`, x + 20, y);
                y += 24;
                
                ctx.font = 'bold 20px Arial';
                ctx.fillStyle = colors.primary;
                manchesLines.forEach((line, idx) => {
                    ctx.fillText(line, x + 20, y + (idx * 20));
                });
            }
            
            return contentY + calcH;
        },
        
        // Fonction ULTRA-SAFE : Mesurer d'abord, dessiner ensuite
        measureStatsContent(ctx, w, ai, gameState) {
            const sp = this.SPACING;
            const precision = ai.cast.precision;
            
            // Pr√©parer toutes les donn√©es SANS DESSINER
            ctx.font = '19px Arial';  // Correspond √† la police utilis√©e
            const data = {
                precisionLines: [],
                topPlayer: null,
                bestLines: this.wrapText(ctx, `üî• Meilleure : ${ai.bestRound.player}`, w - 50),
                worstLines: [],
                streakLines: [],
                ecartLines: this.wrapText(ctx, `üéØ √âcart final : ${ai.finalGap} pts`, w - 50),
                manchesLines: this.wrapText(ctx, `üìà Manches : ${gameState.history.length}`, w - 50)
            };
            
            if (precision && precision.length > 0) {
                data.topPlayer = precision[0];
                data.precisionLines = this.wrapText(ctx, `üéØ Taux victoire : ${data.topPlayer.name}`, w - 50);
            }
            
            if (ai.worstRound.score < 0) {
                data.worstLines = this.wrapText(ctx, `üíÄ Pire : ${ai.worstRound.player}`, w - 50);
            }
            
            if (ai.bestStreak.count > 1) {
                data.streakLines = this.wrapText(ctx, `‚ö° S√©rie : ${ai.bestStreak.player}`, w - 50);
            }
            
            // Calculer la hauteur totale (avec nouveaux espacements)
            let height = sp.SECTION_PADDING;
            if (data.topPlayer) {
                height += data.precisionLines.length * 22 + 8 + 30 + 20;  // Nouvelle taille de barre
            }
            height += data.bestLines.length * 22 + 8 + 28 + 20;  // Nouveaux espacements
            if (data.worstLines.length > 0) {
                height += data.worstLines.length * 22 + 8 + 28 + 20;
            }
            if (data.streakLines.length > 0) {
                height += data.streakLines.length * 22 + 8 + 28 + 20;
            }
            height += data.ecartLines.length * 22 + 26 + 20;
            height += data.manchesLines.length * 22 + sp.SECTION_PADDING;
            
            return { data, height };
        },
        
        drawStatsClean(ctx, x, y, w, ai, gameState, colors) {
            const sp = this.SPACING;
            
            // Mesurer le contenu
            const { data, height } = this.measureStatsContent(ctx, w, ai, gameState);
            
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // HEADER
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            const headerGrad = ctx.createLinearGradient(x, y, x + w, y);
            headerGrad.addColorStop(0, colors.primary);
            headerGrad.addColorStop(0.5, colors.accent);
            headerGrad.addColorStop(1, colors.primary);
            ctx.fillStyle = headerGrad;
            
            ctx.shadowColor = 'rgba(0, 0, 0, 0.25)';
            ctx.shadowBlur = 12;
            ctx.shadowOffsetY = 4;
            ctx.fillRect(x, y, w, 50);
            
            ctx.shadowBlur = 0;
            ctx.shadowOffsetY = 0;
            
            ctx.strokeStyle = 'rgba(255, 215, 0, 0.3)';
            ctx.lineWidth = 2;
            ctx.strokeRect(x, y, w, 50);
            
            // Titre header (CENTER pour cette ligne seulement)
            ctx.font = 'bold 26px Arial';
            ctx.fillStyle = '#FFFFFF';
            ctx.textAlign = 'center';
            ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
            ctx.shadowBlur = 3;
            ctx.fillText('üìä LES STATS', x + w / 2, y + 33);
            ctx.shadowBlur = 0;
            ctx.shadowColor = 'transparent';
            
            y += 50 + sp.SECTION_HEADER;
            const contentY = y;
            
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // CADRE BLANC
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            ctx.fillStyle = '#FFFFFF';
            ctx.shadowColor = 'rgba(0, 0, 0, 0.2)';
            ctx.shadowBlur = 20;
            ctx.shadowOffsetY = 8;
            ctx.fillRect(x, contentY, w, height);
            ctx.shadowBlur = 0;
            ctx.shadowOffsetY = 0;
            ctx.shadowColor = 'transparent';
            
            ctx.strokeStyle = '#DDDDDD';
            ctx.lineWidth = 3;
            ctx.strokeRect(x, contentY, w, height);
            
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // CONTENU - POSITION DE D√âPART
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            let currentY = contentY + sp.SECTION_PADDING;
            const baseX = x + 25;  // Position X de base pour TOUT le texte
            
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // SECTION 1 : TAUX DE VICTOIRE
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            if (data.topPlayer) {
                // Dessiner chaque ligne individuellement
                ctx.font = '19px Arial';
                ctx.fillStyle = '#2c2c2c';
                
                for (let i = 0; i < data.precisionLines.length; i++) {
                    ctx.textAlign = 'left';  // FORC√â avant chaque ligne
                    ctx.fillText(data.precisionLines[i], baseX, currentY);
                    currentY += 22;
                }
                currentY += 8;
                
                // Barre de progression
                this.drawStatBar(ctx, baseX, currentY, w - 50, data.topPlayer.value, 100, colors.primary);
                currentY += 30;
                
                // S√©parateur
                this.drawSeparator(ctx, x + 25, x + w - 25, currentY);
                currentY += 20;
            }
            
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // SECTION 2 : MEILLEURE MANCHE
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            ctx.font = '19px Arial';
            ctx.fillStyle = '#2c2c2c';
            
            for (let i = 0; i < data.bestLines.length; i++) {
                ctx.textAlign = 'left';  // FORC√â avant chaque ligne
                ctx.fillText(data.bestLines[i], baseX, currentY);
                currentY += 22;
            }
            currentY += 8;
            
            // Score
            ctx.textAlign = 'left';  // FORC√â
            ctx.font = 'bold 24px Arial';
            ctx.fillStyle = colors.accent;
            ctx.shadowColor = 'rgba(255, 100, 0, 0.3)';
            ctx.shadowBlur = 5;
            ctx.fillText(`${ai.bestRound.score} pts`, baseX, currentY);
            ctx.shadowBlur = 0;
            ctx.shadowColor = 'transparent';
            currentY += 28;
            
            // S√©parateur
            this.drawSeparator(ctx, x + 25, x + w - 25, currentY);
            currentY += 20;
            
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // SECTION 3 : PIRE MANCHE (si existe)
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            if (data.worstLines.length > 0) {
                ctx.font = '19px Arial';
                ctx.fillStyle = '#2c2c2c';
                
                for (let i = 0; i < data.worstLines.length; i++) {
                    ctx.textAlign = 'left';
                    ctx.fillText(data.worstLines[i], baseX, currentY);
                    currentY += 22;
                }
                currentY += 8;
                
                ctx.textAlign = 'left';
                ctx.font = 'bold 24px Arial';
                ctx.fillStyle = '#F44336';
                ctx.shadowColor = 'rgba(244, 67, 54, 0.3)';
                ctx.shadowBlur = 5;
                ctx.fillText(`${ai.worstRound.score} pts`, baseX, currentY);
                ctx.shadowBlur = 0;
                ctx.shadowColor = 'transparent';
                currentY += 28;
                
                this.drawSeparator(ctx, x + 25, x + w - 25, currentY);
                currentY += 20;
            }
            
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // SECTION 4 : S√âRIE (si existe)
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            if (data.streakLines.length > 0) {
                ctx.font = '19px Arial';
                ctx.fillStyle = '#2c2c2c';
                
                for (let i = 0; i < data.streakLines.length; i++) {
                    ctx.textAlign = 'left';
                    ctx.fillText(data.streakLines[i], baseX, currentY);
                    currentY += 22;
                }
                currentY += 8;
                
                ctx.textAlign = 'left';
                ctx.font = 'bold 24px Arial';
                ctx.fillStyle = colors.secondary;
                ctx.shadowColor = `${colors.secondary}40`;
                ctx.shadowBlur = 5;
                ctx.fillText(`${ai.bestStreak.count} victoires`, baseX, currentY);
                ctx.shadowBlur = 0;
                ctx.shadowColor = 'transparent';
                currentY += 28;
                
                this.drawSeparator(ctx, x + 25, x + w - 25, currentY);
                currentY += 20;
            }
            
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // SECTION 5 : √âCART FINAL
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            ctx.font = '19px Arial';
            ctx.fillStyle = '#2c2c2c';
            
            for (let i = 0; i < data.ecartLines.length; i++) {
                ctx.textAlign = 'left';
                ctx.fillText(data.ecartLines[i], baseX, currentY);
                currentY += 22;
            }
            currentY += 26;
            
            // S√©parateur
            this.drawSeparator(ctx, x + 25, x + w - 25, currentY);
            currentY += 20;
            
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // SECTION 6 : MANCHES
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            ctx.font = '19px Arial';
            ctx.fillStyle = '#2c2c2c';
            
            for (let i = 0; i < data.manchesLines.length; i++) {
                ctx.textAlign = 'left';
                ctx.fillText(data.manchesLines[i], baseX, currentY);
                currentY += 22;
            }
            
            // Retourner position finale
            return contentY + height;
        },
        
        // Fonction helper pour dessiner les s√©parateurs
        drawSeparator(ctx, x1, x2, y) {
            const grad = ctx.createLinearGradient(x1, y, x2, y);
            grad.addColorStop(0, 'rgba(0,0,0,0)');
            grad.addColorStop(0.5, 'rgba(0,0,0,0.15)');
            grad.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.strokeStyle = grad;
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(x1, y);
            ctx.lineTo(x2, y);
            ctx.stroke();
        },
        
        drawFlame(ctx, x, y, size) {
            ctx.fillStyle = '#FF6600';
            ctx.beginPath();
            ctx.moveTo(x, y + size);
            ctx.bezierCurveTo(x - size*0.4, y, x - size*0.2, y - size, x, y - size*1.5);
            ctx.bezierCurveTo(x + size*0.2, y - size, x + size*0.4, y, x, y + size);
            ctx.fill();
            
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.arc(x, y - size*0.3, size*0.4, 0, Math.PI * 2);
            ctx.fill();
        },
        
        drawLightning(ctx, x, y, size) {
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x + size*0.3, y + size*0.5);
            ctx.lineTo(x + size*0.15, y + size*0.5);
            ctx.lineTo(x + size*0.4, y + size);
            ctx.lineTo(x - size*0.1, y + size*0.6);
            ctx.lineTo(x + size*0.1, y + size*0.6);
            ctx.closePath();
            ctx.fill();
            
            ctx.strokeStyle = '#FF8C00';
            ctx.lineWidth = 2;
            ctx.stroke();
        },
        
        drawStatBar(ctx, x, y, w, value, maxValue, color) {
            // Background de la barre avec d√©grad√© subtil
            const bgGrad = ctx.createLinearGradient(x, y, x, y + 26);
            bgGrad.addColorStop(0, '#F0F0F0');
            bgGrad.addColorStop(1, '#E0E0E0');
            ctx.fillStyle = bgGrad;
            ctx.fillRect(x, y, w, 26);  // Barre plus haute
            
            // Barre de progression avec d√©grad√© color√©
            const barWidth = (value / maxValue) * w;
            if (barWidth > 0) {
                const gradient = ctx.createLinearGradient(x, y, x + barWidth, y);
                gradient.addColorStop(0, color);
                gradient.addColorStop(0.5, color + 'DD');
                gradient.addColorStop(1, color + 'AA');
                ctx.fillStyle = gradient;
                ctx.fillRect(x, y, barWidth, 26);
                
                // Effet de brillance sur la barre
                const shineGrad = ctx.createLinearGradient(x, y, x, y + 26);
                shineGrad.addColorStop(0, 'rgba(255,255,255,0.4)');
                shineGrad.addColorStop(0.5, 'rgba(255,255,255,0.1)');
                shineGrad.addColorStop(1, 'rgba(0,0,0,0.1)');
                ctx.fillStyle = shineGrad;
                ctx.fillRect(x, y, barWidth, 26);
            }
            
            // Bordure avec ombre interne
            ctx.strokeStyle = '#CCC';
            ctx.lineWidth = 2;
            ctx.strokeRect(x, y, w, 26);
            
            // Pourcentage avec ombre
            ctx.font = 'bold 17px Arial';  // Police plus grande
            ctx.fillStyle = '#000';
            ctx.textAlign = 'center';
            ctx.shadowColor = 'rgba(255, 255, 255, 0.8)';
            ctx.shadowBlur = 3;
            ctx.shadowOffsetY = 1;
            ctx.fillText(`${value}%`, x + w/2, y + 18);
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            ctx.shadowOffsetY = 0;
        },
        
        wrapText(ctx, text, maxWidth) {
            const words = text.split(' ');
            const lines = [];
            let line = '';
            
            words.forEach(word => {
                const test = line + word + ' ';
                const metrics = ctx.measureText(test);
                if (metrics.width > maxWidth && line !== '') {
                    lines.push(line.trim());
                    line = word + ' ';
                } else {
                    line = test;
                }
            });
            
            if (line) lines.push(line.trim());
            return lines;
        },
        
        downloadImage(canvas, filename = 'ScoreMaster_Recap_CLEAN.png') {
            canvas.toBlob((blob) => {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                a.click();
                URL.revokeObjectURL(url);
            });
        },
        
        async shareImage(canvas) {
            if (!navigator.share || !navigator.canShare) return false;
            
            try {
                const blob = await new Promise(resolve => canvas.toBlob(resolve));
                const file = new File([blob], 'ScoreMaster_Recap_CLEAN.png', { type: 'image/png' });
                
                if (navigator.canShare({ files: [file] })) {
                    await navigator.share({
                        files: [file],
                        title: 'ScoreMaster - R√©cap CLEAN',
                        text: 'D√©couvrez le r√©cap CLEAN ! üèÜ'
                    });
                    return true;
                }
            } catch (error) {
                console.error('Erreur partage:', error);
            }
            
            return false;
        }
    };

    // ==================== RECAP GIF GENERATOR MOBILE ====================
    // Version optimis√©e pour mobile : SANS WEB WORKERS
    // Plus lent mais fonctionne partout (m√™me en file://)
    
    const RecapGifGenerator = {
        CONFIG: {
            WIDTH: 500,      // Optimis√© mobile
            HEIGHT: 1400,    // Optimis√© pour √©viter espace vide
            FPS: 15,         // 15 fps fluide
            DURATION: 5,     // 5 secondes pour laisser lire
            QUALITY: 20      // Qualit√© optimale
        },
        
        debugLog(msg) {
            const debugConsole = document.getElementById('debug-console');
            const debugLogDiv = document.getElementById('debug-log');
            if (debugConsole && debugLogDiv) {
                debugConsole.style.display = 'block';
                const time = new Date().toLocaleTimeString();
                debugLogDiv.innerHTML += `<div>[${time}] ${msg}</div>`;
                debugLogDiv.scrollTop = debugLogDiv.scrollHeight;
            }
            window.console.log('[RecapGif] ' + msg);
        },
        
        async generateAnimated(gameState, progressCallback = null) {
            this.debugLog('=== D√âBUT generateAnimated() ===');
            
            const updateProgress = (progress, message) => {
                if (progressCallback) progressCallback(progress, message);
            };
            
            try {
                this.debugLog('1Ô∏è‚É£ V√©rification gifshot...');
                if (typeof gifshot === 'undefined') {
                    this.debugLog('‚ùå gifshot undefined!');
                    UI.hideLoading();
                    throw new Error('Biblioth√®que gifshot non charg√©e');
                }
                this.debugLog('‚úÖ gifshot OK');
                
                this.debugLog('2Ô∏è‚É£ V√©rification gameState...');
                if (!gameState.players || gameState.players.length === 0) {
                    this.debugLog('‚ùå Pas de joueurs!');
                    UI.hideLoading();
                    throw new Error('Aucun joueur trouv√©');
                }
                this.debugLog(`‚úÖ ${gameState.players.length} joueurs`);
                
                updateProgress(5, 'Analyse des donn√©es...');
                this.debugLog('4Ô∏è‚É£ Analyse des donn√©es...');
                const ai = RecapGenerator.analyzeGameData(gameState);
                this.debugLog('‚úÖ Donn√©es analys√©es');
                
                this.debugLog('5Ô∏è‚É£ R√©cup√©ration des couleurs...');
                const colors = RecapGenerator.GENRE_COLORS[ai.brain.genre];
                this.debugLog(`‚úÖ Genre: ${ai.brain.genre}`);
                
                const totalFrames = this.CONFIG.FPS * this.CONFIG.DURATION;
                this.debugLog(`6Ô∏è‚É£ G√©n√©ration de ${totalFrames} frames...`);
                
                updateProgress(10, `G√©n√©ration de ${totalFrames} frames...`);
                
                // G√©n√©rer toutes les frames
                const frames = [];
                for (let frame = 0; frame < totalFrames; frame++) {
                    const canvas = this.drawAnimatedFrame(frame, totalFrames, ai, gameState, colors);
                    frames.push(canvas.toDataURL('image/png'));
                    
                    if (frame % 5 === 0) {
                        const percent = 10 + Math.round((frame / totalFrames) * 50);
                        updateProgress(percent, `Frame ${frame + 1}/${totalFrames}`);
                        this.debugLog(`   Frame ${frame}/${totalFrames} (${percent}%)`);
                    }
                }
                this.debugLog('‚úÖ Toutes les frames g√©n√©r√©es');
                
                updateProgress(60, 'Encodage du GIF...');
                this.debugLog('7Ô∏è‚É£ Cr√©ation GIF avec gifshot...');
                
                // gifshot.createGIF avec callback
                gifshot.createGIF({
                    images: frames,
                    gifWidth: this.CONFIG.WIDTH,
                    gifHeight: this.CONFIG.HEIGHT,
                    interval: 1 / this.CONFIG.FPS,  // D√©lai en secondes
                    numFrames: totalFrames,
                    frameDuration: 1,
                    sampleInterval: 10,
                    progressCallback: (progress) => {
                        const percent = 60 + Math.round(progress * 35);
                        updateProgress(percent, `Encodage: ${Math.round(progress * 100)}%`);
                        this.debugLog(`   Encodage: ${Math.round(progress * 100)}%`);
                    }
                }, (obj) => {
                    if (!obj.error) {
                        this.debugLog('8Ô∏è‚É£ GIF cr√©√© avec succ√®s!');
                        updateProgress(95, 'Finalisation...');
                        
                        // Convertir data URL en blob
                        fetch(obj.image)
                            .then(res => res.blob())
                            .then(blob => {
                                this.debugLog(`   Taille: ${Math.round(blob.size / 1024)} Ko`);
                                this.downloadGif(blob);
                                updateProgress(100, 'Termin√© !');
                                
                                setTimeout(() => {
                                    UI.hideLoading();
                                    UI.showToast('‚úÖ GIF t√©l√©charg√© !', 'success');
                                }, 300);
                                
                                this.debugLog('=== FIN SUCCESS ===');
                            })
                            .catch(err => {
                                this.debugLog('‚ùå Erreur conversion blob: ' + err.message);
                                UI.hideLoading();
                                UI.showToast('‚ùå Erreur t√©l√©chargement', 'error');
                            });
                    } else {
                        this.debugLog('‚ùå Erreur gifshot: ' + obj.error);
                        UI.hideLoading();
                        UI.showToast('‚ùå Erreur: ' + obj.error, 'error');
                    }
                });
                
                this.debugLog('‚úÖ gifshot.createGIF() lanc√©');
                
            } catch (error) {
                this.debugLog('‚ùå ERREUR CATCH:');
                this.debugLog(`   Message: ${error.message}`);
                this.debugLog(`   Stack: ${error.stack}`);
                window.console.error('[RecapGifGenerator] Erreur:', error);
                UI.hideLoading();
                UI.showToast('‚ùå Erreur: ' + error.message, 'error');
            }
        },
        
        drawAnimatedFrame(frame, totalFrames, ai, gameState, colors) {
            const canvas = document.createElement('canvas');
            canvas.width = this.CONFIG.WIDTH;
            canvas.height = this.CONFIG.HEIGHT;
            const ctx = canvas.getContext('2d');
            
            const progress = frame / totalFrames;
            
            // Fond
            ctx.fillStyle = '#F5F1E8';
            ctx.fillRect(0, 0, this.CONFIG.WIDTH, this.CONFIG.HEIGHT);
            this.drawPaperTexture(ctx);
            
            let y = 0;
            
            // Phases simplifi√©es (3 secondes au lieu de 5)
            y = this.drawAnimatedBanner(ctx, y, colors, this.getPhaseProgress(progress, 0, 0.15));
            y = this.drawAnimatedChampion(ctx, y, ai.brain.winner, 
                gameState.players.find(p => p.name === ai.brain.winner).total,
                colors, this.getPhaseProgress(progress, 0.15, 0.30));
            y = this.drawAnimatedTitle(ctx, y, this.getPhaseProgress(progress, 0.30, 0.40));
            y = this.drawAnimatedNarrative(ctx, y, ai.narrative, this.getPhaseProgress(progress, 0.40, 0.55));
            // Pas de graphique (trop lourd pour mobile)
            y = this.drawAnimatedTempsForts(ctx, y, ai, gameState, colors, this.getPhaseProgress(progress, 0.55, 0.80));
            y = this.drawAnimatedStats(ctx, y, ai, gameState, colors, this.getPhaseProgress(progress, 0.80, 1.0));
            
            this.drawWatermark(ctx);
            
            return canvas;
        },
        
        getPhaseProgress(globalProgress, start, end) {
            if (globalProgress < start) return 0;
            if (globalProgress > end) return 1;
            return (globalProgress - start) / (end - start);
        },
        
        drawAnimatedBanner(ctx, startY, colors, progress) {
            const w = this.CONFIG.WIDTH;
            const h = 120;  // 100 ‚Üí 120px
            const eased = this.easeOutCubic(progress);
            const currentY = startY - (h * (1 - eased));
            
            // D√©grad√© radial ultra-styl√©
            const gradient = ctx.createLinearGradient(0, currentY, 0, currentY + h);
            gradient.addColorStop(0, '#1a1a2e');
            gradient.addColorStop(0.5, colors.primary);
            gradient.addColorStop(1, '#0f0f1e');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, currentY, w, h);
            
            // Effet de shine/brillance
            if (progress > 0.3) {
                const shineGrad = ctx.createLinearGradient(0, currentY, 0, currentY + h);
                shineGrad.addColorStop(0, 'rgba(255,255,255,0)');
                shineGrad.addColorStop(0.5, `rgba(255,255,255,${0.15 * (progress - 0.3)})`);
                shineGrad.addColorStop(1, 'rgba(255,255,255,0)');
                ctx.fillStyle = shineGrad;
                ctx.fillRect(0, currentY, w, h);
            }
            
            // Particules scintillantes
            if (progress > 0.5) {
                ctx.fillStyle = 'rgba(255, 215, 0, 0.6)';
                for (let i = 0; i < 15; i++) {
                    const px = (w / 15) * i + Math.sin(progress * 10 + i) * 10;
                    const py = currentY + 20 + Math.cos(progress * 8 + i) * 8;
                    const size = 2.5 + Math.sin(progress * 20 + i) * 1.5;
                    ctx.beginPath();
                    ctx.arc(px, py, size, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            // Texte avec effet glow
            if (progress > 0.5) {
                const textAlpha = (progress - 0.5) * 2;
                
                // Glow effect
                ctx.shadowBlur = 25;
                ctx.shadowColor = 'rgba(255, 215, 0, 0.9)';
                ctx.font = 'italic 900 70px Georgia';  // 60 ‚Üí 70px
                ctx.fillStyle = '#FFD700';
                ctx.textAlign = 'center';
                ctx.globalAlpha = textAlpha;
                ctx.fillText('LE SCORE', w / 2, currentY + 75);
                
                // Outline/stroke
                ctx.shadowBlur = 0;
                ctx.strokeStyle = '#8B4513';
                ctx.lineWidth = 4;  // 3 ‚Üí 4px
                ctx.strokeText('LE SCORE', w / 2, currentY + 75);
                
                ctx.globalAlpha = 1;
            }
            
            return startY + h + 10;  // +10px padding
        },
        
        drawAnimatedChampion(ctx, startY, name, score, colors, progress) {
            const w = this.CONFIG.WIDTH;
            const h = 110;  // 90 ‚Üí 110px
            const centerX = w / 2;
            const centerY = startY + h / 2;
            const eased = this.easeOutBounce(progress);
            
            ctx.save();
            ctx.translate(centerX, centerY);
            ctx.scale(eased, eased);
            
            // Ombre port√©e 3D
            ctx.shadowBlur = 30;  // 25 ‚Üí 30
            ctx.shadowColor = 'rgba(0, 0, 0, 0.6)';  // 0.5 ‚Üí 0.6
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 10;  // 8 ‚Üí 10
            
            // Fond avec d√©grad√© gold premium
            const boxGrad = ctx.createLinearGradient(0, -45, 0, 45);
            boxGrad.addColorStop(0, '#FFD700');
            boxGrad.addColorStop(0.5, '#FFA500');
            boxGrad.addColorStop(1, '#FF8C00');
            ctx.fillStyle = boxGrad;
            ctx.fillRect(-210, -45, 420, 90);  // Augment√©
            
            // Bordure dor√©e brillante
            ctx.shadowBlur = 0;
            ctx.strokeStyle = '#8B4513';
            ctx.lineWidth = 5;  // 4 ‚Üí 5
            ctx.strokeRect(-210, -45, 420, 90);
            
            // Effet shine diagonal
            const shineGrad = ctx.createLinearGradient(-210, -45, 210, 45);
            shineGrad.addColorStop(0, 'rgba(255,255,255,0)');
            shineGrad.addColorStop(0.4, 'rgba(255,255,255,0)');
            shineGrad.addColorStop(0.5, 'rgba(255,255,255,0.4)');
            shineGrad.addColorStop(0.6, 'rgba(255,255,255,0)');
            shineGrad.addColorStop(1, 'rgba(255,255,255,0)');
            ctx.fillStyle = shineGrad;
            ctx.fillRect(-210, -45, 420, 90);
            
            // Troph√©es avec glow
            ctx.shadowBlur = 12;  // 10 ‚Üí 12
            ctx.shadowColor = 'rgba(255, 215, 0, 0.9)';
            ctx.font = '40px Arial';  // 35 ‚Üí 40
            ctx.fillText('üèÜ', -180, 5);
            ctx.fillText('üèÜ', 145, 5);
            ctx.shadowBlur = 0;
            
            // Nom du champion avec effet 3D
            ctx.font = 'bold 35px Arial';  // 30 ‚Üí 35
            // Ombre du texte
            ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';  // 0.3 ‚Üí 0.4
            ctx.textAlign = 'center';
            ctx.fillText(name.toUpperCase(), 2, -3);
            // Texte principal
            ctx.fillStyle = '#1a1a2e';
            ctx.fillText(name.toUpperCase(), 0, -5);
            
            // Score avec effet brillant
            ctx.font = 'bold 28px Arial';  // 24 ‚Üí 28
            ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
            ctx.fillText(`${score} pts`, 2, 30);
            ctx.fillStyle = '#ffffff';
            ctx.fillText(`${score} pts`, 0, 28);
            
            // √âtoiles d√©coratives
            ctx.fillStyle = '#FFD700';
            ctx.font = '22px Arial';  // 18 ‚Üí 22
            ctx.fillText('‚≠ê', -100, -15);
            ctx.fillText('‚≠ê', 65, -15);
            
            ctx.restore();
            
            return startY + h + 15;  // +15px padding
        },
        
        drawAnimatedTitle(ctx, startY, progress) {
            const w = this.CONFIG.WIDTH;
            
            ctx.globalAlpha = progress;
            
            // Effet glow n√©on rouge
            ctx.shadowBlur = 35;  // 30 ‚Üí 35
            ctx.shadowColor = 'rgba(220, 20, 60, 0.9)';
            
            // Texte avec d√©grad√©
            const textGrad = ctx.createLinearGradient(0, startY, 0, startY + 35);
            textGrad.addColorStop(0, '#FF0000');
            textGrad.addColorStop(0.5, '#DC143C');
            textGrad.addColorStop(1, '#8B0000');
            
            ctx.font = 'italic 900 34px Arial';  // 30 ‚Üí 34px
            ctx.fillStyle = textGrad;
            ctx.textAlign = 'center';
            ctx.fillText('√âCRASE LA CONCURRENCE', w / 2, startY + 28);
            
            // Outline blanc pour le contraste
            ctx.shadowBlur = 0;
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';  // 0.3 ‚Üí 0.4
            ctx.lineWidth = 1.5;  // 1 ‚Üí 1.5
            ctx.strokeText('√âCRASE LA CONCURRENCE', w / 2, startY + 28);
            
            ctx.globalAlpha = 1;
            
            return startY + 55;  // 45 ‚Üí 55 (+10px padding)
        },
        
        drawAnimatedNarrative(ctx, startY, narrative, progress) {
            const w = this.CONFIG.WIDTH;
            const fullText = narrative;
            const visibleLength = Math.floor(fullText.length * progress);
            const visibleText = fullText.substring(0, visibleLength);
            
            // Fond avec d√©grad√© subtil
            const bgHeight = 95;  // 80 ‚Üí 95px
            const bgGrad = ctx.createLinearGradient(0, startY, 0, startY + bgHeight);
            bgGrad.addColorStop(0, 'rgba(245, 245, 220, 0.5)');  // 0.3 ‚Üí 0.5
            bgGrad.addColorStop(1, 'rgba(255, 250, 240, 0.5)');
            ctx.fillStyle = bgGrad;
            ctx.fillRect(20, startY, w - 40, bgHeight);
            
            // Bordure dor√©e fine
            ctx.strokeStyle = 'rgba(184, 134, 11, 0.5)';  // 0.3 ‚Üí 0.5
            ctx.lineWidth = 2.5;  // 2 ‚Üí 2.5
            ctx.strokeRect(20, startY, w - 40, bgHeight);
            
            // Citation marks d√©coratives
            ctx.font = 'bold 45px Georgia';  // 40 ‚Üí 45
            ctx.fillStyle = 'rgba(184, 134, 11, 0.3)';  // 0.2 ‚Üí 0.3
            ctx.textAlign = 'left';
            ctx.fillText('"', 30, startY + 40);
            ctx.textAlign = 'right';
            ctx.fillText('"', w - 30, startY + 85);
            
            // Texte avec ombre l√©g√®re
            ctx.shadowBlur = 2;
            ctx.shadowColor = 'rgba(0, 0, 0, 0.15)';  // 0.1 ‚Üí 0.15
            ctx.shadowOffsetY = 1;
            
            ctx.font = 'italic 18px Georgia';  // 17 ‚Üí 18
            ctx.fillStyle = '#1a1a1a';  // Plus fonc√©
            ctx.textAlign = 'center';
            
            const words = visibleText.split(' ');
            let lines = [];
            let line = '';
            
            words.forEach(word => {
                const test = line + word + ' ';
                if (ctx.measureText(test).width > w - 70) {
                    lines.push(line.trim());
                    line = word + ' ';
                } else {
                    line = test;
                }
            });
            if (line) lines.push(line.trim());
            
            const lineHeight = 24;  // 22 ‚Üí 24
            const totalHeight = lines.length * lineHeight;
            const startLineY = startY + (bgHeight - totalHeight) / 2 + 15;
            
            lines.forEach((l, idx) => {
                ctx.fillText(l, w / 2, startLineY + (idx * lineHeight));
            });
            
            ctx.shadowBlur = 0;
            
            return startY + bgHeight + 25;  // 20 ‚Üí 25 (+5px padding)
        },
        
        drawAnimatedTempsForts(ctx, startY, ai, gameState, colors, progress) {
            const w = this.CONFIG.WIDTH;
            
            // Header avec d√©grad√© premium
            const headerGrad = ctx.createLinearGradient(0, startY, 0, startY + 40);  // 35 ‚Üí 40
            headerGrad.addColorStop(0, colors.primary);
            headerGrad.addColorStop(1, '#0f0f1e');
            ctx.fillStyle = headerGrad;
            ctx.fillRect(15, startY, w - 30, 40);
            
            // Glow sur header
            ctx.shadowBlur = 18;  // 15 ‚Üí 18
            ctx.shadowColor = 'rgba(255, 215, 0, 0.4)';  // 0.3 ‚Üí 0.4
            ctx.font = 'bold 20px Arial';  // 18 ‚Üí 20
            ctx.fillStyle = '#FFD700';
            ctx.textAlign = 'center';
            ctx.fillText('‚≠ê LES TEMPS FORTS ‚≠ê', w / 2, startY + 26);
            ctx.shadowBlur = 0;
            
            startY += 45;  // 40 ‚Üí 45
            
            const items = [
                { icon: 'üî•', label: 'MOMENT FEU', text: ai.bestRound.player, score: `${ai.bestRound.score} pts`, color: '#FF4500' },
                { icon: 'üéØ', label: 'EXPLOIT #2', text: ai.secondBestRound.player, score: `${ai.secondBestRound.score} pts`, color: '#1E90FF' },
                { icon: '‚ö°', label: 'S√âRIE', text: ai.bestStreak.count > 1 ? `${ai.bestStreak.player}` : `${gameState.history.length} manches`, score: ai.bestStreak.count > 1 ? `${ai.bestStreak.count} victoires` : 'Match √©quilibr√©', color: '#FFD700' }
            ];
            
            const visibleItems = Math.floor(items.length * progress);
            const itemHeight = 85;  // 70 ‚Üí 85px
            
            for (let i = 0; i < visibleItems; i++) {
                const item = items[i];
                const itemProgress = Math.max(0, Math.min(1, (progress * items.length) - i));
                const scale = this.easeOutBack(itemProgress);
                const itemY = startY + (i * itemHeight);
                
                ctx.save();
                const centerX = w / 2;
                const centerY = itemY + 35;
                ctx.translate(centerX, centerY);
                ctx.scale(scale, scale);
                
                // Ombre port√©e de la carte
                ctx.shadowBlur = 20;  // R√©duit de 22
                ctx.shadowColor = 'rgba(0, 0, 0, 0.25)';  // R√©duit de 0.35
                ctx.shadowOffsetY = 5;  // R√©duit de 6
                
                // Fond de carte avec d√©grad√©
                const cardGrad = ctx.createLinearGradient(0, -30, 0, 30);
                cardGrad.addColorStop(0, '#ffffff');
                cardGrad.addColorStop(1, '#f5f5f5');
                ctx.fillStyle = cardGrad;
                ctx.fillRect(-230, -30, 460, 65);
                
                // Bordure color√©e √† gauche
                ctx.fillStyle = item.color;
                ctx.fillRect(-230, -30, 7, 65);
                
                // RESET COMPLET de tous les shadows
                ctx.shadowBlur = 0;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;
                
                // Ic√¥ne SANS glow (pour √©viter effet double)
                ctx.font = '32px Arial';
                ctx.textAlign = 'left';
                ctx.fillText(item.icon, -215, 8);
                
                // Label (SANS shadow)
                ctx.font = 'bold 17px Arial';
                ctx.fillStyle = item.color;
                ctx.fillText(item.label, -172, -8);
                
                // Nom (SANS shadow)
                ctx.font = 'bold 16px Arial';
                ctx.fillStyle = '#1a1a1a';
                ctx.fillText(item.text, -172, 12);
                
                // Score (SANS shadow)
                ctx.font = 'bold 16px Arial';
                ctx.fillStyle = item.color;
                ctx.fillText(item.score, -172, 30);
                
                // Badge √† droite
                ctx.fillStyle = item.color;
                ctx.globalAlpha = 0.12;
                ctx.beginPath();
                ctx.arc(205, 0, 22, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
                
                ctx.restore();
            }
            
            return startY + (items.length * itemHeight) + 20;  // +20px padding
        },
        
        drawAnimatedStats(ctx, startY, ai, gameState, colors, progress) {
            const w = this.CONFIG.WIDTH;
            
            // Header avec d√©grad√©
            const headerGrad = ctx.createLinearGradient(0, startY, 0, startY + 40);  // 35 ‚Üí 40
            headerGrad.addColorStop(0, colors.primary);
            headerGrad.addColorStop(1, '#0f0f1e');
            ctx.fillStyle = headerGrad;
            ctx.fillRect(15, startY, w - 30, 40);
            
            ctx.shadowBlur = 18;  // 15 ‚Üí 18
            ctx.shadowColor = 'rgba(100, 149, 237, 0.6)';  // 0.5 ‚Üí 0.6
            ctx.font = 'bold 20px Arial';  // 18 ‚Üí 20
            ctx.fillStyle = '#6495ED';
            ctx.textAlign = 'center';
            ctx.fillText('üìä LES STATS üìä', w / 2, startY + 26);
            ctx.shadowBlur = 0;
            
            startY += 45;  // 40 ‚Üí 45
            
            const frameHeight = 250;  // 180 ‚Üí 250px CRUCIAL !
            
            // Fond de la zone stats avec d√©grad√©
            const bgGrad = ctx.createLinearGradient(0, startY, 0, startY + frameHeight);
            bgGrad.addColorStop(0, '#f8f8f8');
            bgGrad.addColorStop(1, '#ffffff');
            ctx.fillStyle = bgGrad;
            ctx.fillRect(15, startY, w - 30, frameHeight);
            
            // Bordure
            ctx.strokeStyle = '#ccc';  // Plus visible
            ctx.lineWidth = 2.5;  // 2 ‚Üí 2.5
            ctx.strokeRect(15, startY, w - 30, frameHeight);
            
            let y = startY + 30;  // 25 ‚Üí 30
            
            // Taux victoire avec barre anim√©e
            if (ai.cast.precision && ai.cast.precision.length > 0) {
                const topPlayer = ai.cast.precision[0];
                
                ctx.font = '17px Arial';  // 15 ‚Üí 17
                ctx.fillStyle = '#1a1a1a';  // Plus fonc√©
                ctx.textAlign = 'left';
                ctx.fillText(`üéØ Taux de victoire : ${topPlayer.name}`, 30, y);
                y += 28;  // 25 ‚Üí 28
                
                const barWidth = w - 60;
                const filledWidth = barWidth * (topPlayer.value / 100) * progress;
                
                // Barre background avec ombre int√©rieure
                ctx.fillStyle = '#e8e8e8';
                ctx.fillRect(30, y, barWidth, 24);  // 20 ‚Üí 24 plus haute
                ctx.strokeStyle = '#ccc';
                ctx.lineWidth = 1;
                ctx.strokeRect(30, y, barWidth, 24);
                
                // Barre remplie avec d√©grad√© anim√©
                const barGradient = ctx.createLinearGradient(30, y, 30 + filledWidth, y);
                barGradient.addColorStop(0, '#4CAF50');
                barGradient.addColorStop(0.5, '#45a049');
                barGradient.addColorStop(1, '#66BB6A');
                ctx.fillStyle = barGradient;
                ctx.fillRect(30, y, filledWidth, 24);
                
                // Effet de brillance sur la barre
                const shineGrad = ctx.createLinearGradient(30, y, 30, y + 24);
                shineGrad.addColorStop(0, 'rgba(255,255,255,0.3)');
                shineGrad.addColorStop(0.5, 'rgba(255,255,255,0)');
                shineGrad.addColorStop(1, 'rgba(0,0,0,0.1)');
                ctx.fillStyle = shineGrad;
                ctx.fillRect(30, y, filledWidth, 24);
                
                // Pourcentage avec effet digital
                const displayValue = Math.floor(topPlayer.value * progress);
                ctx.font = 'bold 18px "Courier New", monospace';  // 16 ‚Üí 18
                ctx.fillStyle = '#fff';
                ctx.textAlign = 'center';
                ctx.shadowBlur = 4;  // 3 ‚Üí 4
                ctx.shadowColor = 'rgba(0,0,0,0.6)';
                ctx.fillText(`${displayValue}%`, w / 2, y + 17);
                ctx.shadowBlur = 0;
                
                y += 40;  // 35 ‚Üí 40
            }
            
            // Meilleure manche avec badge
            ctx.save();
            ctx.font = '17px Arial';
            ctx.fillStyle = '#1a1a1a';
            ctx.textAlign = 'left';
            ctx.fillText(`üî• Meilleure manche : ${ai.bestRound.player}`, 30, y);
            y += 28;
            
            // Score avec effet compteur digital (SANS glow pour √©viter double)
            const displayBest = Math.floor(ai.bestRound.score * progress);
            ctx.font = 'bold 32px "Courier New", monospace';
            
            // D√©grad√© sur le chiffre (SANS shadowBlur)
            const scoreGrad = ctx.createLinearGradient(0, y - 22, 0, y);
            scoreGrad.addColorStop(0, colors.accent);
            scoreGrad.addColorStop(1, colors.primary);
            ctx.fillStyle = scoreGrad;
            ctx.fillText(`${displayBest} pts`, 30, y);
            ctx.restore();
            
            y += 38;
            
            // √âcart final avec ic√¥ne
            ctx.font = '17px Arial';  // 15 ‚Üí 17
            ctx.fillStyle = '#1a1a1a';
            ctx.textAlign = 'left';
            const displayGap = Math.floor(ai.finalGap * progress);
            ctx.fillText(`üéØ √âcart final : ${displayGap} pts`, 30, y);
            y += 30;  // 25 ‚Üí 30
            
            // Manches avec badge
            const displayManches = Math.floor(gameState.history.length * progress);
            ctx.fillText(`üìà Total manches : ${displayManches}`, 30, y);
            
            // Badge stats supprim√© (plus de "PREMIUM")
            
            return startY + frameHeight + 30;
        },
        
        drawPaperTexture(ctx) {
            // Texture de fond plus sophistiqu√©e
            ctx.fillStyle = 'rgba(139, 119, 101, 0.015)';
            for (let i = 0; i < 400; i++) {
                ctx.fillRect(
                    Math.random() * this.CONFIG.WIDTH,
                    Math.random() * this.CONFIG.HEIGHT,
                    Math.random() * 2,
                    Math.random() * 2
                );
            }
            
            // Vignette subtile sur les bords
            const vignetteGrad = ctx.createRadialGradient(
                this.CONFIG.WIDTH / 2, this.CONFIG.HEIGHT / 2, 0,
                this.CONFIG.WIDTH / 2, this.CONFIG.HEIGHT / 2, this.CONFIG.WIDTH * 0.7
            );
            vignetteGrad.addColorStop(0, 'rgba(0,0,0,0)');
            vignetteGrad.addColorStop(1, 'rgba(0,0,0,0.03)');
            ctx.fillStyle = vignetteGrad;
            ctx.fillRect(0, 0, this.CONFIG.WIDTH, this.CONFIG.HEIGHT);
        },
        
        drawWatermark(ctx) {
            const w = 
    this.CONFIG.WIDTH;
            const h = this.CONFIG.HEIGHT;
            
            // Badge premium en bas centr√©
            ctx.save();
            ctx.translate(w / 2, h - 35);
            
            // Fond du badge avec ombre
            ctx.shadowBlur = 10;
            ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
            
            const badgeGrad = ctx.createLinearGradient(-55, -12, 55, 12);
            badgeGrad.addColorStop(0, 'rgba(30, 30, 46, 0.9)');
            badgeGrad.addColorStop(1, 'rgba(15, 15, 30, 0.9)');
            ctx.fillStyle = badgeGrad;
            ctx.fillRect(-55, -12, 110, 24);
            
            ctx.shadowBlur = 0;
            
            // Bordure dor√©e
            ctx.strokeStyle = 'rgba(255, 215, 0, 0.7)';
            ctx.lineWidth = 1.5;
            ctx.strokeRect(-55, -12, 110, 24);
            
            // Texte avec glow
            ctx.shadowBlur = 8;
            ctx.shadowColor = 'rgba(255, 215, 0, 0.7)';
            ctx.font = 'bold 13px Arial';
            ctx.fillStyle = '#FFD700';
            ctx.textAlign = 'center';
            ctx.fillText('ScoreMaster‚Ñ¢', 0, 4);
            
            ctx.restore();
        },
        
        easeOutCubic(t) {
            return 1 - Math.pow(1 - t, 3);
        },
        
        easeOutBounce(t) {
            const n1 = 7.5625;
            const d1 = 2.75;
            if (t < 1 / d1) return n1 * t * t;
            else if (t < 2 / d1) return n1 * (t -= 1.5 / d1) * t + 0.75;
            else if (t < 2.5 / d1) return n1 * (t -= 2.25 / d1) * t + 0.9375;
            else return n1 * (t -= 2.625 / d1) * t + 0.984375;
        },
        
        easeOutBack(t) {
            const c1 = 1.70158;
            const c3 = c1 + 1;
            return 1 + c3 * Math.pow(t - 1, 3) + c1 * Math.pow(t - 1, 2);
        },
        
        downloadGif(blob) {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `ScoreMaster_Recap_${Date.now()}.gif`;
            a.click();
            URL.revokeObjectURL(url);
        }
    };
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => {
            app.init();
            PWA.init();
        });
    } else {
        app.init();
        PWA.init();
    }
</script>
<!-- Console de d√©bogage -->
<div id="debug-console" style="position: fixed; bottom: 0; left: 0; right: 0; max-height: 200px; background: #000; color: #0f0; font-family: monospace; font-size: 11px; padding: 10px; overflow-y: auto; z-index: 10000; display: none; border-top: 2px solid #0f0;">
    <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
        <strong>üîß DEBUG CONSOLE</strong>
        <button onclick="document.getElementById('debug-console').style.display='none'" style="background: #f00; color: #fff; border: none; padding: 2px 8px; cursor: pointer;">‚úï</button>
    </div>
    <div id="debug-log"></div>
</div>

</body>
</html>
