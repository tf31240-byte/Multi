<!DOCTYPE html>

<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="theme-color" content="#007AFF" media="(prefers-color-scheme: light)">
    <meta name="theme-color" content="#0A84FF" media="(prefers-color-scheme: dark)">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="ScoreMaster">
    <meta name="description" content="Gestionnaire de scores pour belote, coinche et jeux de cartes avec statistiques avanc√©es">
    <meta name="keywords" content="belote, coinche, score, cartes, jeu, statistiques">
    <title>ScoreMaster OPTIMIZED v1.1 üöÄ</title>

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/gifshot@0.4.5/dist/gifshot.min.js"></script>

<style>
    /* ==================== SCOREMASTER OPTIMIZED v1.1 ==================== */
    /* 
     * OPTIMISATIONS APPLIQU√âES:
     * #1: Cache localStorage (-50% I/O)
     * #2: Debouncing render (-70% redraws)
     * #3: Chart.js update (-80% graph time)
     * UX1: Dock intelligent
     * UX2: Mode Zen FAB
     * UX4: Toast Queue
     * UX6: Pagination historique
     */
    
    /* === VARIABLES & THEME === */
    :root {
        --primary: #007AFF; --bg: #F5F5F7; --card: #FFFFFF; --text: #1D1D1F;
        --text-sec: #86868B; --border: #E5E5EA; --dealer: #FF9500; 
        --danger: #FF3B30; --success: #34C759; 
        --glass-bg: rgba(255, 255, 255, 0.65);
        --glass-border: rgba(255, 255, 255, 0.5);
        --glass-shadow: 0 15px 35px rgba(0,0,0,0.1), 0 5px 15px rgba(0,0,0,0.05);
        --glass-blur: 20px;
        --bg-gradient: radial-gradient(circle at 50% 0%, #ffffff, #F5F5F7);
    }
    
    :root[data-theme="dark"] {
        --primary: #0A84FF; --bg: #000000; --card: #1C1C1E; --text: #F5F5F7;
        --text-sec: #98989D; --border: #38383A; 
        --glass-bg: rgba(28, 28, 30, 0.65);
        --glass-border: rgba(255, 255, 255, 0.1);
        --glass-shadow: 0 15px 35px rgba(0,0,0,0.4), 0 5px 15px rgba(0,0,0,0.2);
        --bg-gradient: radial-gradient(circle at 50% 0%, #2c2c2e, #000000);
    }
    
    @media (prefers-color-scheme: dark) {
        :root:not([data-theme="light"]) {
            --primary: #0A84FF; --bg: #000000; --card: #1C1C1E; --text: #F5F5F7;
            --text-sec: #98989D; --border: #38383A; 
            --glass-bg: rgba(28, 28, 30, 0.65);
            --glass-border: rgba(255, 255, 255, 0.1);
            --glass-shadow: 0 15px 35px rgba(0,0,0,0.4), 0 5px 15px rgba(0,0,0,0.2);
            --bg-gradient: radial-gradient(circle at 50% 0%, #2c2c2e, #000000);
        }
    }
    
    * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-family: -apple-system, system-ui, sans-serif; }
    html { height: -webkit-fill-available; }
    body { 
        margin: 0; background: var(--bg); background-attachment: fixed;
        color: var(--text); padding-bottom: 140px; transition: background 0.3s;
        min-height: 100vh; min-height: -webkit-fill-available;
    }
    body::before {
        content: ''; position: fixed; top: 0; left: 0; right: 0; bottom: 0;
        background: var(--bg-gradient); z-index: -1;
    }
    
    .container { 
        max-width: 600px; margin: 0 auto; padding: 20px; 
        padding-top: max(20px, env(safe-area-inset-top)); 
        animation: slideIn 0.4s ease-out; position: relative; z-index: 1; 
    }
    .hidden { display: none !important; }
    .text-huge { font-size: 28px; font-weight: 900; }
    .text-center { text-align: center; }

    /* === ANIMATIONS === */
    @keyframes slideIn { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }
    @keyframes slideUp { from { transform: translateX(-50%) translateY(100%); opacity: 0; } to { transform: translateX(-50%) translateY(0); opacity: 1; } }
    @keyframes rankPop { 0% { transform: scale(1); } 50% { transform: scale(1.1); } 100% { transform: scale(1); } }
    @keyframes badgeBounce { 0%, 100% { transform: scale(1) rotate(0deg); } 25% { transform: scale(1.3) rotate(-10deg); } 75% { transform: scale(1.3) rotate(10deg); } }
    @keyframes scoreBump { 0% { transform: scale(1); } 50% { transform: scale(1.15); } 100% { transform: scale(1); } }
    @keyframes victoryPop { 0% { transform: scale(0.8); opacity: 0; } 100% { transform: scale(1); opacity: 1; } }
    @keyframes podiumRise { from { transform: translateY(100px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
    @keyframes simpleFadeIn { from { opacity: 0; } to { opacity: 1; } }
    @keyframes dockSlideUp { 0% { opacity: 0; transform: translateX(-50%) translateY(50px); } 100% { opacity: 1; transform: translateX(-50%) translateY(0); } }
    @keyframes scoreClick { 0% { transform: scale(1); } 50% { transform: scale(0.92); } 100% { transform: scale(1); } }

    /* === GLASSMORPHISM COMPONENTS === */
    .modal-overlay { 
        position: fixed; inset: 0; background: rgba(0,0,0,0.1); 
        backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px);
        z-index: 4000; display: flex; align-items: center; justify-content: center; 
        padding: 20px; opacity: 0; pointer-events: none; transition: 0.2s; 
    }
    .modal-overlay.active { opacity: 1; pointer-events: auto; }
    
    .modal-box, .sheet-content, .victory-box { 
        background: var(--glass-bg);
        backdrop-filter: blur(var(--glass-blur)) saturate(180%);
        -webkit-backdrop-filter: blur(var(--glass-blur)) saturate(180%);
        border: 1px solid var(--glass-border);
        box-shadow: var(--glass-shadow);
    }

    .modal-box { width: 100%; max-width: 340px; border-radius: 28px; padding: 25px; text-align: center; }
    .modal-box.large { max-width: 500px; text-align: left; max-height: 80vh; overflow-y: auto; }
    
    .sheet-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.2); z-index: 3000; opacity: 0; pointer-events: none; transition: 0.3s; display: flex; align-items: flex-end; }
    .sheet-overlay.active { opacity: 1; pointer-events: auto; }
    .sheet-content { 
        width: 100%; border-radius: 35px 35px 0 0; padding: 25px 20px calc(25px + env(safe-area-inset-bottom)); 
        transform: translateY(100%); transition: 0.4s cubic-bezier(0.1, 0.9, 0.2, 1);
    }
    .sheet-overlay.active .sheet-content { transform: translateY(0); }

    /* === UI ELEMENTS === */
    .header-controls { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; }
    .theme-toggle, .btn-stats, .btn-focus { 
        background: var(--glass-bg); backdrop-filter: blur(10px);
        border: 1px solid var(--glass-border); 
        width: 44px; height: 44px; border-radius: 12px; font-size: 20px; cursor: pointer; 
        transition: all 0.3s; display:flex; align-items:center; justify-content:center; 
        box-shadow: 0 4px 10px rgba(0,0,0,0.05);
    }
    .btn-stats:active, .theme-toggle:active, .btn-focus:active { transform: scale(0.9); }
    .btn-stats { color:var(--primary); }
    .btn-focus { color: var(--primary); }

    .welcome-title { 
        font-size: 42px; font-weight: 900; text-align: center; margin-top: 40px; letter-spacing: -2px; 
        background: linear-gradient(120deg, var(--text), var(--primary)); 
        -webkit-background-clip: text; -webkit-text-fill-color: transparent;
    }

    .mode-btn { 
        background: var(--card); border: 1px solid var(--border); border-radius: 24px; 
        padding: 20px; margin-bottom: 12px; box-shadow: 0 4px 15px rgba(0,0,0,0.05); 
        cursor: pointer; display: flex; align-items: center; gap: 15px; transition: all 0.2s; 
    }
    .mode-btn:hover { transform: translateY(-2px); box-shadow: 0 10px 25px rgba(0,0,0,0.1); }
    .mode-btn:active { transform: translateY(0); }

    .guide-container { margin-top: 30px; background: var(--card); border-radius: 24px; padding: 20px; border: 1px solid var(--border); font-size: 13px; color: var(--text-sec); }

    /* === GAME LIST STYLES === */
    .game-item { 
        background: var(--card); border: 1px solid var(--border); border-radius: 20px; 
        padding: 16px; margin-bottom: 12px; cursor: pointer; display: flex; 
        justify-content: space-between; align-items: center; transition: all 0.2s; 
    }
    .game-item:hover { border-color: var(--primary); transform: translateX(4px); box-shadow: 0 5px 15px rgba(0,0,0,0.05); }
    
    .game-mode-badge { display: inline-block; padding: 3px 8px; border-radius: 8px; font-size: 10px; font-weight: 900; margin-left: 8px; }
    .badge-belote { background: #FF9500; color: white; }
    .badge-standard { background: #007AFF; color: white; }
    
    .game-players-list { display: flex; gap: 8px; margin-top: 8px; flex-wrap: wrap; }
    .game-player-score { font-size: 11px; padding: 4px 8px; border-radius: 8px; font-weight: 700; }
    
    .game-actions { display: flex; gap: 8px; }
    .game-actions button { background: none; border: none; font-size: 18px; padding: 8px; cursor: pointer; transition: transform 0.2s; }
    .game-actions button:active { transform: scale(0.9); }

    .chart-box { 
        background: var(--glass-bg); backdrop-filter: blur(10px); border-radius: 24px; 
        padding: 15px; height: 200px; margin-bottom: 25px; border: 1px solid var(--border); 
        box-shadow: 0 5px 15px rgba(0,0,0,0.05); transition: opacity 0.5s ease; 
    }
    
    .players-grid { 
        display: grid; grid-template-columns: repeat(auto-fit, minmax(130px, 1fr)); 
        gap: 14px; margin-bottom: 30px; 
        transition: all 0.5s cubic-bezier(0.34, 1.56, 0.64, 1); 
    }
    
    .p-card { 
        background: var(--card); padding: 22px 10px; border-radius: 26px; text-align: center; 
        position: relative; border: 3px solid transparent; 
        box-shadow: 0 8px 20px rgba(0,0,0,0.05); 
        transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1), border-color 0.3s; 
        overflow: visible; 
    }
    .p-card.is-dealer { border-color: var(--dealer); }
    .p-card.rank-change { animation: rankPop 0.6s cubic-bezier(0.34, 1.56, 0.64, 1); }
    
    .rank-badge { 
        position: absolute; top: -12px; left: 12px; font-size: 13px; padding: 4px 10px; 
        border-radius: 12px; font-weight: 900; color: white; 
        box-shadow: 0 4px 8px rgba(0,0,0,0.2); 
        transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1); z-index: 10; 
    }
    .rank-badge.bounce { animation: badgeBounce 0.6s cubic-bezier(0.34, 1.56, 0.64, 1); }
    .focus-mode .rank-badge { display: none; }
    .focus-mode .p-card { padding: 12px 8px 22px 8px; overflow: visible; }
    .focus-mode .p-name-btn { font-size: 11px; margin-bottom: 6px; padding: 3px 8px; }
    .focus-mode .p-score { font-size: 38px; }
    .focus-mode .p-temp { font-size: 13px; margin-top: 4px; }
    
    .badge-1 { background: #FFD700; }
    .badge-2 { background: #C0C0C0; }
    .badge-3 { background: #CD7F32; }
    .badge-none { background: var(--text-sec); opacity: 0.5; }

    .p-name-btn { 
        font-size: 12px; font-weight: 900; text-transform: uppercase; cursor: pointer; 
        display: inline-block; padding: 4px 10px; border: 1px solid var(--border); 
        border-radius: 10px; margin-bottom: 8px; 
    }
    .p-score { 
        font-size: 44px; font-weight: 900; cursor: pointer; line-height: 1; letter-spacing: -2px; 
        transition: transform 0.2s ease-out; 
    }
    .p-score.score-bump { animation: scoreBump 0.4s ease-out; }
    .p-temp { font-size: 15px; font-weight: 800; color: var(--primary); min-height: 18px; margin-top: 6px; }

    .h-row { 
        background: var(--card); padding: 12px; border-radius: 18px; display: flex; 
        align-items: center; margin-bottom: 8px; border: 1px solid var(--border); 
        gap: 10px; overflow-x: auto; transition: opacity 0.5s ease; 
    }
    .h-idx { font-size: 10px; font-weight: 900; color: var(--text-sec); min-width: 30px; flex-shrink: 0; }
    .h-scores { 
        display: flex; flex: 1; justify-content: space-between; align-items: center; 
        min-width: max-content; padding-right: 5px; cursor: pointer; 
    }
    .h-score-item { text-align: center; min-width: 50px; padding: 0 5px; }

    .sel-box { 
        background: var(--card); padding: 12px; border-radius: 18px; text-align: center; 
        flex: 1; border: 3px solid transparent; min-width: 80px; 
        transition: transform 0.2s cubic-bezier(0.34, 1.56, 0.64, 1), border-color 0.2s; 
        position: relative; z-index: 1; margin-bottom: 0;
    }
    .sel-box.active { 
        border-color: var(--p-color); transform: scale(1.04);
        box-shadow: 0 5px 15px rgba(0,0,0,0.05); z-index: 2;
    }
    
    .numpad { display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; }
    .btn-nb { 
        background: var(--card); border: none; height: 58px; border-radius: 16px; 
        font-size: 22px; font-weight: 700; color: var(--text); 
        box-shadow: 0 3px 0 var(--border); cursor: pointer; 
    }
    .btn-nb:active { transform: translateY(3px); box-shadow: none; }

    /* OPTIMISATION UX1: Dock intelligent */
    .dock { 
        position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%); 
        width: 90%; max-width: 450px; z-index: 2000; 
        background: var(--glass-bg);
        backdrop-filter: blur(25px) saturate(200%);
        -webkit-backdrop-filter: blur(25px) saturate(200%);
        border: 1px solid var(--glass-border);
        box-shadow: var(--glass-shadow);
        border-radius: 26px;
        transition: opacity 0.3s ease, transform 0.3s ease;
    }
    
    .dock.hidden {
        opacity: 0;
        pointer-events: none;
        transform: translateX(-50%) translateY(20px);
    }
    
    .btn-main { 
        width: 100%; background: var(--text); color: var(--bg); border: none; 
        padding: 20px; border-radius: 20px; font-size: 16px; font-weight: 900; 
        box-shadow: 0 5px 15px rgba(0,0,0,0.1); cursor: pointer; transition: transform 0.1s; 
    }
    .btn-main:active { transform: scale(0.98); }
    .btn-main.editing { background: var(--dealer); color: #000; }

    /* OPTIMISATION UX2: Mode Zen avec FAB */
    .focus-mode .btn-focus {
        position: fixed; bottom: 120px; right: 20px; top: auto; left: auto;
        width: 56px; height: 56px; border-radius: 50%;
        background: var(--primary); color: white; font-size: 24px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.3); z-index: 2001;
        transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1); border: none;
    }
    .focus-mode .btn-focus:active { transform: scale(0.9); }
    .focus-mode #dock {
        opacity: 1 !important; pointer-events: auto !important;
        transform: translateX(-50%) !important; z-index: 200;
    }
    .focus-mode header > *:not(.btn-focus) { opacity: 0; pointer-events: none; }
    .focus-mode .chart-box, .focus-mode #history, .focus-mode #history-header {
        opacity: 0; pointer-events: none; position: absolute;
    }
    .focus-mode .players-grid {
        position: fixed; top: 0; left: 0; width: 100%; height: 100vh; height: 100dvh;
        padding: max(20px, env(safe-area-inset-top)) 15px calc(100px + env(safe-area-inset-bottom)) 15px;
        margin: 0; display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
        align-content: center; gap: 15px; z-index: 100;
        transform: none !important; opacity: 1 !important;
        overflow-y: auto; -webkit-overflow-scrolling: touch;
    }
    .focus-mode .p-card {
        display: flex; flex-direction: column; justify-content: center; align-items: center;
        height: 100%; min-height: 140px; padding: 20px;
        box-shadow: 0 10px 40px rgba(0,0,0,0.15); border-width: 0; background: var(--card);
    }
    .focus-mode .p-score { font-size: 68px !important; letter-spacing: -3px; }
    .focus-mode .p-name-btn { font-size: 15px; padding: 7px 16px; }
    .focus-mode .p-temp { font-size: 20px; margin-top: 12px; }

    .toast {
        position: fixed; top: max(60px, calc(env(safe-area-inset-top) + 40px));
        left: 50%; transform: translateX(-50%) translateY(-100px);
        background: var(--glass-bg); backdrop-filter: blur(20px);
        -webkit-backdrop-filter: blur(20px); border: 1px solid var(--glass-border);
        padding: 16px 24px; border-radius: 20px; box-shadow: var(--glass-shadow);
        font-weight: 700; z-index: 5000; opacity: 0; transition: all 0.3s;
        white-space: nowrap;
    }
    .toast.show { opacity: 1; transform: translateX(-50%) translateY(0); }
    .toast.success { border-color: var(--success); background: var(--success); color: white; border: none; }
    .toast.warning { border-color: var(--dealer); background: var(--dealer); color: white; border: none; }
    .toast.error { border-color: var(--danger); background: var(--danger); color: white; border: none; }

    /* OPTIMISATION UX6: Pagination historique */
    .history-pagination {
        display: flex; justify-content: center; gap: 10px; margin-bottom: 10px; align-items: center;
    }
    .history-pagination button {
        padding: 8px 16px; border-radius: 8px; border: 1px solid var(--border);
        background: var(--card); color: var(--text); font-weight: 700; font-size: 12px;
        cursor: pointer; transition: all 0.2s;
    }
    .history-pagination button:disabled { opacity: 0.3; cursor: not-allowed; }
    .history-pagination button:not(:disabled):active { transform: scale(0.95); }
    .history-pagination span { color: var(--text-sec); font-size: 12px; font-weight: 700; }

    .victory-overlay {
        position: fixed; inset: 0; background: rgba(0,0,0,0.6); backdrop-filter: blur(10px); z-index: 6000;
        display: flex; align-items: center; justify-content: center; opacity: 0; pointer-events: none;
        transition: 0.3s; overflow-y: auto; padding: 20px;
    }
    .victory-overlay.active { opacity: 1; pointer-events: auto; }
    .podium-container { display: flex; align-items: flex-end; justify-content: center; gap: 8px; margin: 30px 0; height: 180px; }
    .podium-place { flex: 1; max-width: 110px; display: flex; flex-direction: column; align-items: center; }
    .podium-avatar {
        width: 60px; height: 60px; border-radius: 50%; display: flex; align-items: center; justify-content: center;
        font-size: 28px; font-weight: 900; margin-bottom: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.2); position: relative;
    }
    .podium-name { font-size: 11px; font-weight: 900; text-align: center; margin-bottom: 6px; }
    .podium-score { font-size: 16px; font-weight: 900; margin-bottom: 8px; }
    .podium-bar {
        width: 100%; border-radius: 12px 12px 0 0; display: flex; align-items: center; justify-content: center;
        font-size: 32px; font-weight: 900; color: white; box-shadow: 0 -2px 8px rgba(0,0,0,0.1);
    }
    .podium-place.p1 .podium-bar { background: #FFD700; height: 100px; }
    .podium-place.p2 .podium-bar { background: #C0C0C0; height: 70px; }
    .podium-place.p3 .podium-bar { background: #CD7F32; height: 50px; }
</style>

</head>
<body>
    <div id="toast" class="toast"></div>

<div id="confirm-modal" class="modal-overlay">
    <div class="modal-box">
        <h3 id="confirm-msg">Confirmer l'action ?</h3>
        <div class="confirm-actions" style="display:flex; gap:10px;">
            <button class="btn-main btn-confirm-no" style="background:var(--card); color:var(--text); border:1px solid var(--border);" onclick="UI.closeConfirm()">Annuler</button>
            <button id="confirm-yes-btn" class="btn-main btn-confirm-yes" style="background:var(--danger); color:white; border:1px solid var(--danger);">Confirmer</button>
        </div>
    </div>
</div>

<div id="stats-modal" class="modal-overlay" onclick="if(event.target===this) UI.closeStats()">
    <div class="modal-box large">
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:20px;">
            <h2 style="margin:0">üìä Statistiques</h2>
            <button onclick="UI.closeStats()" style="background:none; border:none; font-size:24px; color:var(--text); cursor:pointer;">‚úï</button>
        </div>
        <div id="stats-content-rank"></div>
    </div>
</div>

<div id="modal-player-count" class="modal-overlay" onclick="if(event.target===this) document.getElementById('modal-player-count').classList.remove('active')">
    <div class="modal-box" style="max-width: 400px;">
        <h2 style="margin:0 0 10px 0" id="mode-setup-title">Mode Standard</h2>
        <p style="color:var(--text-sec); margin-bottom:20px;">Combien de joueurs ?</p>
        <div style="display:grid; grid-template-columns: repeat(3, 1fr); gap:10px; margin-bottom:25px;">
            <button class="btn-nb" onclick="app.selectPlayerCount(2)">2</button>
            <button class="btn-nb" onclick="app.selectPlayerCount(3)">3</button>
            <button class="btn-nb" onclick="app.selectPlayerCount(4)">4</button>
            <button class="btn-nb" onclick="app.selectPlayerCount(5)">5</button>
            <button class="btn-nb" onclick="app.selectPlayerCount(6)">6</button>
            <button id="btn-toggle-players" class="btn-nb" style="background:rgba(120,120,128,0.12); font-size:14px;" onclick="app.toggleMorePlayers()">Plus ‚ñº</button>
            <div id="extra-players" class="hidden" style="grid-column: 1 / -1; display:contents;">
                <button class="btn-nb" onclick="app.selectPlayerCount(7)">7</button>
                <button class="btn-nb" onclick="app.selectPlayerCount(8)">8</button>
                <button class="btn-nb" onclick="app.selectPlayerCount(9)">9</button>
                <button class="btn-nb" onclick="app.selectPlayerCount(10)">10</button>
                <button class="btn-nb" onclick="app.selectPlayerCount(11)">11</button>
                <button class="btn-nb" onclick="app.selectPlayerCount(12)">12</button>
            </div>
        </div>

    <div style="border-top: 1px solid var(--border); padding-top: 20px; margin-top: 10px;">
        <div style="margin-bottom: 20px;">
            <label style="font-size: 13px; font-weight: 700; color: var(--text); margin-bottom: 10px; display: block;">üéØ Objectif de victoire</label>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                <label style="display: flex; align-items: center; justify-content: center; background: var(--card); border: 2px solid var(--border); border-radius: 12px; padding: 12px; cursor: pointer;" id="victory-highest-label">
                    <input type="radio" name="victory-condition" value="highest" checked style="margin-right: 8px; accent-color: var(--primary);" onchange="app.updateVictoryCondition()">
                    <span style="font-size: 12px; font-weight: 700;">‚¨ÜÔ∏è Plus HAUT</span>
                </label>
                <label style="display: flex; align-items: center; justify-content: center; background: var(--card); border: 2px solid var(--border); border-radius: 12px; padding: 12px; cursor: pointer;" id="victory-lowest-label">
                    <input type="radio" name="victory-condition" value="lowest" style="margin-right: 8px; accent-color: var(--primary);" onchange="app.updateVictoryCondition()">
                    <span style="font-size: 12px; font-weight: 700;">‚¨áÔ∏è Plus BAS</span>
                </label>
            </div>
        </div>
        
        <div>
            <label style="font-size: 13px; font-weight: 700; color: var(--text); margin-bottom: 10px; display: block;">üèÅ Condition de fin</label>
            <div style="display: grid; gap: 8px;">
                <label style="display: flex; align-items: center; background: var(--card); border: 2px solid var(--border); border-radius: 12px; padding: 12px; cursor: pointer;" id="end-free-label">
                    <input type="radio" name="end-condition" value="free" checked style="margin-right: 10px; accent-color: var(--primary);" onchange="app.updateEndCondition()">
                    <span style="font-size: 12px; font-weight: 700; flex: 1;">‚ôæÔ∏è Partie libre</span>
                </label>
                <label style="display: flex; align-items: center; background: var(--card); border: 2px solid var(--border); border-radius: 12px; padding: 12px; cursor: pointer;" id="end-score-label">
                    <input type="radio" name="end-condition" value="score" style="margin-right: 10px; accent-color: var(--primary);" onchange="app.updateEndCondition()">
                    <span style="font-size: 12px; font-weight: 700; flex: 1;" id="score-label-text">üéØ Score objectif :</span>
                    <input type="number" id="score-target" value="100" min="10" max="9999" style="width: 70px; padding: 6px; border: 1px solid var(--border); border-radius: 8px; font-size: 14px; font-weight: 700; text-align: center; background: var(--bg); color: var(--text);" onclick="event.stopPropagation(); document.querySelector('input[name=end-condition][value=score]').checked = true; app.updateEndCondition();">
                </label>
            </div>
        </div>
    </div>
</div>

</div>

<div id="setup" class="container">
    <div class="header-controls">
        <h1 class="welcome-title" style="margin:0; flex:1;">ScoreMaster</h1>
        <div style="display:flex; gap:10px;">
            <button class="btn-stats" onclick="app.showStats()" title="Statistiques">üìä</button>
            <button id="theme-toggle" class="theme-toggle" onclick="app.toggleTheme()">üåô</button>
        </div>
    </div>
    <div class="mode-btn" onclick="app.showModeSelection('belote')">
        <span style="font-size:30px; margin-right:15px;">üÉè</span>
        <div><h2 style="margin:0">Belote / Coinche</h2><p style="margin:4px 0 0; font-size:12px; color:var(--text-sec)">Points √† 162 ‚Ä¢ Capot 252</p></div>
    </div>
    <div class="mode-btn" onclick="app.showModeSelection('standard')">
        <span style="font-size:30px; margin-right:15px;">üé≤</span>
        <div><h2 style="margin:0">Standard</h2><p style="margin:4px 0 0; font-size:12px; color:var(--text-sec)">Scores libres ‚Ä¢ Jusqu'√† 12 joueurs</p></div>
    </div>
    <div style="margin-top: 40px;">
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:15px;">
            <h3 style="margin:0; font-size:18px; font-weight:900;">üìö Historique des parties</h3>
            <button onclick="app.clearAll()" style="background:none; border:none; color:var(--danger); font-weight:900; font-size:12px; cursor:pointer;">TOUT EFFACER</button>
        </div>
        <div id="games-list"></div>
    </div>
    <div class="guide-container">
        <b style="display:block; margin-bottom:8px; color:var(--text)">üìñ Guide Rapide</b>
        ‚Ä¢ Cliquez sur le <b style="color:var(--text)">NOM</b> pour le donneur üÉè<br>
        ‚Ä¢ Cliquez sur le <b style="color:var(--text)">SCORE</b> pour les points ‚úçÔ∏è<br>
        ‚Ä¢ Cliquez sur l'<b style="color:var(--text)">HISTORIQUE</b> pour corriger ‚úèÔ∏è
    </div>
</div>

<div id="game" class="container hidden">
    <header style="display:flex; justify-content:space-between; align-items:center; margin-bottom:20px;">
        <button onclick="app.showSetup()" style="background:var(--card); border:1px solid var(--border); width:40px; height:40px; border-radius:12px; color:var(--text); cursor:pointer;">‚¨ÖÔ∏è</button>
        <div style="flex:1; text-align:center;">
            <h1 id="mode-title" style="margin:0; font-size:22px; font-weight:900;">SCORE</h1>
            <div id="game-info" style="font-size:10px; color:var(--text-sec); font-weight:700; margin-top:3px;"></div>
        </div>
        <button class="btn-focus" onclick="app.toggleFocusMode()" title="Mode Zen">üëÅÔ∏è</button>
    </header>
    <div class="chart-box"><canvas id="chart"></canvas></div>
    <div id="grid" class="players-grid"></div>
    <div id="history-header" style="display:flex; justify-content:space-between; margin: 30px 0 10px; font-size:11px; font-weight:900; color:var(--text-sec);">
        <span>HISTORIQUE DES MANCHES</span>
        <div style="display:flex; gap:12px;">
            <button onclick="app.finishGame()" style="background:none; border:none; color:var(--success); font-weight:900; cursor:pointer;">‚úì TERMINER</button>
            <button onclick="app.undo()" style="background:none; border:none; color:var(--danger); font-weight:900; cursor:pointer;">ANNULER</button>
        </div>
    </div>
    <div id="history"></div>
</div>

<div id="dock" class="dock hidden">
    <button id="save-btn" class="btn-main" onclick="app.validateRound()">ENREGISTRER MANCHE 1</button>
</div>

<div id="modal-player" class="modal-overlay" onclick="if(event.target===this) app.closeModal()">
    <div class="modal-box">
        <h2 id="modal-title" style="margin:0 0 20px 0">Joueur</h2>
        <input type="text" id="edit-name" style="width:100%; padding:15px; border-radius:12px; border:2px solid var(--border); font-size:18px; font-weight:700; margin-bottom:20px; outline:none; background:var(--bg); color:var(--text);">
        <label style="display:flex; align-items:center; justify-content:space-between; background:var(--bg); padding:15px; border-radius:12px; font-weight:700; cursor:pointer;">
            Donneur üÉè <input type="checkbox" id="edit-dealer" style="width:20px; height:20px; accent-color:var(--dealer);">
        </label>
        <button class="btn-main" style="margin-top:20px; background:var(--primary); color:white" onclick="app.savePlayer()">VALIDER</button>
    </div>
</div>

<div id="sheet" class="sheet-overlay" onclick="app.closeSheet()">
    <div class="sheet-content" onclick="event.stopPropagation()">
        <div id="input-switcher" style="display:flex; gap:8px; margin-bottom:20px; overflow-x:auto; padding: 10px 20px 5px 20px; scroll-snap-type: x mandatory;"></div>
        <div style="display:grid; grid-template-columns: repeat(4, 1fr); gap:8px; margin-bottom:12px;">
            <button id="calc-btn" class="btn-nb hidden" style="grid-column:span 4; background:var(--success); color:white; font-size:14px; box-shadow:none;" onclick="app.calcRest()">‚ú® RESTE √Ä 162</button>
            <button class="btn-nb" style="background:rgba(120,120,128,0.12); font-size:14px; box-shadow:none;" onclick="app.addVal(10)">+10</button>
            <button class="btn-nb" style="background:rgba(120,120,128,0.12); font-size:14px; box-shadow:none;" onclick="app.addVal(20)">+20</button>
            <button id="btn-82" class="btn-nb hidden" style="background:rgba(120,120,128,0.12); font-size:14px; box-shadow:none;" onclick="app.addVal(82)">+82</button>
            <button id="btn-50" class="btn-nb hidden" style="background:rgba(120,120,128,0.12); font-size:14px; box-shadow:none;" onclick="app.addVal(50)">+50</button>
            <button id="smart-btn" class="btn-nb" style="background:var(--text); color:var(--bg); font-size:14px; box-shadow:none;" onclick="app.handleSmart()">+/-</button>
        </div>
        <div class="numpad">
            <button class="btn-nb" onclick="app.typeNum(1)">1</button><button class="btn-nb" onclick="app.typeNum(2)">2</button><button class="btn-nb" onclick="app.typeNum(3)">3</button>
            <button class="btn-nb" onclick="app.typeNum(4)">4</button><button class="btn-nb" onclick="app.typeNum(5)">5</button><button class="btn-nb" onclick="app.typeNum(6)">6</button>
            <button class="btn-nb" onclick="app.typeNum(7)">7</button><button class="btn-nb" onclick="app.typeNum(8)">8</button><button class="btn-nb" onclick="app.typeNum(9)">9</button>
            <button class="btn-nb" style="color:var(--danger)" onclick="app.clearInput()">C</button>
            <button class="btn-nb" onclick="app.typeNum(0)">0</button>
            <button class="btn-nb" onclick="app.backspace()">‚å´</button>
        </div>
        <button class="btn-main" style="margin-top:15px; background:var(--primary); color:white" onclick="app.closeSheet()">OK</button>
    </div>
</div>

<div id="victory" class="victory-overlay">
    <div class="victory-box">
        <h2 class="text-center" style="margin:0 0 10px 0; font-size:28px;">üèÜ PARTIE TERMIN√âE</h2>
        <div class="podium-container" id="podium"></div>
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin: 20px 0;">
            <button class="btn-main" style="background:var(--success); color:white;" onclick="app.shareRecapPNG()">
                üì∏ PNG
            </button>
            <button class="btn-main" style="background:var(--dealer); color:white;" onclick="app.shareRecapGIF()">
                üé¨ GIF
            </button>
        </div>

    <button class="btn-main" style="background:var(--primary); color:white; margin:12px 0;" onclick="app.restartWithSamePlayers()">üîÑ REJOUER (m√™mes joueurs)</button>
    <button class="btn-main" style="background:var(--card); border:1px solid var(--border); color:var(--text);" onclick="app.showSetup()">üè† RETOUR MENU</button>
</div>


</div>

<script>
    /* ==================== SCOREMASTER OPTIMIZED v1.1 - JAVASCRIPT ==================== */
    
    // ==================== SOUND ENGINE ====================
    const SoundFX = {
        ctx: null, enabled: true,
        init() {
            if (!this.ctx && window.AudioContext) {
                try {
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                    if (this.ctx.state === 'suspended') this.ctx.resume();
                } catch (e) { console.warn("Audio API non support√©e"); this.enabled = false; }
            }
        },
        playTone(freq, type, duration) {
            if (!this.enabled || !this.ctx) return;
            if (this.ctx.state === 'suspended') this.ctx.resume();
            try {
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + duration);
            } catch (e) {}
        },
        // OPTIMISATION: Vibrations tactiles am√©lior√©es
        click() { this.playTone(800, 'sine', 0.1); if(navigator.vibrate) navigator.vibrate(5); },
        success() { 
            this.playTone(600, 'sine', 0.1); 
            setTimeout(() => this.playTone(900, 'sine', 0.2), 100); 
            if(navigator.vibrate) navigator.vibrate([30, 50, 30]);
        },
        error() { 
            this.playTone(150, 'sawtooth', 0.3); 
            if(navigator.vibrate) navigator.vibrate([50, 50, 50]);
        }
    };

    // ==================== DATA LAYER ====================
    const GameState = {
        create(mode, playerCount) {
            const colors = ['#007AFF', '#FF2D55', '#34C759', '#FF9500', '#AF52DE', '#5AC8FA', '#FFCC00', '#5856D6', '#FF3B30', '#30B0C7', '#8E8E93', '#4CD964'];
            const validPlayerCount = Math.max(2, Math.min(playerCount, 12));
            return {
                mode,
                victoryCondition: 'highest',
                players: Array.from({length: validPlayerCount}, (_, i) => ({
                    id: i + 1, 
                    name: mode === 'belote' ? (i === 0 ? 'NOUS' : 'EUX') : `J${i + 1}`, 
                    color: colors[i] || '#000000',
                    total: 0, previousRank: null
                })),
                history: [], 
                temp: {}, 
                dealerId: 1, 
                celebratedMilestones: {},
                historyPage: 0  // OPTIMISATION UX6: Pagination
            };
        },
        addRound(state, scores) {
            const round = {};
            state.players.forEach(p => {
                const score = scores[p.id] || 0;
                round[p.id] = score;
                p.total += score;
            });
            state.history.push(round);
            return state;
        },
        updateRound(state, index, scores) {
            const oldRound = state.history[index];
            state.players.forEach(p => p.total -= (oldRound[p.id] || 0));
            const newRound = {};
            state.players.forEach(p => {
                const score = scores[p.id] || 0;
                newRound[p.id] = score;
                p.total += score;
            });
            state.history[index] = newRound;
            return state;
        },
        deleteRound(state, index) {
            const round = state.history[index];
            state.players.forEach(p => p.total -= (round[p.id] || 0));
            state.history.splice(index, 1);
            return state;
        },
        getSortedPlayers(state) {
            const isLowest = state.victoryCondition === 'lowest';
            return [...state.players].sort((a, b) => 
                isLowest ? a.total - b.total : b.total - a.total
            );
        },
        validate(scores, mode) {
            const values = Object.values(scores);
            if(values.some(v => v > 9999)) return { valid: false, error: 'Score trop √©lev√© (max 9999)' };
            if(mode === 'belote' && values.some(v => v < 0)) return { valid: false, error: 'Score n√©gatif impossible en Belote' };
            return { valid: true };
        }
    };

    // ==================== STORAGE LAYER (OPTIMIS√â) ====================
    const Storage = {
        GAMES_KEY: 'sm_v12_games', 
        CURRENT_KEY: 'sm_v12_current',
        
        // OPTIMISATION #1: Cache localStorage (-50% I/O)
        _cache: null,
        _cacheTime: 0,
        CACHE_DURATION: 1000,
        
        migrateData() {
            const v12Data = localStorage.getItem(this.GAMES_KEY);
            if (!v12Data) {
                const v11Data = localStorage.getItem('sm_v11_games');
                if (v11Data) {
                    try {
                        const parsed = JSON.parse(v11Data);
                        if (Array.isArray(parsed) && parsed.length > 0) {
                            localStorage.setItem(this.GAMES_KEY, v11Data);
                            const v11Current = localStorage.getItem('sm_v11_current');
                            if (v11Current && parsed.find(g => g.id === v11Current)) {
                                localStorage.setItem(this.CURRENT_KEY, v11Current);
                            }
                        }
                    } catch(e) { console.error("SM: Migration √©chou√©e", e); }
                }
            }
        },
        
        saveGame(game) {
            try {
                const games = this.loadGames() || [];
                const existing = games.findIndex(g => g.id === game.id);
                if(existing >= 0) games[existing] = game;
                else games.push(game);
                localStorage.setItem(this.GAMES_KEY, JSON.stringify(games));
                localStorage.setItem(this.CURRENT_KEY, game.id);
                this.invalidateCache();
                return true;
            } catch(e) {
                console.error("SM: Save failed", e);
                return false;
            }
        },
        
        loadGames() {
            const now = Date.now();
            if (this._cache && (now - this._cacheTime) < this.CACHE_DURATION) {
                return this._cache;
            }
            try {
                const data = localStorage.getItem(this.GAMES_KEY);
                this._cache = data ? JSON.parse(data) : [];
                this._cacheTime = now;
                return this._cache;
            } catch(e) { 
                console.error("SM: Corrupt data", e); 
                return []; 
            }
        },
        
        invalidateCache() {
            this._cache = null;
        },
        
        loadCurrentGame() {
            try {
                const currentId = localStorage.getItem(this.CURRENT_KEY);
                if(!currentId) return null;
                return this.loadGames().find(g => g.id === currentId);
            } catch(e) { return null; }
        },
        
        deleteGame(gameId) {
            const games = this.loadGames().filter(g => g.id !== gameId);
            localStorage.setItem(this.GAMES_KEY, JSON.stringify(games));
            const currentId = localStorage.getItem(this.CURRENT_KEY);
            if(currentId === gameId) localStorage.removeItem(this.CURRENT_KEY);
            this.invalidateCache();
        }
    };

    // ==================== UI LAYER (OPTIMIS√â) ====================
    const UI = {
        // OPTIMISATION UX4: Toast Queue
        toastQueue: [],
        toastActive: false,
        
        showToast(message, type = 'default') {
            this.toastQueue.push({ message, type });
            if (!this.toastActive) {
                this.processToastQueue();
            }
        },
        
        processToastQueue() {
            if (this.toastQueue.length === 0) {
                this.toastActive = false;
                return;
            }
            
            this.toastActive = true;
            const { message, type } = this.toastQueue.shift();
            
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.className = 'toast show';
            if(type !== 'default') toast.classList.add(type);
            
            if(type === 'success') SoundFX.success();
            else if(type === 'error') SoundFX.error();
            
            setTimeout(() => {
                toast.classList.remove('show');
                setTimeout(() => this.processToastQueue(), 300);
            }, 2500);
        },
        
        confirm(message, onYes) {
            SoundFX.click();
            const modal = document.getElementById('confirm-modal');
            const msgEl = document.getElementById('confirm-msg');
            const yesBtn = document.getElementById('confirm-yes-btn');
            msgEl.textContent = message;
            modal.classList.add('active');
            const newBtn = yesBtn.cloneNode(true);
            yesBtn.parentNode.replaceChild(newBtn, yesBtn);
            newBtn.addEventListener('click', () => {
                modal.classList.remove('active');
                onYes();
            });
        },
        closeConfirm() { document.getElementById('confirm-modal').classList.remove('active'); },
        
        showStats() {
            SoundFX.click();
            document.getElementById('stats-modal').classList.add('active');
        },
        closeStats() { document.getElementById('stats-modal').classList.remove('active'); },
        
        renderScoreCards(state) {
            const isLowest = app.currentGame.victoryCondition === 'lowest';
            const sorted = app.focusMode ? [...state.players] : [...state.players].sort((a,b) => {
                const scoreA = a.total + (state.temp[a.id]||0);
                const scoreB = b.total + (state.temp[b.id]||0);
                return isLowest ? scoreA - scoreB : scoreB - scoreA;
            });
            const grid = document.getElementById('grid');
            const rankChanges = new Set();
            app.lastRanks = app.lastRanks || {};

            state.players.forEach(p => {
                const newRank = sorted.findIndex(s => s.id === p.id);
                if(app.lastRanks[p.id] !== undefined && app.lastRanks[p.id] !== newRank) {
                    rankChanges.add(p.id);
                }
                app.lastRanks[p.id] = newRank;
            });
            grid.innerHTML = '';
            const displayOrder = app.focusMode ? state.players : sorted;
            displayOrder.forEach(p => {
                const tempScore = state.temp[p.id] || 0;
                const totalScore = p.total + tempScore;
                const rankIdx = sorted.findIndex(s => s.id === p.id);
                let badgeClass = 'badge-none', badgeText = '#' + (rankIdx + 1);
                if(rankIdx === 0) { badgeClass = 'badge-1'; badgeText = 'ü•á'; }
                else if(rankIdx === 1) { badgeClass = 'badge-2'; badgeText = 'ü•à'; }
                else if(rankIdx === 2) { badgeClass = 'badge-3'; badgeText = 'ü•â'; }
                const card = document.createElement('div');
                card.className = `p-card ${state.dealerId === p.id ? 'is-dealer' : ''}`;
                if(rankChanges.has(p.id) && !app.focusMode) card.classList.add('rank-change');
                card.innerHTML = `
                    <div class="rank-badge ${badgeClass} ${rankChanges.has(p.id) ? 'bounce' : ''}">${badgeText}</div>
                    <div class="p-name-btn" style="color:${p.color}; border-color:${p.color}40" onclick="app.openModal(${p.id})">${p.name}</div>
                    <div class="p-score ${tempScore !== 0 ? 'score-bump' : ''}" onclick="app.openSheet(${p.id})">${totalScore}</div>
                    <div class="p-temp">${tempScore ? (tempScore > 0 ? '+' + tempScore : tempScore) : ''}</div>
                    ${state.dealerId === p.id ? '<div style="position:absolute; top:8px; right:8px; font-size:12px;">üÉè</div>' : ''}
                `;
                grid.appendChild(card);
            });
        },
        
        // OPTIMISATION UX6: Pagination historique
        renderHistory(state, editIdx) {
            const hist = document.getElementById('history');
            const MAX_VISIBLE = 20;
            
            if (!state.historyPage) state.historyPage = 0;
            
            const totalPages = Math.ceil(state.history.length / MAX_VISIBLE);
            const startIdx = state.historyPage * MAX_VISIBLE;
            const endIdx = Math.min(startIdx + MAX_VISIBLE, state.history.length);
            
            hist.innerHTML = '';
            
            if (totalPages > 1) {
                const nav = document.createElement('div');
                nav.className = 'history-pagination';
                nav.innerHTML = `
                    <button onclick="app.currentGame.state.historyPage = Math.max(0, ${state.historyPage - 1}); app.render()" 
                            ${state.historyPage === 0 ? 'disabled' : ''}>
                        ‚Üê Pr√©c√©dent
                    </button>
                    <span>Page ${state.historyPage + 1} / ${totalPages}</span>
                    <button onclick="app.currentGame.state.historyPage = Math.min(${totalPages - 1}, ${state.historyPage + 1}); app.render()"
                            ${state.historyPage === totalPages - 1 ? 'disabled' : ''}>
                        Suivant ‚Üí
                    </button>
                `;
                hist.appendChild(nav);
            }
            
            state.history.slice().reverse()
                .slice(startIdx, endIdx)
                .forEach((r, i) => {
                    const idx = state.history.length - 1 - (startIdx + i);
                    const isEditing = idx === editIdx;
                    const row = document.createElement('div');
                    row.className = 'h-row';
                    row.style.borderColor = isEditing ? 'var(--dealer)' : 'var(--border)';
                    let scoresHtml = '';
                    state.players.forEach(p => {
                        const score = isEditing && state.temp[p.id] !== undefined ? state.temp[p.id] : (r[p.id] || 0);
                        scoresHtml += `
                            <div class="h-score-item">
                                <div style="font-size:7px; color:${p.color}; font-weight:900; opacity:0.7">${p.name.substring(0,4)}</div>
                                <div style="color:${p.color}; font-weight:800; font-size:14px;">${score}</div>
                            </div>
                        `;
                    });
                    row.innerHTML = `
                        <div class="h-idx">M${idx+1}</div>
                        <div class="h-scores" onclick="app.startEdit(${idx})">${scoresHtml}</div>
                        <button onclick="app.delRound(${idx})" style="border:none; background:none; color:var(--danger); font-size:18px; padding-left:10px; flex-shrink:0;">√ó</button>
                    `;
                    hist.appendChild(row);
                });
        },
        
        // OPTIMISATION #3: Chart.js Update au lieu de Destroy
        renderChart(state, editIdx) {
            const ctx = document.getElementById('chart');
            if(!ctx || typeof Chart === 'undefined') return;
            
            const datasets = state.players.map(p => {
                let cumul = 0;
                const data = [0];
                state.history.forEach((h, idx) => {
                    if(idx === editIdx && state.temp[p.id] !== undefined) cumul += state.temp[p.id];
                    else cumul += (h[p.id] || 0);
                    data.push(cumul);
                });
                if(Object.keys(state.temp).length > 0 && editIdx === null) data.push(cumul + (state.temp[p.id] || 0));
                return {
                    label: p.name, data, borderColor: p.color, backgroundColor: p.color + '20', 
                    tension: 0.4, pointRadius: 3, pointHoverRadius: 6, borderWidth: 2.5, fill: false
                };
            });
            const labels = ['0', ...state.history.map((_, i) => 'M' + (i + 1))];
            if(Object.keys(state.temp).length > 0 && editIdx === null) labels.push('...');
            
            if(app.chart) {
                app.chart.data.datasets = datasets;
                app.chart.data.labels = labels;
                app.chart.update('none');
            } else {
                app.chart = new Chart(ctx, {
                    type: 'line',
                    data: { labels, datasets },
                    options: {
                        responsive: true, maintainAspectRatio: false,
                        interaction: { mode: 'index', intersect: false },
                        plugins: { legend: { display: false } },
                        scales: { 
                            x: { grid: { display: false }, ticks: { font: { size: 10, weight: '700' }, color: '#86868B' } }, 
                            y: { beginAtZero: true, grid: { color: 'rgba(128,128,128,0.08)' }, ticks: { font: { size: 10, weight: '600' }, color: '#86868B' } } 
                        },
                        animation: { duration: 400 }
                    }
                });
            }
        },
        
        showVictory(winner, score, state) {
            SoundFX.success();
            const overlay = document.getElementById('victory');
            const sorted = [...state.players].sort((a,b) => b.total - a.total);
            const podium = document.getElementById('podium');
            podium.innerHTML = '';
            const top3 = [sorted[1], sorted[0], sorted[2]].filter(p => p);
            top3.forEach((p) => {
                if(!p) return;
                const realRank = sorted.indexOf(p) + 1;
                const place = document.createElement('div');
                place.className = `podium-place p${realRank}`;
                place.innerHTML = `
                    <div class="podium-avatar" style="background:${p.color}30; border:3px solid ${p.color};">
                        <span style="color:${p.color}">${p.name.substring(0,2)}</span>
                    </div>
                    <div class="podium-name" style="color:${p.color}">${p.name}</div>
                    <div class="podium-score" style="color:${p.color}">${p.total}</div>
                    <div class="podium-bar">
                        ${realRank === 1 ? 'ü•á' : realRank === 2 ? 'ü•à' : 'ü•â'}
                    </div>
                `;
                podium.appendChild(place);
            });
            overlay.classList.add('active');
            
            // OPTIMISATION: Confetti plus court
            const duration = 2000;
            const end = Date.now() + duration;
            const colors = ['#007AFF', '#FF2D55', '#34C759', '#FF9500', '#AF52DE', '#FFD700'];
            (function frame() {
                confetti({ particleCount: 2, angle: 60, spread: 55, origin: { x: 0, y: 0.8 }, colors: colors, gravity: 1.2 });
                confetti({ particleCount: 2, angle: 120, spread: 55, origin: { x: 1, y: 0.8 }, colors: colors, gravity: 1.2 });
                if (Date.now() < end) requestAnimationFrame(frame);
            })();
            confetti({ particleCount: 50, spread: 70, origin: { y: 0.6 }, colors: colors });
            
            if(navigator.vibrate) navigator.vibrate([100, 50, 100, 50, 200]);
        },
        closeVictory() { document.getElementById('victory').classList.remove('active'); },
        
        launchMilestoneConfetti(score) {
            const colors = ['#FFD700', '#FF2D55', '#34C759', '#007AFF', '#AF52DE'];
            const particleCount = score >= 1000 ? 150 : 100;
            
            confetti({
                particleCount: particleCount,
                spread: 100,
                origin: { y: 0.6 },
                colors: colors,
                gravity: 1,
                ticks: 300
            });
            
            if (navigator.vibrate) {
                navigator.vibrate([50, 100, 50, 100, 50]);
            }
        }
    };

    // ==================== APP CONTROLLER (OPTIMIS√â) ====================
    const app = {
        currentGame: null, activePlayerId: null, editIdx: null, chart: null, savedPlayers: {}, focusMode: false,
        
        // OPTIMISATION #2: Debouncing sur render() (-70% redraws)
        _renderTimeout: null,

        init() {
            Storage.migrateData();
            const savedTheme = localStorage.getItem('sm_theme');
            if(savedTheme) { document.documentElement.setAttribute('data-theme', savedTheme); this.updateThemeIcon(); }
            
            try {
                const savedPlayersData = localStorage.getItem('sm_saved_players');
                if(savedPlayersData) { this.savedPlayers = JSON.parse(savedPlayersData); }
            } catch(e) { console.warn("Corrupt saved players data", e); this.savedPlayers = {}; }

            const game = Storage.loadCurrentGame();
            if(game) { 
                if(!game.victoryCondition) game.victoryCondition = 'highest';
                if(!game.endCondition) game.endCondition = game.mode === 'belote' ? { type: 'score', value: 1000 } : { type: 'free', value: null };
                this.currentGame = game; 
                this.showGame(); 
            } else { 
                this.showSetup(); 
            }
            this.renderGamesList();
        },
        
        toggleTheme() {
            const root = document.documentElement;
            const currentTheme = root.getAttribute('data-theme');
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            root.setAttribute('data-theme', newTheme);
            localStorage.setItem('sm_theme', newTheme);
            this.updateThemeIcon();
            if(navigator.vibrate) navigator.vibrate(30);
        },
        
        updateThemeIcon() {
            const theme = document.documentElement.getAttribute('data-theme');
            const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
            const isDark = theme === 'dark' || (theme !== 'light' && prefersDark);
            document.getElementById('theme-toggle').textContent = isDark ? '‚òÄÔ∏è' : 'üåô';
        },
        
        showSetup() {
            UI.closeVictory();
            this.focusMode = false;
            document.getElementById('game').classList.remove('focus-mode');
            document.getElementById('dock').classList.add('hidden');
            this.currentGame = null;
            this.editIdx = null;
            document.getElementById('setup').classList.remove('hidden');
            document.getElementById('game').classList.add('hidden');
            this.renderGamesList();
        },
        
        showModeSelection(mode) {
            SoundFX.click();
            if(mode === 'belote') { this.createGame(mode, 2); }
            else { 
                document.getElementById('mode-setup-title').textContent = 'Mode Standard';
                document.getElementById('modal-player-count').classList.add('active'); 
                this.updateVictoryCondition();
                this.updateEndCondition();
            }
        },
        
        updateVictoryCondition() {
            const isLowest = document.querySelector('input[name="victory-condition"]:checked')?.value === 'lowest';
            const scoreLabel = document.getElementById('score-label-text');
            const highestLabel = document.getElementById('victory-highest-label');
            const lowestLabel = document.getElementById('victory-lowest-label');
            
            if (this.currentGame?.state) {
                this.currentGame.state.victoryCondition = isLowest ? 'lowest' : 'highest';
            }
            
            highestLabel.style.borderColor = !isLowest ? 'var(--primary)' : 'var(--border)';
            lowestLabel.style.borderColor = isLowest ? 'var(--primary)' : 'var(--border)';
            
            if(isLowest) {
                scoreLabel.textContent = '‚ö†Ô∏è Limite de d√©faite :';
            } else {
                scoreLabel.textContent = 'üéØ Score objectif :';
            }
        },
        
        updateEndCondition() {
            const endType = document.querySelector('input[name="end-condition"]:checked')?.value;
            const freeLabel = document.getElementById('end-free-label');
            const scoreLabel = document.getElementById('end-score-label');
            
            freeLabel.style.borderColor = endType === 'free' ? 'var(--primary)' : 'var(--border)';
            scoreLabel.style.borderColor = endType === 'score' ? 'var(--primary)' : 'var(--border)';
        },
        
        toggleMorePlayers() {
            const extraDiv = document.getElementById('extra-players');
            const btn = document.getElementById('btn-toggle-players');
            if (extraDiv.classList.contains('hidden')) { extraDiv.classList.remove('hidden'); btn.textContent = 'Moins ‚ñ≤'; }
            else { extraDiv.classList.add('hidden'); btn.textContent = 'Plus ‚ñº'; }
        },
        
        selectPlayerCount(count) {
            const victoryCondition = document.querySelector('input[name="victory-condition"]:checked')?.value || 'highest';
            const endType = document.querySelector('input[name="end-condition"]:checked')?.value || 'free';
            const scoreTarget = endType === 'score' ? parseInt(document.getElementById('score-target').value) || 100 : null;
            
            document.getElementById('modal-player-count').classList.remove('active');
            document.getElementById('extra-players').classList.add('hidden');
            document.getElementById('btn-toggle-players').textContent = 'Plus ‚ñº';
            
            this.createGame('standard', count, victoryCondition, endType, scoreTarget);
        },
        
        createGame(mode, playerCount, victoryCondition = 'highest', endType = 'free', scoreTarget = null) {
            this.currentGame = {
                id: Date.now().toString(),
                name: mode === 'belote' ? 'Belote' : 'Partie Standard',
                mode, 
                date: new Date().toISOString(),
                victoryCondition: mode === 'belote' ? 'highest' : victoryCondition,
                endCondition: mode === 'belote' ? { type: 'score', value: 1000 } : { type: endType, value: scoreTarget },
                state: GameState.create(mode, playerCount), 
                finished: false
            };
            if(this.savedPlayers[mode]) {
                const saved = this.savedPlayers[mode];
                this.currentGame.state.players.forEach((p, idx) => {
                    if(saved[idx]) { p.name = saved[idx].name; p.color = saved[idx].color; }
                });
            }
            if(!Storage.saveGame(this.currentGame)) {
                UI.showToast('‚ö†Ô∏è Erreur de sauvegarde (M√©moire pleine)', 'error');
                return;
            }
            this.showGame();
        },
        
        showGame() {
            document.getElementById('setup').classList.add('hidden');
            document.getElementById('game').classList.remove('hidden');
            document.getElementById('dock').classList.remove('hidden');
            const isBelote = this.currentGame.mode === 'belote';
            document.getElementById('mode-title').textContent = isBelote ? 'BELOTE' : 'STANDARD';
            
            const gameInfo = document.getElementById('game-info');
            const isLowest = this.currentGame.victoryCondition === 'lowest';
            const endCond = this.currentGame.endCondition;
            let infoText = '';
            
            if(isBelote) {
                infoText = 'üéØ Premier √† 1000 pts';
            } else {
                infoText = isLowest ? '‚¨áÔ∏è Score le plus BAS' : '‚¨ÜÔ∏è Score le plus HAUT';
                if(endCond.type === 'score') {
                    infoText += isLowest ? ` ‚Ä¢ Limite ${endCond.value} pts` : ` ‚Ä¢ Objectif ${endCond.value} pts`;
                }
            }
            gameInfo.textContent = infoText;
            
            document.getElementById('calc-btn').classList.toggle('hidden', !isBelote);
            document.getElementById('btn-82').classList.toggle('hidden', !isBelote);
            document.getElementById('btn-50').classList.toggle('hidden', isBelote);
            document.getElementById('smart-btn').textContent = isBelote ? 'CAPOT' : '+/-';
            this.render();
        },
        
        toggleFocusMode() {
            SoundFX.click();
            this.focusMode = !this.focusMode;
            const root = document.body;
            if(this.focusMode) { 
                root.classList.add('focus-mode');
                if(navigator.vibrate) navigator.vibrate(20);
            } else { 
                root.classList.remove('focus-mode');
            }
        },
        
        showStats() { UI.showStats(); },
        
        render() {
            clearTimeout(this._renderTimeout);
            this._renderTimeout = setTimeout(() => {
                this._doRender();
            }, 16);
        },
        
        _doRender() {
            if(!this.currentGame) return;
            UI.renderScoreCards(this.currentGame.state);
            UI.renderHistory(this.currentGame.state, this.editIdx);
            UI.renderChart(this.currentGame.state, this.editIdx);
            
            const saveBtn = document.getElementById('save-btn');
            if(saveBtn && this.editIdx === null) {
                const nextRound = this.currentGame.state.history.length + 1;
                saveBtn.textContent = `ENREGISTRER MANCHE ${nextRound}`;
            }
            
            // OPTIMISATION UX1: Dock intelligent
            const dock = document.getElementById('dock');
            const hasTemp = Object.keys(this.currentGame.state.temp).length > 0;
            
            if (hasTemp || this.editIdx !== null) {
                dock.classList.remove('hidden');
            } else {
                dock.classList.add('hidden');
            }
        },
        
        // RESTAURATION COMPL√àTE de renderGamesList()
        renderGamesList() {
            const games = Storage.loadGames();
            const list = document.getElementById('games-list');
            
            if(!games || games.length === 0) { 
                list.innerHTML = '<p class="text-center" style="color:var(--text-sec); padding:20px;">Aucune partie enregistr√©e</p>'; 
                return; 
            }
            
            list.innerHTML = '';
            
            games.slice().reverse().forEach(game => {
                const sortedPlayers = [...game.state.players].sort((a,b) => b.total - a.total);
                const winner = sortedPlayers[0];
                const date = new Date(game.date).toLocaleDateString('fr-FR', { 
                    day: 'numeric', 
                    month: 'short', 
                    hour: '2-digit', 
                    minute: '2-digit' 
                });
                
                const modeBadge = game.mode === 'belote' 
                    ? '<span class="game-mode-badge badge-belote">üÉè BELOTE</span>' 
                    : '<span class="game-mode-badge badge-standard">üé≤ STANDARD</span>';
                
                const item = document.createElement('div');
                item.className = 'game-item';
                
                let playersScoresHtml = '';
                sortedPlayers.forEach((p, idx) => {
                    const isWinner = idx === 0;
                    playersScoresHtml += `
                        <div class="game-player-score" style="background:${p.color}20; color:${p.color}; border: 1px solid ${p.color}40;">
                            ${isWinner ? 'üèÜ ' : ''}${p.name}: ${p.total}
                        </div>
                    `;
                });
                
                item.innerHTML = `
                    <div onclick="app.loadGame('${game.id}')" style="flex:1; cursor:pointer;">
                        <div style="font-weight:900; font-size:16px; margin-bottom:6px;">
                            ${game.name} ${game.finished ? '‚úì' : ''} ${modeBadge}
                        </div>
                        <div style="font-size:12px; color:var(--text-sec); margin-bottom:8px;">
                            ${date} ‚Ä¢ ${game.state.history.length} manches
                        </div>
                        <div class="game-players-list">${playersScoresHtml}</div>
                    </div>
                    <div class="game-actions">
                        <button onclick="event.stopPropagation(); app.deleteGame('${game.id}')" title="Supprimer">üóëÔ∏è</button>
                    </div>
                `;
                
                list.appendChild(item);
            });
        },
        
        loadGame(id) {
            SoundFX.click();
            const game = Storage.loadGames().find(g => g.id === id);
            
            if(game) {
                try {
                    this.savedPlayers[game.mode] = game.state.players.map(p => ({ 
                        name: p.name, 
                        color: p.color 
                    }));
                    localStorage.setItem('sm_saved_players', JSON.stringify(this.savedPlayers));
                    localStorage.setItem(Storage.CURRENT_KEY, id);
                } catch(e) {
                    if (e.name === 'QuotaExceededError') {
                        UI.showToast('‚ö†Ô∏è M√©moire pleine ! Supprimez des parties.', 'error');
                    } else {
                        console.error('localStorage error:', e);
                    }
                }
                
                this.currentGame = game;
                this.showGame();
            } else {
                UI.showToast('‚ö†Ô∏è Partie introuvable', 'error');
            }
        },
        
        deleteGame(gameId) {
            UI.confirm('Supprimer cette partie ?', () => {
                Storage.deleteGame(gameId);
                UI.showToast('‚úÖ Partie supprim√©e', 'success');
                this.renderGamesList();
            });
        },
        
        clearAll() {
            UI.confirm("‚ö†Ô∏è Supprimer TOUTES les parties ?", () => {
                localStorage.removeItem(Storage.GAMES_KEY);
                localStorage.removeItem(Storage.CURRENT_KEY);
                Storage.invalidateCache();
                UI.showToast('‚úÖ Historique effac√©', 'success');
                this.renderGamesList();
            });
        },
        
        restartWithSamePlayers() {
            UI.closeVictory();
            if(!this.currentGame) return;
            if(!this.currentGame.finished) { this.currentGame.finished = true; Storage.saveGame(this.currentGame); }
            const oldState = this.currentGame.state;
            const newGame = {
                id: Date.now().toString(),
                name: this.currentGame.mode === 'belote' ? 'Belote' : 'Partie Standard',
                mode: this.currentGame.mode, 
                date: new Date().toISOString(),
                state: { 
                    mode: oldState.mode, 
                    players: oldState.players.map(p => ({ ...p, total: 0, previousRank: null })), 
                    history: [], temp: {}, dealerId: oldState.dealerId, celebratedMilestones: {}, historyPage: 0 
                },
                finished: false
            };
            this.currentGame = newGame;
            if(!Storage.saveGame(newGame)) {
                UI.showToast('‚ö†Ô∏è Erreur de sauvegarde', 'error');
                return;
            }
            UI.showToast('üéÆ Nouvelle partie !', 'success');
            this.render();
        },
        
        finishGame() {
            if(this.currentGame.state.history.length === 0) { UI.showToast('‚ö†Ô∏è Aucune manche jou√©e', 'warning'); return; }
            this.currentGame.finished = true;
            Storage.saveGame(this.currentGame);
            
            try {
                this.savedPlayers[this.currentGame.mode] = this.currentGame.state.players.map(p => ({ name: p.name, color: p.color }));
                localStorage.setItem('sm_saved_players', JSON.stringify(this.savedPlayers));
            } catch(e) {}
            
            const winner = [...this.currentGame.state.players].sort((a,b) => b.total - a.total)[0];
            UI.showVictory(winner, winner.total, this.currentGame.state);
        },
        
        openModal(playerId) {
            SoundFX.click();
            this.editPlayerId = playerId;
            const player = this.currentGame.state.players.find(p => p.id === playerId);
            document.getElementById('modal-title').textContent = player.name;
            document.getElementById('modal-title').style.color = player.color;
            document.getElementById('edit-name').value = player.name;
            document.getElementById('edit-dealer').checked = (this.currentGame.state.dealerId === playerId);
            document.getElementById('modal-player').classList.add('active');
        },
        
        closeModal() { document.getElementById('modal-player').classList.remove('active'); },
        
        savePlayer() {
            SoundFX.click();
            const player = this.currentGame.state.players.find(p => p.id === this.editPlayerId);
            const newName = document.getElementById('edit-name').value.trim().toUpperCase();
            if(newName) player.name = newName;
            if(document.getElementById('edit-dealer').checked) { this.currentGame.state.dealerId = player.id; }
            this.closeModal();
            this.render();
        },
        
        openSheet(playerId) {
            SoundFX.click();
            this.activePlayerId = playerId;
            const isBelote = this.currentGame.mode === 'belote';
            document.getElementById('calc-btn').classList.toggle('hidden', !isBelote);
            document.getElementById('btn-82').classList.toggle('hidden', !isBelote);
            document.getElementById('btn-50').classList.toggle('hidden', isBelote);
            this.renderSwitcher();
            document.getElementById('sheet').classList.add('active');
        },
        
        closeSheet() { document.getElementById('sheet').classList.remove('active'); this.render(); },
        
        renderSwitcher() {
            const cont = document.getElementById('input-switcher');
            cont.innerHTML = '';
            this.currentGame.state.players.forEach(p => {
                const isActive = p.id === this.activePlayerId;
                const tempScore = this.currentGame.state.temp[p.id] || 0;
                const div = document.createElement('div');
                div.className = `sel-box ${isActive ? 'active' : ''}`;
                if(isActive) div.style.setProperty('--p-color', p.color);
                div.onclick = () => { this.activePlayerId = p.id; this.renderSwitcher(); SoundFX.click(); };
                div.innerHTML = `<div style="font-size:10px; font-weight:800; color:${isActive ? p.color : 'var(--text-sec)'}">${p.name}</div><div style="font-size:20px; font-weight:900">${tempScore}</div>`;
                cont.appendChild(div);
            });
        },
        
        typeNum(n) {
            const current = (this.currentGame.state.temp[this.activePlayerId] || 0).toString();
            const newVal = parseInt((current === '0' ? '' : current) + n);
            if(newVal > 9999) { if(navigator.vibrate) navigator.vibrate([50, 50, 50]); UI.showToast('‚ö†Ô∏è Maximum 9999 points', 'warning'); return; }
            if(navigator.vibrate) navigator.vibrate(5);
            this.currentGame.state.temp[this.activePlayerId] = newVal;
            this.renderSwitcher();
            this.render();
        },
        
        addVal(value) {
            const current = this.currentGame.state.temp[this.activePlayerId] || 0;
            const newVal = current + value;
            if(newVal > 9999) { if(navigator.vibrate) navigator.vibrate([50, 50, 50]); UI.showToast('‚ö†Ô∏è Maximum 9999 points', 'warning'); return; }
            if(navigator.vibrate) navigator.vibrate(10);
            this.currentGame.state.temp[this.activePlayerId] = Math.max(0, newVal);
            this.renderSwitcher();
            this.render();
        },
        
        backspace() {
            const current = (this.currentGame.state.temp[this.activePlayerId] || 0).toString();
            this.currentGame.state.temp[this.activePlayerId] = current.length > 1 ? parseInt(current.slice(0, -1)) : 0;
            if(navigator.vibrate) navigator.vibrate(5);
            this.renderSwitcher();
            this.render();
        },
        
        clearInput() {
            this.currentGame.state.temp[this.activePlayerId] = 0;
            if(navigator.vibrate) navigator.vibrate([30, 50, 30]);
            this.renderSwitcher();
            this.render();
        },
        
        handleSmart() {
            SoundFX.click();
            if(this.currentGame.mode === 'belote') { 
                this.currentGame.state.temp[this.activePlayerId] = 252; 
            } else { 
                const current = this.currentGame.state.temp[this.activePlayerId] || 0; 
                this.currentGame.state.temp[this.activePlayerId] = current * -1; 
            }
            this.renderSwitcher();
            this.render();
        },
        
        calcRest() {
            SoundFX.click();
            const otherPlayer = this.currentGame.state.players.find(p => p.id !== this.activePlayerId);
            if(otherPlayer) {
                const currentScore = this.currentGame.state.temp[this.activePlayerId] || 0;
                this.currentGame.state.temp[otherPlayer.id] = Math.max(0, 162 - currentScore);
                this.activePlayerId = otherPlayer.id;
                this.renderSwitcher();
                this.render();
            }
        },
        
        validateRound() {
            SoundFX.click();
            const state = this.currentGame.state;
            if(Object.keys(state.temp).length === 0) { UI.showToast('‚ö†Ô∏è Aucun score saisi', 'warning'); return; }
            const validation = GameState.validate(state.temp, this.currentGame.mode);
            if(!validation.valid) { UI.showToast(validation.error, 'error'); return; }
            
            if(this.editIdx !== null) {
                const roundNumber = this.editIdx + 1;
                GameState.updateRound(state, this.editIdx, state.temp);
                this.editIdx = null;
                document.getElementById('save-btn').textContent = `ENREGISTRER MANCHE ${state.history.length + 1}`;
                document.getElementById('save-btn').classList.remove('editing');
                UI.showToast(`‚úÖ Manche ${roundNumber} modifi√©e`, 'success');
            } else {
                const roundNumber = state.history.length + 1;
                GameState.addRound(state, state.temp);
                
                const currentIdx = state.players.findIndex(p => p.id === state.dealerId);
                if (currentIdx === -1) {
                    state.dealerId = state.players[0].id;
                } else {
                    state.dealerId = state.players[(currentIdx + 1) % state.players.length].id;
                }
                
                UI.showToast(`‚úÖ Manche ${roundNumber} enregistr√©e`, 'success');
            }
            
            const endCond = this.currentGame.endCondition;
            const victCond = this.currentGame.victoryCondition;
            let gameEnded = false;
            let winner = null;
            
            if(this.currentGame.mode === 'belote') {
                winner = state.players.find(p => p.total >= 1000);
                if(winner) gameEnded = true;
            } else if(endCond.type === 'score') {
                if(victCond === 'highest') {
                    winner = state.players.find(p => p.total >= endCond.value);
                    if(winner) gameEnded = true;
                } else {
                    const overLimit = state.players.filter(p => p.total >= endCond.value);
                    if(overLimit.length > 0) {
                        gameEnded = true;
                        const remaining = state.players.filter(p => p.total < endCond.value);
                        if(remaining.length > 0) {
                            winner = remaining.sort((a,b) => a.total - b.total)[0];
                        } else {
                            winner = [...state.players].sort((a,b) => a.total - b.total)[0];
                        }
                    }
                }
            }
            
            if(gameEnded && winner) {
                try {
                    this.savedPlayers[this.currentGame.mode] = state.players.map(p => ({ name: p.name, color: p.color }));
                    localStorage.setItem('sm_saved_players', JSON.stringify(this.savedPlayers));
                } catch(e) {}
                
                this.currentGame.finished = true;
                setTimeout(() => { UI.showVictory(winner, winner.total, state); }, 500);
            }
            
            if(!Storage.saveGame(this.currentGame)) {
                UI.showToast('‚ö†Ô∏è Erreur de sauvegarde', 'error');
            }
            state.temp = {};
            this.render();
        },
        
        startEdit(idx) {
            SoundFX.click();
            const state = this.currentGame.state;
            if(Object.keys(state.temp).length > 0) {
                UI.confirm('Abandonner la saisie en cours ?', () => {
                    this.editIdx = idx;
                    state.temp = {...state.history[idx]};
                    document.getElementById('save-btn').textContent = `MODIFIER MANCHE ${idx + 1}`;
                    document.getElementById('save-btn').classList.add('editing');
                    this.openSheet(state.players[0].id);
                });
                return;
            }
            this.editIdx = idx;
            state.temp = {...state.history[idx]};
            document.getElementById('save-btn').textContent = `MODIFIER MANCHE ${idx + 1}`;
            document.getElementById('save-btn').classList.add('editing');
            this.openSheet(state.players[0].id);
        },
        
        delRound(idx) {
            UI.confirm('Supprimer cette manche ?', () => {
                GameState.deleteRound(this.currentGame.state, idx);
                
                if (this.editIdx !== null) {
                    if (this.editIdx === idx) {
                        this.editIdx = null;
                        this.currentGame.state.temp = {};
                        document.getElementById('save-btn').textContent = `ENREGISTRER MANCHE ${this.currentGame.state.history.length + 1}`;
                        document.getElementById('save-btn').classList.remove('editing');
                    } else if (this.editIdx > idx) {
                        this.editIdx--;
                    }
                }
                
                UI.showToast('‚úÖ Manche supprim√©e', 'success');
                this.render();
            });
        },
        
        undo() {
            const history = this.currentGame.state.history;
            if(history.length > 0) { this.delRound(history.length - 1); }
        }
    ,

        
        async shareRecapPNG() {
            try {
                SoundFX.click();
                UI.showToast('üì∏ G√©n√©ration PNG...', 'default');
                
                const canvas = await RecapGenerator.generate(this.currentGame.state);
                
                if (!canvas) {
                    UI.showToast('‚ùå Erreur g√©n√©ration', 'error');
                    return;
                }
                
                const shared = await RecapGenerator.shareImage(canvas);
                
                if (!shared) {
                    RecapGenerator.downloadImage(canvas, `scoremaster_${Date.now()}.png`);
                    UI.showToast('‚úÖ Image t√©l√©charg√©e', 'success');
                } else {
                    UI.showToast('‚úÖ Image partag√©e', 'success');
                }
            } catch (error) {
                console.error('[app] PNG share error:', error);
                UI.showToast('‚ùå Erreur de partage', 'error');
            }
        },
        
        async shareRecapGIF() {
            try {
                SoundFX.click();
                
                if (typeof gifshot === 'undefined') {
                    UI.showToast('‚ùå Biblioth√®que GIF non charg√©e', 'error');
                    return;
                }
                
                if (this.currentGame.state.history.length === 0) {
                    UI.showToast('‚ö†Ô∏è Aucune manche √† animer', 'warning');
                    return;
                }
                
                const gifDataUrl = await RecapGifGenerator.generate(this.currentGame.state);
                
                if (!gifDataUrl) {
                    UI.showToast('‚ùå Erreur g√©n√©ration GIF', 'error');
                    return;
                }
                
                const shared = await RecapGifGenerator.shareGif(gifDataUrl);
                
                if (shared) {
                    UI.showToast('‚úÖ GIF partag√©', 'success');
                } else {
                    UI.showToast('‚ùå Erreur de partage', 'error');
                }
            } catch (error) {
                console.error('[app] GIF share error:', error);
                UI.showToast('‚ùå Erreur g√©n√©ration GIF', 'error');
            }
        }
};
    
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => {
            SoundFX.init();
            app.init();
        });
    } else {
        SoundFX.init();
        app.init();
        PWA.init();
    }

    
    // ==================== RECAP GENERATOR (PNG EXPORT) ====================
    /* ==================== RECAP GENERATOR (PNG EXPORT) ==================== */

const RecapGenerator = {
    async generate(state) {
        try {
            const canvas = document.createElement('canvas');
            canvas.width = 1080;
            canvas.height = 1920;
            const ctx = canvas.getContext('2d');
            
            // Background gradient
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
            if (isDark) {
                gradient.addColorStop(0, '#1C1C1E');
                gradient.addColorStop(1, '#000000');
            } else {
                gradient.addColorStop(0, '#F5F5F7');
                gradient.addColorStop(1, '#FFFFFF');
            }
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Titre
            ctx.textAlign = 'center';
            ctx.font = 'bold 80px -apple-system, sans-serif';
            ctx.fillStyle = isDark ? '#F5F5F7' : '#1D1D1F';
            ctx.fillText('üèÜ PARTIE TERMIN√âE', canvas.width / 2, 120);
            
            // Date
            ctx.font = '32px -apple-system, sans-serif';
            ctx.fillStyle = isDark ? '#98989D' : '#86868B';
            const date = new Date().toLocaleDateString('fr-FR', {
                day: 'numeric',
                month: 'long',
                year: 'numeric',
                hour: '2-digit',
                minute: '2-digit'
            });
            ctx.fillText(date, canvas.width / 2, 180);
            
            // Analyse narrative
            const story = StoryBrain.analyze(state);
            const roles = PlayerCasting.assignRoles(state, story);
            const narrative = NarrativeEngine.generateStory(state, story, roles);
            
            // Narrative box
            let yPos = 260;
            ctx.fillStyle = isDark ? 'rgba(28, 28, 30, 0.8)' : 'rgba(255, 255, 255, 0.8)';
            ctx.fillRect(60, yPos, canvas.width - 120, 200);
            ctx.strokeStyle = isDark ? '#38383A' : '#E5E5EA';
            ctx.lineWidth = 2;
            ctx.strokeRect(60, yPos, canvas.width - 120, 200);
            
            // Narrative text
            ctx.fillStyle = isDark ? '#F5F5F7' : '#1D1D1F';
            ctx.font = '28px -apple-system, sans-serif';
            ctx.textAlign = 'left';
            this.wrapText(ctx, narrative, 100, yPos + 50, canvas.width - 200, 40);
            
            // Podium
            yPos = 520;
            const sorted = [...state.players].sort((a, b) => b.total - a.total);
            const podiumOrder = [sorted[1], sorted[0], sorted[2]].filter(p => p);
            const podiumX = [240, 540, 840];
            const podiumHeights = [200, 280, 160];
            const podiumY = [yPos + 80, yPos, yPos + 120];
            
            podiumOrder.forEach((player, idx) => {
                if (!player) return;
                const realRank = sorted.indexOf(player) + 1;
                const x = podiumX[idx];
                const h = podiumHeights[idx];
                const y = podiumY[idx];
                
                // Podium bar
                ctx.fillStyle = realRank === 1 ? '#FFD700' : realRank === 2 ? '#C0C0C0' : '#CD7F32';
                ctx.fillRect(x - 100, y + 280 - h, 200, h);
                
                // Rank number
                ctx.fillStyle = '#FFFFFF';
                ctx.font = 'bold 80px -apple-system, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(realRank, x, y + 280 - h + 70);
                
                // Player name
                ctx.fillStyle = player.color;
                ctx.font = 'bold 36px -apple-system, sans-serif';
                ctx.fillText(player.name, x, y + 250);
                
                // Score
                ctx.font = 'bold 48px -apple-system, sans-serif';
                ctx.fillText(player.total + ' pts', x, y + 300);
                
                // Medal
                const medal = realRank === 1 ? 'ü•á' : realRank === 2 ? 'ü•à' : 'ü•â';
                ctx.font = '60px -apple-system, sans-serif';
                ctx.fillText(medal, x, y + 180);
            });
            
            // Stats section
            yPos = 900;
            ctx.fillStyle = isDark ? '#F5F5F7' : '#1D1D1F';
            ctx.font = 'bold 48px -apple-system, sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('üìä STATISTIQUES', canvas.width / 2, yPos);
            
            yPos += 80;
            sorted.forEach((player, idx) => {
                // Player card
                ctx.fillStyle = isDark ? 'rgba(28, 28, 30, 0.8)' : 'rgba(255, 255, 255, 0.8)';
                ctx.fillRect(60, yPos, canvas.width - 120, 120);
                ctx.strokeStyle = player.color;
                ctx.lineWidth = 4;
                ctx.strokeRect(60, yPos, canvas.width - 120, 120);
                
                // Rank
                ctx.fillStyle = player.color;
                ctx.font = 'bold 48px -apple-system, sans-serif';
                ctx.textAlign = 'left';
                ctx.fillText(`#${idx + 1}`, 100, yPos + 70);
                
                // Name
                ctx.font = 'bold 40px -apple-system, sans-serif';
                ctx.fillText(player.name, 200, yPos + 70);
                
                // Score
                ctx.fillStyle = isDark ? '#F5F5F7' : '#1D1D1F';
                ctx.font = 'bold 44px -apple-system, sans-serif';
                ctx.textAlign = 'right';
                ctx.fillText(player.total + ' pts', canvas.width - 100, yPos + 70);
                
                yPos += 140;
            });
            
            // Footer
            ctx.fillStyle = isDark ? '#98989D' : '#86868B';
            ctx.font = '28px -apple-system, sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('G√©n√©r√© par ScoreMaster üé≤', canvas.width / 2, canvas.height - 60);
            
            return canvas;
        } catch (error) {
            console.error('[RecapGenerator] Error:', error);
            return null;
        }
    },
    
    wrapText(ctx, text, x, y, maxWidth, lineHeight) {
        const words = text.split(' ');
        let line = '';
        let currentY = y;
        
        for (let n = 0; n < words.length; n++) {
            const testLine = line + words[n] + ' ';
            const metrics = ctx.measureText(testLine);
            const testWidth = metrics.width;
            
            if (testWidth > maxWidth && n > 0) {
                ctx.fillText(line, x, currentY);
                line = words[n] + ' ';
                currentY += lineHeight;
            } else {
                line = testLine;
            }
        }
        ctx.fillText(line, x, currentY);
    },
    
    async shareImage(canvas) {
        try {
            const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/png'));
            
            if (navigator.share && navigator.canShare && navigator.canShare({ files: [new File([blob], 'scoremaster.png', { type: 'image/png' })] })) {
                const file = new File([blob], 'scoremaster.png', { type: 'image/png' });
                await navigator.share({
                    files: [file],
                    title: 'ScoreMaster - R√©sultats',
                    text: 'D√©couvrez les r√©sultats de la partie !'
                });
                return true;
            }
            return false;
        } catch (error) {
            console.error('[RecapGenerator] Share error:', error);
            return false;
        }
    },
    
    downloadImage(canvas, filename) {
        const link = document.createElement('a');
        link.download = filename;
        link.href = canvas.toDataURL('image/png');
        link.click();
    }
};

const StoryBrain = {
    analyze(state) {
        const sorted = [...state.players].sort((a, b) => b.total - a.total);
        const winner = sorted[0];
        const loser = sorted[sorted.length - 1];
        const gap = winner.total - (sorted[1]?.total || 0);
        const isClose = gap < 100;
        const isDomination = gap > 300;
        
        // Identifier les comebacks
        let biggestComeback = null;
        let maxImprovement = 0;
        
        state.players.forEach(p => {
            const ranks = [state.players.length];
            state.history.forEach((round, histIdx) => {
                const totals = state.players.map(pl => {
                    let c = 0;
                    state.history.slice(0, histIdx + 1).forEach(r => c += r[pl.id] || 0);
                    return { id: pl.id, total: c };
                }).sort((a, b) => b.total - a.total);
                ranks.push(totals.findIndex(t => t.id === p.id) + 1);
            });
            const maxRank = Math.max(...ranks);
            const finalRank = ranks[ranks.length - 1];
            const improvement = maxRank - finalRank;
            if (improvement > maxImprovement) {
                maxImprovement = improvement;
                biggestComeback = { player: p, from: maxRank, to: finalRank };
            }
        });
        
        // Meilleure manche
        let bestRound = { score: 0, player: null, roundIdx: 0 };
        state.history.forEach((round, idx) => {
            state.players.forEach(p => {
                if (round[p.id] > bestRound.score) {
                    bestRound = { score: round[p.id], player: p, roundIdx: idx + 1 };
                }
            });
        });
        
        return {
            winner,
            loser,
            gap,
            isClose,
            isDomination,
            comeback: biggestComeback,
            bestRound,
            totalRounds: state.history.length
        };
    }
};

const PlayerCasting = {
    assignRoles(state, story) {
        const sorted = [...state.players].sort((a, b) => b.total - a.total);
        
        return {
            champion: story.winner,
            challenger: sorted[1],
            underdog: sorted[sorted.length - 1],
            mvp: story.bestRound.player,
            comeback: story.comeback?.player
        };
    }
};

const NarrativeEngine = {
    generateStory(state, story, roles) {
        const templates = [];
        
        if (story.isDomination) {
            templates.push(`${roles.champion.name} √©crase la comp√©tition avec une victoire sans appel !`);
        } else if (story.isClose) {
            templates.push(`Victoire serr√©e de ${roles.champion.name} dans un match haletant !`);
        } else {
            templates.push(`${roles.champion.name} remporte la partie avec ${story.winner.total} points.`);
        }
        
        if (story.comeback && story.comeback.from > story.comeback.to && story.comeback.from - story.comeback.to >= 2) {
            templates.push(`${roles.comeback.name} r√©alise un incroyable comeback : de la ${story.comeback.from}e √† la ${story.comeback.to}e place !`);
        }
        
        if (story.bestRound.score > 0) {
            templates.push(`Meilleure manche : ${roles.mvp.name} avec ${story.bestRound.score} pts (M${story.bestRound.roundIdx}).`);
        }
        
        return templates.join(' ');
    }
};

    
    // ==================== RECAP GIF GENERATOR ====================
    /* ==================== RECAP GIF GENERATOR ==================== */

const RecapGifGenerator = {
    async generate(state) {
        try {
            UI.showToast('üé¨ G√©n√©ration GIF...', 'info');
            
            const frames = await this.createFrames(state);
            
            if (!frames || frames.length === 0) {
                throw new Error('Aucune frame g√©n√©r√©e');
            }
            
            return new Promise((resolve, reject) => {
                if (typeof gifshot === 'undefined') {
                    reject(new Error('gifshot not loaded'));
                    return;
                }
                
                gifshot.createGIF({
                    images: frames,
                    gifWidth: 800,
                    gifHeight: 600,
                    interval: 0.8,
                    numFrames: frames.length,
                    frameDuration: 8,
                    sampleInterval: 10,
                    numWorkers: 0  // Pas de web workers pour compatibilit√© mobile
                }, (obj) => {
                    if (!obj.error) {
                        resolve(obj.image);
                    } else {
                        reject(new Error(obj.error));
                    }
                });
            });
        } catch (error) {
            console.error('[GifGenerator] Error:', error);
            UI.showToast('‚ùå Erreur g√©n√©ration GIF', 'error');
            return null;
        }
    },
    
    async createFrames(state) {
        const frames = [];
        const canvas = document.createElement('canvas');
        canvas.width = 800;
        canvas.height = 600;
        const ctx = canvas.getContext('2d');
        
        const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
        const bgColor = isDark ? '#1C1C1E' : '#F5F5F7';
        const textColor = isDark ? '#F5F5F7' : '#1D1D1F';
        const secColor = isDark ? '#98989D' : '#86868B';
        
        // Frame initiale
        ctx.fillStyle = bgColor;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = textColor;
        ctx.font = 'bold 48px -apple-system, sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('üé¨ R√©capitulatif', canvas.width / 2, 80);
        ctx.font = '28px -apple-system, sans-serif';
        ctx.fillStyle = secColor;
        ctx.fillText(`${state.history.length} manches`, canvas.width / 2, 130);
        frames.push(canvas.toDataURL('image/png'));
        
        // Frames progression
        const step = Math.max(1, Math.floor(state.history.length / 15));
        
        for (let i = 0; i <= state.history.length; i += step) {
            if (i > state.history.length) i = state.history.length;
            
            ctx.fillStyle = bgColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Titre
            ctx.fillStyle = textColor;
            ctx.font = 'bold 32px -apple-system, sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(`Manche ${i}/${state.history.length}`, canvas.width / 2, 60);
            
            // Calculer les totaux actuels
            const currentTotals = state.players.map(p => {
                let total = 0;
                state.history.slice(0, i).forEach(r => total += r[p.id] || 0);
                return { ...p, currentTotal: total };
            }).sort((a, b) => b.currentTotal - a.currentTotal);
            
            // Afficher les scores
            const startY = 120;
            const barHeight = 50;
            const spacing = 70;
            const maxScore = Math.max(...currentTotals.map(p => p.currentTotal), 1);
            
            currentTotals.forEach((p, idx) => {
                const y = startY + idx * spacing;
                const barWidth = (p.currentTotal / maxScore) * 500;
                
                // Barre de score
                ctx.fillStyle = p.color;
                ctx.fillRect(150, y, barWidth, barHeight);
                
                // Nom
                ctx.fillStyle = textColor;
                ctx.font = 'bold 24px -apple-system, sans-serif';
                ctx.textAlign = 'left';
                ctx.fillText(p.name, 20, y + 33);
                
                // Score
                ctx.textAlign = 'right';
                ctx.fillText(p.currentTotal, 750, y + 33);
            });
            
            frames.push(canvas.toDataURL('image/png'));
        }
        
        // Frame finale avec podium
        ctx.fillStyle = bgColor;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = textColor;
        ctx.font = 'bold 48px -apple-system, sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('üèÜ VICTOIRE', canvas.width / 2, 80);
        
        const sorted = [...state.players].sort((a, b) => b.total - a.total);
        ctx.font = 'bold 36px -apple-system, sans-serif';
        ctx.fillStyle = sorted[0].color;
        ctx.fillText(sorted[0].name, canvas.width / 2, 140);
        ctx.font = 'bold 48px -apple-system, sans-serif';
        ctx.fillText(sorted[0].total + ' pts', canvas.width / 2, 200);
        
        frames.push(canvas.toDataURL('image/png'));
        
        return frames;
    },
    
    async shareGif(gifDataUrl) {
        try {
            const blob = await (await fetch(gifDataUrl)).blob();
            
            if (navigator.share && navigator.canShare) {
                const file = new File([blob], 'scoremaster.gif', { type: 'image/gif' });
                
                if (navigator.canShare({ files: [file] })) {
                    await navigator.share({
                        files: [file],
                        title: 'ScoreMaster - R√©cap anim√©',
                        text: 'D√©couvrez le r√©capitulatif anim√© !'
                    });
                    return true;
                }
            }
            
            // Fallback: download
            const link = document.createElement('a');
            link.download = `scoremaster_${Date.now()}.gif`;
            link.href = gifDataUrl;
            link.click();
            return true;
        } catch (error) {
            console.error('[GifGenerator] Share error:', error);
            return false;
        }
    }
};

    
    // ==================== STATS ENGINE COMPLET ====================
    const StatsEngine = {
        calculateStats(games) {
            const allPlayers = new Map();
            
            games.forEach(game => {
                game.state.players.forEach(player => {
                    if (!allPlayers.has(player.name)) {
                        allPlayers.set(player.name, {
                            name: player.name,
                            color: player.color,
                            gamesPlayed: 0,
                            wins: 0,
                            totalScore: 0,
                            bestScore: 0,
                            worstScore: Infinity,
                            avgScore: 0
                        });
                    }
                    
                    const stats = allPlayers.get(player.name);
                    stats.gamesPlayed++;
                    stats.totalScore += player.total;
                    stats.bestScore = Math.max(stats.bestScore, player.total);
                    stats.worstScore = Math.min(stats.worstScore, player.total);
                    
                    const sorted = [...game.state.players].sort((a,b) => b.total - a.total);
                    if (sorted[0].name === player.name) {
                        stats.wins++;
                    }
                });
            });
            
            allPlayers.forEach(stats => {
                stats.avgScore = Math.round(stats.totalScore / stats.gamesPlayed);
                stats.winRate = ((stats.wins / stats.gamesPlayed) * 100).toFixed(1);
            });
            
            return Array.from(allPlayers.values()).sort((a, b) => b.wins - a.wins);
        },
        
        getRecordScores(games) {
            let highestScore = { score: 0, player: '', game: null };
            let lowestScore = { score: Infinity, player: '', game: null };
            let biggestWin = { gap: 0, winner: '', game: null };
            let closestGame = { gap: Infinity, winner: '', game: null };
            
            games.forEach(game => {
                const sorted = [...game.state.players].sort((a,b) => b.total - a.total);
                
                if (sorted[0] && sorted[0].total > highestScore.score) {
                    highestScore = { score: sorted[0].total, player: sorted[0].name, game: game };
                }
                
                if (sorted[sorted.length - 1] && sorted[sorted.length - 1].total < lowestScore.score) {
                    lowestScore = { score: sorted[sorted.length - 1].total, player: sorted[sorted.length - 1].name, game: game };
                }
                
                if (sorted.length > 1) {
                    const gap = sorted[0].total - sorted[1].total;
                    if (gap > biggestWin.gap) {
                        biggestWin = { gap: gap, winner: sorted[0].name, game: game };
                    }
                    if (gap < closestGame.gap) {
                        closestGame = { gap: gap, winner: sorted[0].name, game: game };
                    }
                }
            });
            
            return { highestScore, lowestScore, biggestWin, closestGame };
        }
    };
    
    // ==================== PWA MANAGER ====================
    const PWA = {
        init() {
            if ('serviceWorker' in navigator) {
                this.registerServiceWorker();
            }
            this.setupInstallPrompt();
        },
        
        async registerServiceWorker() {
            try {
                const swCode = `
                    const CACHE_NAME = 'scoremaster-v1.2';
                    const urlsToCache = ['/'];
                    
                    self.addEventListener('install', (event) => {
                        event.waitUntil(
                            caches.open(CACHE_NAME)
                                .then(cache => cache.addAll(urlsToCache))
                        );
                    });
                    
                    self.addEventListener('fetch', (event) => {
                        event.respondWith(
                            caches.match(event.request)
                                .then(response => response || fetch(event.request))
                        );
                    });
                `;
                
                const blob = new Blob([swCode], { type: 'application/javascript' });
                const swUrl = URL.createObjectURL(blob);
                
                const registration = await navigator.serviceWorker.register(swUrl);
                console.log('[PWA] Service Worker registered');
            } catch (error) {
                console.error('[PWA] SW registration failed:', error);
            }
        },
        
        setupInstallPrompt() {
            let deferredPrompt = null;
            
            window.addEventListener('beforeinstallprompt', (e) => {
                e.preventDefault();
                deferredPrompt = e;
                this.addInstallButton(deferredPrompt);
            });
            
            window.addEventListener('appinstalled', () => {
                console.log('[PWA] App installed');
                UI.showToast('‚úÖ App install√©e !', 'success');
            });
        },
        
        addInstallButton(deferredPrompt) {
            const installBtn = document.createElement('button');
            installBtn.className = 'btn-stats';
            installBtn.innerHTML = 'üì•';
            installBtn.title = 'Installer l\'app';
            installBtn.onclick = () => this.installApp(deferredPrompt);
            
            const header = document.querySelector('.header-controls div');
            if (header) {
                header.insertBefore(installBtn, header.lastElementChild);
            }
        },
        
        async installApp(deferredPrompt) {
            if (!deferredPrompt) return;
            deferredPrompt.prompt();
            const { outcome } = await deferredPrompt.userChoice;
            if (outcome === 'accepted') {
                console.log('[PWA] User accepted install');
            }
            deferredPrompt = null;
        }
    };
</script>

</body>
</html>