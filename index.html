<!DOCTYPE html>

<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="theme-color" content="#007AFF" media="(prefers-color-scheme: light)">
    <meta name="theme-color" content="#0A84FF" media="(prefers-color-scheme: dark)">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="ScoreMaster">
    <meta name="description" content="Gestionnaire de scores pour belote, coinche et jeux de cartes avec statistiques avanc√©es">
    <meta name="keywords" content="belote, coinche, score, cartes, jeu, statistiques">

```
<!-- PWA Manifest -->
<link rel="manifest" href="manifest.json">

<!-- Apple Touch Icons -->
<link rel="apple-touch-icon" href="icon-180.png">
<link rel="apple-touch-icon" sizes="180x180" href="icon-180.png">
<link rel="apple-touch-icon" sizes="192x192" href="icon-192.png">
<link rel="apple-touch-icon" sizes="512x512" href="icon-512.png">

<!-- Favicon -->
<link rel="icon" type="image/png" sizes="192x192" href="icon-192.png">
<link rel="icon" type="image/png" sizes="512x512" href="icon-512.png">

<title>ScoreMaster PWA v13</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>
<style>
    /* --- VARIABLES & THEME --- */
    :root {
        --primary: #007AFF; --bg: #F5F5F7; --card: #FFFFFF; --text: #1D1D1F;
        --text-sec: #86868B; --border: #E5E5EA; --dealer: #FF9500; 
        --danger: #FF3B30; --success: #34C759; 
        
        /* Glassmorphism Vars */
        --glass-bg: rgba(255, 255, 255, 0.65);
        --glass-border: rgba(255, 255, 255, 0.5);
        --glass-shadow: 0 15px 35px rgba(0,0,0,0.1), 0 5px 15px rgba(0,0,0,0.05);
        --glass-blur: 20px;
        
        /* Gradients */
        --bg-gradient: radial-gradient(circle at 50% 0%, #ffffff, #F5F5F7);
    }
    :root[data-theme="dark"] {
        --primary: #0A84FF; --bg: #000000; --card: #1C1C1E; --text: #F5F5F7;
        --text-sec: #98989D; --border: #38383A; 
        
        --glass-bg: rgba(28, 28, 30, 0.65);
        --glass-border: rgba(255, 255, 255, 0.1);
        --glass-shadow: 0 15px 35px rgba(0,0,0,0.4), 0 5px 15px rgba(0,0,0,0.2);
        
        --bg-gradient: radial-gradient(circle at 50% 0%, #2c2c2e, #000000);
    }
    @media (prefers-color-scheme: dark) {
        :root:not([data-theme="light"]) {
            --primary: #0A84FF; --bg: #000000; --card: #1C1C1E; --text: #F5F5F7;
            --text-sec: #98989D; --border: #38383A; 
            --glass-bg: rgba(28, 28, 30, 0.65);
            --glass-border: rgba(255, 255, 255, 0.1);
            --glass-shadow: 0 15px 35px rgba(0,0,0,0.4), 0 5px 15px rgba(0,0,0,0.2);
            --bg-gradient: radial-gradient(circle at 50% 0%, #2c2c2e, #000000);
        }
    }
    * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-family: -apple-system, system-ui, sans-serif; }
    
    html {
        height: -webkit-fill-available;
    }
    
    body { 
        margin: 0; 
        background: var(--bg);
        background-attachment: fixed;
        color: var(--text); 
        padding-bottom: 140px; 
        transition: background 0.3s;
        min-height: 100vh;
        min-height: -webkit-fill-available;
    }
    
    body::before {
        content: '';
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: var(--bg-gradient);
        z-index: -1;
    }
    
    .container { 
        max-width: 600px; 
        margin: 0 auto; 
        padding: 20px; 
        padding-top: max(20px, env(safe-area-inset-top)); 
        animation: slideIn 0.4s ease-out; 
        position: relative; 
        z-index: 1; 
    }
    .hidden { display: none !important; }
    
    /* Typography Helpers */
    .text-huge { font-size: 28px; font-weight: 900; }
    .text-center { text-align: center; }

    /* --- ANIMATIONS --- */
    @keyframes slideIn { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }
    @keyframes rankPop { 0% { transform: scale(1); } 50% { transform: scale(1.1); } 100% { transform: scale(1); } }
    @keyframes badgeBounce { 0%, 100% { transform: scale(1) rotate(0deg); } 25% { transform: scale(1.3) rotate(-10deg); } 75% { transform: scale(1.3) rotate(10deg); } }
    @keyframes scoreBump { 0% { transform: scale(1); } 50% { transform: scale(1.15); } 100% { transform: scale(1); } }
    @keyframes victoryPop { 0% { transform: scale(0.8); opacity: 0; } 100% { transform: scale(1); opacity: 1; } }

    /* --- GLASSMORPHISM COMPONENTS --- */
    .modal-overlay { 
        position: fixed; inset: 0; 
        background: rgba(0,0,0,0.1); 
        backdrop-filter: blur(8px); 
        -webkit-backdrop-filter: blur(8px);
        z-index: 4000; 
        display: flex; 
        align-items: center; 
        justify-content: center; 
        padding: 20px; 
        opacity: 0; 
        pointer-events: none; 
        transition: 0.2s; 
    }
    .modal-overlay.active { opacity: 1; pointer-events: auto; }
    
    .modal-box, .sheet-content, .victory-box { 
        background: var(--glass-bg);
        backdrop-filter: blur(var(--glass-blur)) saturate(180%);
        -webkit-backdrop-filter: blur(var(--glass-blur)) saturate(180%);
        border: 1px solid var(--glass-border);
        box-shadow: var(--glass-shadow);
    }

    .modal-box { 
        width: 100%; max-width: 340px; border-radius: 28px; padding: 25px; text-align: center; 
    }
    .modal-box.large { max-width: 500px; text-align: left; max-height: 80vh; overflow-y: auto; }
    
    .sheet-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.2); z-index: 3000; opacity: 0; pointer-events: none; transition: 0.3s; display: flex; align-items: flex-end; }
    .sheet-overlay.active { opacity: 1; pointer-events: auto; }
    .sheet-content { 
        width: 100%; border-radius: 35px 35px 0 0; padding: 25px 20px calc(25px + env(safe-area-inset-bottom)); 
        transform: translateY(100%); transition: 0.4s cubic-bezier(0.1, 0.9, 0.2, 1);
    }
    .sheet-overlay.active .sheet-content { transform: translateY(0); }

    /* --- UI ELEMENTS --- */
    .header-controls { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; }
    .theme-toggle, .btn-stats, .btn-focus { 
        background: var(--glass-bg);
        backdrop-filter: blur(10px);
        border: 1px solid var(--glass-border); 
        width: 44px; height: 44px; border-radius: 12px; font-size: 20px; cursor: pointer; transition: all 0.3s; display:flex; align-items:center; justify-content:center; box-shadow: 0 4px 10px rgba(0,0,0,0.05);
    }
    .btn-stats:active, .theme-toggle:active, .btn-focus:active { transform: scale(0.9); }
    .btn-stats { color:var(--primary); }
    .btn-focus { color: var(--primary); }

    .welcome-title { font-size: 42px; font-weight: 900; text-align: center; margin-top: 40px; letter-spacing: -2px; background: linear-gradient(120deg, var(--text), var(--primary)); -webkit-background-clip: text; -webkit-text-fill-color: transparent;}

    .mode-btn { background: var(--card); border: 1px solid var(--border); border-radius: 24px; padding: 20px; margin-bottom: 12px; box-shadow: 0 4px 15px rgba(0,0,0,0.05); cursor: pointer; display: flex; align-items: center; gap: 15px; transition: all 0.2s; }
    .mode-btn:hover { transform: translateY(-2px); box-shadow: 0 10px 25px rgba(0,0,0,0.1); }
    .mode-btn:active { transform: translateY(0); }

    .guide-container { margin-top: 30px; background: var(--card); border-radius: 24px; padding: 20px; border: 1px solid var(--border); font-size: 13px; color: var(--text-sec); }

    .game-item { background: var(--card); border: 1px solid var(--border); border-radius: 20px; padding: 16px; margin-bottom: 12px; cursor: pointer; display: flex; justify-content: space-between; align-items: center; transition: all 0.2s; }
    .game-item:hover { border-color: var(--primary); transform: translateX(4px); box-shadow: 0 5px 15px rgba(0,0,0,0.05); }
    .game-mode-badge { display: inline-block; padding: 3px 8px; border-radius: 8px; font-size: 10px; font-weight: 900; margin-left: 8px; }
    .badge-belote { background: #FF9500; color: white; }
    .badge-standard { background: #007AFF; color: white; }
    .game-players-list { display: flex; gap: 8px; margin-top: 8px; flex-wrap: wrap; }
    .game-player-score { font-size: 11px; padding: 4px 8px; border-radius: 8px; font-weight: 700; }
    .game-actions { display: flex; gap: 8px; }
    .game-actions button { background: none; border: none; font-size: 18px; padding: 8px; cursor: pointer; transition: transform 0.2s; }
    .game-actions button:active { transform: scale(0.9); }

    .chart-box { background: var(--glass-bg); backdrop-filter: blur(10px); border-radius: 24px; padding: 15px; height: 200px; margin-bottom: 25px; border: 1px solid var(--border); box-shadow: 0 5px 15px rgba(0,0,0,0.05); transition: opacity 0.5s ease; }
    
    .players-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(130px, 1fr)); gap: 14px; margin-bottom: 30px; transition: all 0.5s cubic-bezier(0.34, 1.56, 0.64, 1); }
    
    .p-card { background: var(--card); padding: 22px 10px; border-radius: 26px; text-align: center; position: relative; border: 3px solid transparent; box-shadow: 0 8px 20px rgba(0,0,0,0.05); transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1), border-color 0.3s; overflow: visible; }
    .p-card.is-dealer { border-color: var(--dealer); }
    .p-card.rank-change { animation: rankPop 0.6s cubic-bezier(0.34, 1.56, 0.64, 1); }
    
    .rank-badge { position: absolute; top: -12px; left: 12px; font-size: 13px; padding: 4px 10px; border-radius: 12px; font-weight: 900; color: white; box-shadow: 0 4px 8px rgba(0,0,0,0.2); transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1); z-index: 10; }
    .rank-badge.bounce { animation: badgeBounce 0.6s cubic-bezier(0.34, 1.56, 0.64, 1); }
    
    /* Cacher compl√®tement le badge en mode Zen */
    .focus-mode .rank-badge {
        display: none;
    }
    
    /* Ajuster les cartes en mode Zen pour que le nom soit visible et le score temp pas coup√© */
    .focus-mode .p-card {
        padding: 12px 8px 22px 8px;
        overflow: visible;
    }
    
    .focus-mode .p-name-btn {
        font-size: 11px;
        margin-bottom: 6px;
        padding: 3px 8px;
    }
    
    .focus-mode .p-score {
        font-size: 38px;
    }
    
    .focus-mode .p-temp {
        font-size: 13px;
        margin-top: 4px;
    }
    
    .badge-1 { background: #FFD700; }
    .badge-2 { background: #C0C0C0; }
    .badge-3 { background: #CD7F32; }
    .badge-none { background: var(--text-sec); opacity: 0.5; }

    .p-name-btn { font-size: 12px; font-weight: 900; text-transform: uppercase; cursor: pointer; display: inline-block; padding: 4px 10px; border: 1px solid var(--border); border-radius: 10px; margin-bottom: 8px; }
    .p-score { font-size: 44px; font-weight: 900; cursor: pointer; line-height: 1; letter-spacing: -2px; transition: transform 0.2s ease-out; }
    .p-score.score-bump { animation: scoreBump 0.4s ease-out; }
    .p-temp { font-size: 15px; font-weight: 800; color: var(--primary); min-height: 18px; margin-top: 6px; }

    .h-row { background: var(--card); padding: 12px; border-radius: 18px; display: flex; align-items: center; margin-bottom: 8px; border: 1px solid var(--border); gap: 10px; overflow-x: auto; transition: opacity 0.5s ease; }
    .h-idx { font-size: 10px; font-weight: 900; color: var(--text-sec); min-width: 30px; flex-shrink: 0; }
    .h-scores { display: flex; flex: 1; justify-content: space-between; align-items: center; min-width: max-content; padding-right: 5px; cursor: pointer; }
    .h-score-item { text-align: center; min-width: 50px; padding: 0 5px; }

    .sel-box { 
        background: var(--card); 
        padding: 12px; 
        border-radius: 18px; 
        text-align: center; 
        flex: 1; 
        border: 3px solid transparent; 
        min-width: 80px; 
        transition: transform 0.2s cubic-bezier(0.34, 1.56, 0.64, 1), border-color 0.2s; 
        position: relative;
        z-index: 1;
        margin-bottom: 0;
    }
    .sel-box.active { 
        border-color: var(--p-color); 
        transform: scale(1.04);
        box-shadow: 0 5px 15px rgba(0,0,0,0.05);
        z-index: 2;
    }
    .numpad { display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; }
    .btn-nb { background: var(--card); border: none; height: 58px; border-radius: 16px; font-size: 22px; font-weight: 700; color: var(--text); box-shadow: 0 3px 0 var(--border); cursor: pointer; }
    .btn-nb:active { transform: translateY(3px); box-shadow: none; }

    .dock { 
        position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%); width: 90%; max-width: 450px; z-index: 2000; 
        background: var(--glass-bg);
        backdrop-filter: blur(25px) saturate(200%);
        -webkit-backdrop-filter: blur(25px) saturate(200%);
        border: 1px solid var(--glass-border);
        box-shadow: var(--glass-shadow);
        border-radius: 26px;
        transition: opacity 0.5s ease;
    }
    .btn-main { width: 100%; background: var(--text); color: var(--bg); border: none; padding: 20px; border-radius: 20px; font-size: 16px; font-weight: 900; box-shadow: 0 5px 15px rgba(0,0,0,0.1); cursor: pointer; transition: transform 0.1s; }
    .btn-main:active { transform: scale(0.98); }
    .btn-main.editing { background: var(--dealer); color: #000; }
```

/* ‚Äî OVERLAY FOND MODE ZEN ‚Äî */
.zen-overlay {
position: fixed;
inset: 0;
background: var(‚Äìbg);
z-index: 50;
opacity: 0;
pointer-events: none;
transition: opacity 0.6s cubic-bezier(0.4, 0, 0.2, 1);
}

```
    .focus-mode .zen-overlay {
        opacity: 1;
        pointer-events: auto;
    }

    .focus-mode #dock {
        opacity: 1 !important;
        pointer-events: auto !important;
        transform: translateX(-50%) !important;
        z-index: 200;
        animation: dockSlideUp 0.6s cubic-bezier(0.34, 1.56, 0.64, 1) 0.3s backwards;
    }

    @keyframes dockSlideUp {
        0% { opacity: 0; transform: translateX(-50%) translateY(50px); }
        100% { opacity: 1; transform: translateX(-50%) translateY(0); }
    }
```

/* ‚Äî LE BOUTON OEIL EN MODE ZEN ‚Äî */
.focus-mode .btn-focus {
position: fixed;
top: max(15px, env(safe-area-inset-top));
right: 15px;
z-index: 2000;
background: var(‚Äìcard);
border: 1px solid var(‚Äìprimary);
color: var(‚Äìprimary);
box-shadow: 0 5px 15px rgba(0,0,0,0.2);
transform: scale(1.1);
}

.focus-mode header > *:not(.btn-focus) {
opacity: 0;
pointer-events: none;
}

/* Masquer les √©l√©ments non essentiels en mode Zen */
.focus-mode .chart-box,
.focus-mode #history,
.focus-mode #history-header {
opacity: 0;
pointer-events: none;
position: absolute;
}

/* ‚Äî CORRECTION DE LA GRILLE (Plus de fond noir vide) ‚Äî */
.focus-mode .players-grid {
position: fixed;
top: 0;
left: 0;
width: 100%;
height: 100vh;
height: 100dvh;
padding: max(20px, env(safe-area-inset-top)) 15px calc(100px + env(safe-area-inset-bottom)) 15px;
margin: 0;
display: grid;
grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
align-content: center;
gap: 15px;
z-index: 100;
transform: none !important;
opacity: 1 !important;
animation: simpleFadeIn 0.3s ease-out backwards;
overflow-y: auto;
-webkit-overflow-scrolling: touch;
}

@keyframes simpleFadeIn {
from { opacity: 0; }
to { opacity: 1; }
}

.focus-mode .p-card {
display: flex;
flex-direction: column;
justify-content: center;
align-items: center;
height: 100%;
min-height: 140px;
padding: 20px;
box-shadow: 0 10px 40px rgba(0,0,0,0.15);
border-width: 0;
background: var(‚Äìcard);
animation: none !important;
transition: none !important;
}

.focus-mode .p-card:nth-child(n) { animation-delay: 0s; }

.focus-mode .rank-change { animation: none !important; }

.focus-mode .p-score {
font-size: 68px !important;
letter-spacing: -3px;
}

.focus-mode .p-score:active {
animation: scoreClick 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
}

@keyframes scoreClick {
0% { transform: scale(1); }
50% { transform: scale(0.92); }
100% { transform: scale(1); }
}

.focus-mode .rank-badge {
font-size: 22px;
padding: 10px 18px;
top: -18px;
left: 18px;
animation: badgePopIn 0.4s cubic-bezier(0.34, 1.56, 0.64, 1) 0.8s backwards;
}

@keyframes badgePopIn {
0% { opacity: 0; transform: scale(0) rotate(-180deg); }
100% { opacity: 1; transform: scale(1) rotate(0deg); }
}

.focus-mode .p-name-btn {
font-size: 15px;
padding: 7px 16px;
}

.focus-mode .p-temp {
font-size: 20px;
margin-top: 12px;
}

.focus-mode-cta {
position: fixed;
bottom: 300px;
right: 20px;
top: auto;
background: var(‚Äìprimary);
color: white;
box-shadow: 0 4px 15px rgba(0,0,0,0.3);
border: none;
padding: 12px 20px;
border-radius: 30px;
font-weight: 800;
font-size: 13px;
z-index: 9999;
cursor: pointer;
opacity: 0;
pointer-events: none;
transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
transform: translateY(20px) scale(0.9);
}

@keyframes ctaSlideIn {
0% { opacity: 0; transform: translateX(100px); }
100% { opacity: 1; transform: translateX(0); }
}

.focus-mode .focus-mode-cta {
opacity: 1;
pointer-events: auto;
transform: translateY(0) scale(1);
}
.focus-mode-cta:active { transform: scale(0.95); }

/* ‚Äî STATS STYLES ‚Äî */
.stats-tabs { display: flex; gap: 10px; margin-bottom: 20px; border-bottom: 1px solid var(‚Äìborder); padding-bottom: 10px; }
.stats-tab { flex: 1; text-align: center; padding: 10px; border-radius: 10px; cursor: pointer; font-weight: 700; font-size: 14px; opacity: 0.5; transition: 0.3s; }
.stats-tab.active { opacity: 1; background: var(‚Äìprimary); color: white; box-shadow: 0 4px 10px rgba(0,0,0,0.1); }

.mode-filter {
display: flex;
gap: 8px;
margin-bottom: 15px;
padding: 0 5px;
}

.filter-btn, .filter-btn-records {
flex: 1;
padding: 8px 12px;
border-radius: 10px;
border: 1px solid var(‚Äìborder);
background: var(‚Äìcard);
font-size: 12px;
font-weight: 700;
cursor: pointer;
transition: all 0.2s;
color: var(‚Äìtext);
}

.filter-btn.active, .filter-btn-records.active {
background: var(‚Äìprimary);
color: white;
border-color: var(‚Äìprimary);
}

.rank-item { display: flex; align-items: center; padding: 12px; border-bottom: 1px solid var(‚Äìborder); cursor: pointer; transition: background 0.2s; }
.rank-item:hover { background: rgba(0,0,0,0.03); }
.rank-item:last-child { border-bottom: none; }
.rank-num { font-size: 20px; font-weight: 900; width: 30px; color: var(‚Äìtext-sec); font-style: italic; }
.rank-1 .rank-num { color: #FFD700; } .rank-2 .rank-num { color: #C0C0C0; } .rank-3 .rank-num { color: #CD7F32; }
.rank-info { flex: 1; }
.rank-name { font-weight: 900; font-size: 16px; }
.rank-sub { font-size: 12px; color: var(‚Äìtext-sec); }
.rank-val { font-weight: 800; font-size: 18px; }

.stat-detail { background: var(‚Äìcard); padding: 15px; border-radius: 15px; margin-bottom: 15px; border: 1px solid var(‚Äìborder); }
.stat-detail h4 { margin: 0 0 5px 0; font-size: 12px; text-transform: uppercase; color: var(‚Äìtext-sec); }
.stat-detail .value { font-size: 24px; font-weight: 900; color: var(‚Äìtext); }

.toast {
position: fixed;
top: max(60px, calc(env(safe-area-inset-top) + 40px));
left: 50%;
transform: translateX(-50%) translateY(-100px);
background: var(‚Äìglass-bg);
backdrop-filter: blur(20px);
-webkit-backdrop-filter: blur(20px);
border: 1px solid var(‚Äìglass-border);
padding: 16px 24px;
border-radius: 20px;
box-shadow: var(‚Äìglass-shadow);
font-weight: 700;
z-index: 5000;
opacity: 0;
transition: all 0.3s;
white-space: nowrap;
}
.toast.show { opacity: 1; transform: translateX(-50%) translateY(0); }
.toast.success { border-color: var(‚Äìsuccess); background: var(‚Äìsuccess); color: white; border: none; }
.toast.warning { border-color: var(‚Äìdealer); background: var(‚Äìdealer); color: white; border: none; }
.toast.error { border-color: var(‚Äìdanger); background: var(‚Äìdanger); color: white; border: none; }

.victory-overlay {
position: fixed; inset: 0; background: rgba(0,0,0,0.6); backdrop-filter: blur(10px); z-index: 6000;
display: flex; align-items: center; justify-content: center; opacity: 0; pointer-events: none;
transition: 0.3s; overflow-y: auto; padding: 20px;
}
.victory-overlay.active { opacity: 1; pointer-events: auto; }

.podium-container { display: flex; align-items: flex-end; justify-content: center; gap: 8px; margin: 30px 0; height: 180px; }
.podium-place { flex: 1; max-width: 110px; display: flex; flex-direction: column; align-items: center; animation: podiumRise 0.6s cubic-bezier(0.34, 1.56, 0.64, 1); }
.podium-place.p1 { animation-delay: 0.2s; } .podium-place.p2 { animation-delay: 0s; } .podium-place.p3 { animation-delay: 0.1s; }
.podium-avatar {
width: 60px; height: 60px; border-radius: 50%; display: flex; align-items: center; justify-content: center;
font-size: 28px; font-weight: 900; margin-bottom: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.2); position: relative;
}
.podium-crown { position: absolute; top: -15px; font-size: 24px; animation: badgeBounce 1s infinite; }
.podium-name { font-size: 11px; font-weight: 900; text-align: center; margin-bottom: 6px; }
.podium-score { font-size: 16px; font-weight: 900; margin-bottom: 8px; }
.podium-bar {
width: 100%; border-radius: 12px 12px 0 0; display: flex; align-items: center; justify-content: center;
font-size: 32px; font-weight: 900; color: white; box-shadow: 0 -2px 8px rgba(0,0,0,0.1);
}
.podium-place.p1 .podium-bar { background: #FFD700; height: 100px; }
.podium-place.p2 .podium-bar { background: #C0C0C0; height: 70px; }
.podium-place.p3 .podium-bar { background: #CD7F32; height: 50px; }

.victory-tabs { display: flex; gap: 8px; margin-bottom: 20px; border-bottom: 2px solid var(‚Äìborder); padding-bottom: 8px; }
.victory-tab { flex: 1; text-align: center; padding: 10px 8px; border-radius: 8px; cursor: pointer; font-weight: 700; font-size: 13px; opacity: 0.5; transition: 0.2s; }
.victory-tab.active { opacity: 1; background: var(‚Äìprimary); color: white; box-shadow: 0 4px 10px rgba(0,0,0,0.15); }

.highlight-card { background: rgba(0,0,0,0.03); padding: 12px; border-radius: 12px; margin-bottom: 10px; display: flex; align-items: center; gap: 12px; border: 1px solid var(‚Äìborder); }
.highlight-icon { font-size: 28px; }
.highlight-text { flex: 1; }
.highlight-label { font-size: 11px; color: var(‚Äìtext-sec); font-weight: 600; }
.highlight-value { font-size: 14px; font-weight: 900; }

.player-stats-row { display: flex; align-items: center; padding: 10px; border-bottom: 1px solid var(‚Äìborder); }
.player-stats-row:last-child { border-bottom: none; }
.player-stats-rank { width: 30px; font-size: 18px; font-weight: 900; }
.player-stats-info { flex: 1; }
.player-stats-name { font-size: 14px; font-weight: 900; }
.player-stats-score { font-size: 16px; font-weight: 900; }

@keyframes podiumRise { from { transform: translateY(100px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }

#confirm-modal .modal-box { text-align: center; }
#confirm-msg { font-size: 18px; margin: 0 0 25px 0; color: var(‚Äìtext); }
.confirm-actions { display: flex; gap: 10px; }
.btn-confirm-no { background: var(‚Äìcard); color: var(‚Äìtext); border: 1px solid var(‚Äìborder); }
.btn-confirm-yes { background: var(‚Äìdanger); color: white; border: 1px solid var(‚Äìdanger); }
</style>

</head>
<body>
    <div id="toast" class="toast"></div>

```
<div id="confirm-modal" class="modal-overlay">
    <div class="modal-box">
        <h3 id="confirm-msg">Confirmer l'action ?</h3>
        <div class="confirm-actions">
            <button class="btn-main btn-confirm-no" onclick="UI.closeConfirm()">Annuler</button>
            <button id="confirm-yes-btn" class="btn-main btn-confirm-yes">Confirmer</button>
        </div>
    </div>
</div>

<div id="stats-modal" class="modal-overlay" onclick="if(event.target===this) UI.closeStats()">
    <div class="modal-box large">
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:20px;">
            <h2 style="margin:0">üìä Statistiques</h2>
            <button onclick="UI.closeStats()" style="background:none; border:none; font-size:24px; color:var(--text); cursor:pointer;">‚úï</button>
        </div>
        <div class="stats-tabs">
            <div id="tab-rank" class="stats-tab active" onclick="UI.switchStatsTab('rank')">Classement</div>
            <div id="tab-records" class="stats-tab" onclick="UI.switchStatsTab('records')">Records</div>
        </div>
        <div id="stats-content-rank">
            <div class="mode-filter">
                <button class="filter-btn active" onclick="UI.filterStats('all')">Tous</button>
                <button class="filter-btn" onclick="UI.filterStats('belote')">üÉè Belote</button>
                <button class="filter-btn" onclick="UI.filterStats('standard')">üé≤ Standard</button>
            </div>
            <div id="ranking-list"></div>
        </div>
        <div id="stats-content-player" class="hidden">
            <button onclick="UI.showRanking()" style="background:none; border:none; color:var(--primary); font-weight:700; font-size:14px; margin-bottom:10px; cursor:pointer;">‚Üê Retour au classement</button>
            <div id="player-detail-content"></div>
        </div>
        <div id="stats-content-records" class="hidden">
            <div class="mode-filter">
                <button class="filter-btn-records active" onclick="UI.filterRecords('all')">Tous</button>
                <button class="filter-btn-records" onclick="UI.filterRecords('belote')">üÉè Belote</button>
                <button class="filter-btn-records" onclick="UI.filterRecords('standard')">üé≤ Standard</button>
            </div>
            <div id="records-list"></div>
        </div>
    </div>
</div>

<div id="modal-player-count" class="modal-overlay" onclick="if(event.target===this) document.getElementById('modal-player-count').classList.remove('active')">
    <div class="modal-box" style="max-width: 400px;">
        <h2 style="margin:0 0 10px 0" id="mode-setup-title">Mode Standard</h2>
        <p style="color:var(--text-sec); margin-bottom:20px;">Combien de joueurs ?</p>
        <div style="display:grid; grid-template-columns: repeat(3, 1fr); gap:10px; margin-bottom:25px;">
            <button class="btn-nb" onclick="app.selectPlayerCount(2)">2</button>
            <button class="btn-nb" onclick="app.selectPlayerCount(3)">3</button>
            <button class="btn-nb" onclick="app.selectPlayerCount(4)">4</button>
            <button class="btn-nb" onclick="app.selectPlayerCount(5)">5</button>
            <button class="btn-nb" onclick="app.selectPlayerCount(6)">6</button>
            <button id="btn-toggle-players" class="btn-nb" style="background:rgba(120,120,128,0.12); font-size:14px;" onclick="app.toggleMorePlayers()">Plus ‚ñº</button>
            <div id="extra-players" class="hidden" style="grid-column: 1 / -1; display:contents;">
                <button class="btn-nb" onclick="app.selectPlayerCount(7)">7</button>
                <button class="btn-nb" onclick="app.selectPlayerCount(8)">8</button>
                <button class="btn-nb" onclick="app.selectPlayerCount(9)">9</button>
                <button class="btn-nb" onclick="app.selectPlayerCount(10)">10</button>
                <button class="btn-nb" onclick="app.selectPlayerCount(11)">11</button>
                <button class="btn-nb" onclick="app.selectPlayerCount(12)">12</button>
            </div>
        </div>
        
        <!-- Nouvelles options -->
        <div style="border-top: 1px solid var(--border); padding-top: 20px; margin-top: 10px;">
            <div style="margin-bottom: 20px;">
                <label style="font-size: 13px; font-weight: 700; color: var(--text); margin-bottom: 10px; display: block;">üéØ Objectif de victoire</label>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                    <label style="display: flex; align-items: center; justify-content: center; background: var(--card); border: 2px solid var(--border); border-radius: 12px; padding: 12px; cursor: pointer; transition: all 0.2s;" id="victory-highest-label">
                        <input type="radio" name="victory-condition" value="highest" checked style="margin-right: 8px; accent-color: var(--primary);" onchange="app.updateVictoryCondition()">
                        <span style="font-size: 12px; font-weight: 700;">‚¨ÜÔ∏è Plus HAUT</span>
                    </label>
                    <label style="display: flex; align-items: center; justify-content: center; background: var(--card); border: 2px solid var(--border); border-radius: 12px; padding: 12px; cursor: pointer; transition: all 0.2s;" id="victory-lowest-label">
                        <input type="radio" name="victory-condition" value="lowest" style="margin-right: 8px; accent-color: var(--primary);" onchange="app.updateVictoryCondition()">
                        <span style="font-size: 12px; font-weight: 700;">‚¨áÔ∏è Plus BAS</span>
                    </label>
                </div>
            </div>
            
            <div>
                <label style="font-size: 13px; font-weight: 700; color: var(--text); margin-bottom: 10px; display: block;">üèÅ Condition de fin</label>
                <div style="display: grid; gap: 8px;">
                    <label style="display: flex; align-items: center; background: var(--card); border: 2px solid var(--border); border-radius: 12px; padding: 12px; cursor: pointer;" id="end-free-label">
                        <input type="radio" name="end-condition" value="free" checked style="margin-right: 10px; accent-color: var(--primary);" onchange="app.updateEndCondition()">
                        <span style="font-size: 12px; font-weight: 700; flex: 1;">‚ôæÔ∏è Partie libre</span>
                    </label>
                    <label style="display: flex; align-items: center; background: var(--card); border: 2px solid var(--border); border-radius: 12px; padding: 12px; cursor: pointer;" id="end-score-label">
                        <input type="radio" name="end-condition" value="score" style="margin-right: 10px; accent-color: var(--primary);" onchange="app.updateEndCondition()">
                        <span style="font-size: 12px; font-weight: 700; flex: 1;" id="score-label-text">üéØ Score objectif :</span>
                        <input type="number" id="score-target" value="100" min="10" max="9999" style="width: 70px; padding: 6px; border: 1px solid var(--border); border-radius: 8px; font-size: 14px; font-weight: 700; text-align: center; background: var(--bg); color: var(--text);" onclick="event.stopPropagation(); document.querySelector('input[name=end-condition][value=score]').checked = true; app.updateEndCondition();">
                    </label>
                </div>
            </div>
        </div>
    </div>
</div>

<div id="setup" class="container">
    <div class="header-controls">
        <h1 class="welcome-title" style="margin:0; flex:1;">ScoreMaster</h1>
        <div style="display:flex; gap:10px;">
            <button class="btn-stats" onclick="app.showStats()" title="Statistiques">üìä</button>
            <button id="theme-toggle" class="theme-toggle" onclick="app.toggleTheme()">üåô</button>
        </div>
    </div>
    <div class="mode-btn" onclick="app.showModeSelection('belote')">
        <span style="font-size:30px; margin-right:15px;">üÉè</span>
        <div><h2 style="margin:0">Belote / Coinche</h2><p style="margin:4px 0 0; font-size:12px; color:var(--text-sec)">Points √† 162 ‚Ä¢ Capot 252</p></div>
    </div>
    <div class="mode-btn" onclick="app.showModeSelection('standard')">
        <span style="font-size:30px; margin-right:15px;">üé≤</span>
        <div><h2 style="margin:0">Standard</h2><p style="margin:4px 0 0; font-size:12px; color:var(--text-sec)">Scores libres ‚Ä¢ Jusqu'√† 12 joueurs</p></div>
    </div>
    <div style="margin-top: 40px;">
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:15px;">
            <h3 style="margin:0; font-size:18px; font-weight:900;">üìö Historique des parties</h3>
            <button onclick="app.clearAll()" style="background:none; border:none; color:var(--danger); font-weight:900; font-size:12px; cursor:pointer;">TOUT EFFACER</button>
        </div>
        <div id="games-list"></div>
    </div>
    <div class="guide-container">
        <b style="display:block; margin-bottom:8px; color:var(--text)">üìñ Guide Rapide</b>
        ‚Ä¢ Cliquez sur le <b style="color:var(--text)">NOM</b> pour le donneur üÉè<br>
        ‚Ä¢ Cliquez sur le <b style="color:var(--text)">SCORE</b> pour les points ‚úçÔ∏è<br>
        ‚Ä¢ Cliquez sur l'<b style="color:var(--text)">HISTORIQUE</b> pour corriger ‚úèÔ∏è
    </div>
</div>

<div id="game" class="container hidden">
    <header style="display:flex; justify-content:space-between; align-items:center; margin-bottom:20px;">
        <button onclick="app.showSetup()" style="background:var(--card); border:1px solid var(--border); width:40px; height:40px; border-radius:12px; color:var(--text); cursor:pointer;">‚¨ÖÔ∏è</button>
        <div style="flex:1; text-align:center;">
            <h1 id="mode-title" style="margin:0; font-size:22px; font-weight:900;">SCORE</h1>
            <div id="game-info" style="font-size:10px; color:var(--text-sec); font-weight:700; margin-top:3px;"></div>
        </div>
        <button class="btn-focus" onclick="app.toggleFocusMode()" title="Mode Zen">üëÅÔ∏è</button>
    </header>
    <div class="chart-box"><canvas id="chart"></canvas></div>
    <div id="grid" class="players-grid"></div>
    <div id="history-header" style="display:flex; justify-content:space-between; margin: 30px 0 10px; font-size:11px; font-weight:900; color:var(--text-sec);">
        <span>HISTORIQUE DES MANCHES</span>
        <div style="display:flex; gap:12px;">
            <button onclick="app.finishGame()" style="background:none; border:none; color:var(--success); font-weight:900; cursor:pointer;">‚úì TERMINER</button>
            <button onclick="app.undo()" style="background:none; border:none; color:var(--danger); font-weight:900; cursor:pointer;">ANNULER</button>
        </div>
    </div>
    <div id="history"></div>
</div>

<div id="dock" class="dock hidden">
    <button id="save-btn" class="btn-main" onclick="app.validateRound()">ENREGISTRER MANCHE 1</button>
</div>

<div id="modal-player" class="modal-overlay" onclick="if(event.target===this) app.closeModal()">
    <div class="modal-box">
        <h2 id="modal-title" style="margin:0 0 20px 0">Joueur</h2>
        <input type="text" id="edit-name" style="width:100%; padding:15px; border-radius:12px; border:2px solid var(--border); font-size:18px; font-weight:700; margin-bottom:20px; outline:none; background:var(--bg); color:var(--text);">
        <label style="display:flex; align-items:center; justify-content:space-between; background:var(--bg); padding:15px; border-radius:12px; font-weight:700; cursor:pointer;">
            Donneur üÉè <input type="checkbox" id="edit-dealer" style="width:20px; height:20px; accent-color:var(--dealer);">
        </label>
        <button class="btn-main" style="margin-top:20px; background:var(--primary); color:white" onclick="app.savePlayer()">VALIDER</button>
    </div>
</div>

<div id="sheet" class="sheet-overlay" onclick="app.closeSheet()">
    <div class="sheet-content" onclick="event.stopPropagation()">
        <div id="input-switcher" style="display:flex; gap:8px; margin-bottom:20px; overflow-x:auto; padding: 10px 20px 5px 20px; scroll-snap-type: x mandatory;"></div>
        <div style="display:grid; grid-template-columns: repeat(4, 1fr); gap:8px; margin-bottom:12px;">
            <button id="calc-btn" class="btn-nb hidden" style="grid-column:span 4; background:var(--success); color:white; font-size:14px; box-shadow:none;" onclick="app.calcRest()">‚ú® RESTE √Ä 162</button>
            <button class="btn-nb" style="background:rgba(120,120,128,0.12); font-size:14px; box-shadow:none;" onclick="app.addVal(10)">+10</button>
            <button class="btn-nb" style="background:rgba(120,120,128,0.12); font-size:14px; box-shadow:none;" onclick="app.addVal(20)">+20</button>
            <button id="btn-82" class="btn-nb hidden" style="background:rgba(120,120,128,0.12); font-size:14px; box-shadow:none;" onclick="app.addVal(82)">+82</button>
            <button id="btn-50" class="btn-nb hidden" style="background:rgba(120,120,128,0.12); font-size:14px; box-shadow:none;" onclick="app.addVal(50)">+50</button>
            <button id="smart-btn" class="btn-nb" style="background:var(--text); color:var(--bg); font-size:14px; box-shadow:none;" onclick="app.handleSmart()">+/-</button>
        </div>
        <div class="numpad">
            <button class="btn-nb" onclick="app.typeNum(1)">1</button><button class="btn-nb" onclick="app.typeNum(2)">2</button><button class="btn-nb" onclick="app.typeNum(3)">3</button>
            <button class="btn-nb" onclick="app.typeNum(4)">4</button><button class="btn-nb" onclick="app.typeNum(5)">5</button><button class="btn-nb" onclick="app.typeNum(6)">6</button>
            <button class="btn-nb" onclick="app.typeNum(7)">7</button><button class="btn-nb" onclick="app.typeNum(8)">8</button><button class="btn-nb" onclick="app.typeNum(9)">9</button>
            <button class="btn-nb" style="color:var(--danger)" onclick="app.clearInput()">C</button>
            <button class="btn-nb" onclick="app.typeNum(0)">0</button>
            <button class="btn-nb" onclick="app.backspace()">‚å´</button>
        </div>
        <button class="btn-main" style="margin-top:15px; background:var(--primary); color:white" onclick="app.closeSheet()">OK</button>
    </div>
</div>

<div id="victory" class="victory-overlay">
    <div class="victory-box">
        <h2 class="text-center" style="margin:0 0 10px 0; font-size:28px;">üèÜ PARTIE TERMIN√âE</h2>
        
        <div class="victory-tabs">
            <div class="victory-tab active" onclick="UI.switchVictoryTab('podium')">üèÜ Podium</div>
            <div class="victory-tab" onclick="UI.switchVictoryTab('stats')">üìä Stats</div>
            <div class="victory-tab" onclick="UI.switchVictoryTab('highlights')">‚≠ê Highlights</div>
        </div>

        <div id="victory-tab-podium">
            <div class="podium-container" id="podium"></div>
        </div>

        <div id="victory-tab-stats" class="hidden">
            <div id="victory-all-players"></div>
        </div>

        <div id="victory-tab-highlights" class="hidden">
            <div id="victory-highlights"></div>
        </div>

        <button class="btn-main" style="background:linear-gradient(135deg, #2B5AA0 0%, #1E3F6E 100%); color:white; margin:20px 0 12px; font-size:16px;" onclick="app.shareRecap()">üì∞ PARTAGER LE R√âCAP</button>
        <button class="btn-main" style="background:var(--primary); color:white; margin:0 0 12px;" onclick="app.restartWithSamePlayers()">üîÑ REJOUER (m√™mes joueurs)</button>
        <button class="btn-main" style="background:var(--card); border:1px solid var(--border); color:var(--text);" onclick="app.showSetup()">üè† RETOUR MENU</button>
    </div>
</div>

<script>
    // ==================== SOUND ENGINE ====================
    const SoundFX = {
        ctx: null, enabled: true,
        init() {
            if (!this.ctx && window.AudioContext) {
                try {
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                    if (this.ctx.state === 'suspended') this.ctx.resume();
                } catch (e) { console.warn("Audio API non support√©e"); this.enabled = false; }
            }
        },
        playTone(freq, type, duration) {
            if (!this.enabled || !this.ctx) return;
            if (this.ctx.state === 'suspended') this.ctx.resume();
            try {
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + duration);
            } catch (e) {}
        },
        click() { this.playTone(800, 'sine', 0.1); },
        slide() { 
            if (!this.enabled || !this.ctx) return;
            try {
                const bufferSize = this.ctx.sampleRate * 0.15; 
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
                const noise = this.ctx.createBufferSource();
                noise.buffer = buffer;
                const gain = this.ctx.createGain();
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 400;
                gain.gain.setValueAtTime(0.05, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.15);
                noise.connect(filter);
                filter.connect(gain);
                gain.connect(this.ctx.destination);
                noise.start();
            } catch (e) {}
        },
        success() { this.playTone(600, 'sine', 0.1); setTimeout(() => this.playTone(900, 'sine', 0.2), 100); },
        error() { this.playTone(150, 'sawtooth', 0.3); }
    };

    // ==================== DATA LAYER ====================
    const GameState = {
        create(mode, playerCount) {
            const colors = ['#007AFF', '#FF2D55', '#34C759', '#FF9500', '#AF52DE', '#5AC8FA', '#FFCC00', '#5856D6', '#FF3B30', '#30B0C7', '#8E8E93', '#4CD964'];
            return {
                mode, players: Array.from({length: Math.min(playerCount, 12)}, (_, i) => ({
                    id: i + 1, 
                    name: mode === 'belote' ? (i === 0 ? 'NOUS' : 'EUX') : `J${i + 1}`, 
                    color: colors[i] || '#000000',
                    total: 0, previousRank: null
                })),
                history: [], temp: {}, dealerId: 1, celebratedMilestones: {}
            };
        },
        addRound(state, scores) {
            const round = {};
            state.players.forEach(p => {
                const score = scores[p.id] || 0;
                round[p.id] = score;
                p.total += score;
            });
            state.history.push(round);
            return state;
        },
        updateRound(state, index, scores) {
            const oldRound = state.history[index];
            state.players.forEach(p => p.total -= (oldRound[p.id] || 0));
            const newRound = {};
            state.players.forEach(p => {
                const score = scores[p.id] || 0;
                newRound[p.id] = score;
                p.total += score;
            });
            state.history[index] = newRound;
            return state;
        },
        deleteRound(state, index) {
            const round = state.history[index];
            state.players.forEach(p => p.total -= (round[p.id] || 0));
            state.history.splice(index, 1);
            return state;
        },
        validate(scores, mode) {
            const values = Object.values(scores);
            if(values.some(v => v > 9999)) return { valid: false, error: 'Score trop √©lev√© (max 9999)' };
            if(mode === 'belote' && values.some(v => v < 0)) return { valid: false, error: 'Score n√©gatif impossible en Belote' };
            return { valid: true };
        }
    };

    // ==================== STORAGE LAYER ====================
    const Storage = {
        GAMES_KEY: 'sm_v12_games', CURRENT_KEY: 'sm_v12_current',
        migrateData() {
            const v12Data = localStorage.getItem(this.GAMES_KEY);
            if (!v12Data) {
                const v11Data = localStorage.getItem('sm_v11_games');
                if (v11Data) {
                    try {
                        const parsed = JSON.parse(v11Data);
                        if (Array.isArray(parsed) && parsed.length > 0) {
                            localStorage.setItem(this.GAMES_KEY, v11Data);
                            console.log("SM: Migration v11->v12 OK");
                            const v11Current = localStorage.getItem('sm_v11_current');
                            if (v11Current && parsed.find(g => g.id === v11Current)) {
                                localStorage.setItem(this.CURRENT_KEY, v11Current);
                            }
                        }
                    } catch(e) { console.error("SM: Migration √©chou√©e", e); }
                }
            }
        },
        saveGame(game) {
            try {
                const games = this.loadGames() || [];
                const existing = games.findIndex(g => g.id === game.id);
                if(existing >= 0) games[existing] = game;
                else games.push(game);
                localStorage.setItem(this.GAMES_KEY, JSON.stringify(games));
                localStorage.setItem(this.CURRENT_KEY, game.id);
                return true;
            } catch(e) {
                console.error("SM: Save failed", e);
                return false;
            }
        },
        loadGames() {
            try {
                const data = localStorage.getItem(this.GAMES_KEY);
                return data ? JSON.parse(data) : [];
            } catch(e) { console.error("SM: Corrupt data", e); return []; }
        },
        loadCurrentGame() {
            try {
                const currentId = localStorage.getItem(this.CURRENT_KEY);
                if(!currentId) return null;
                return this.loadGames().find(g => g.id === currentId);
            } catch(e) { return null; }
        },
        deleteGame(gameId) {
            const games = this.loadGames().filter(g => g.id !== gameId);
            localStorage.setItem(this.GAMES_KEY, JSON.stringify(games));
            const currentId = localStorage.getItem(this.CURRENT_KEY);
            if(currentId === gameId) localStorage.removeItem(this.CURRENT_KEY);
        }
    };

    // ==================== STATS ENGINE ====================
    const StatsEngine = {
        calculateStats(mode = 'all') {
            const games = Storage.loadGames().filter(g =>
                g.finished && (mode === 'all' || g.mode === mode)
            );

            const stats = {};

            games.forEach(game => {
                const sortedPlayers = [...game.state.players].sort((a,b)=>b.total-a.total);
                const winner = sortedPlayers[0];

                game.state.players.forEach(p => {
                    const key = p.name.toUpperCase();
                    if(!stats[key]) {
                        stats[key] = { 
                            wins: 0, 
                            played: 0, 
                            totalScoreSum: 0, 
                            highestScore: 0, 
                            highestRound: 0,
                            lowestRound: Infinity,
                            roundScores: [],
                            totalRounds: 0,
                            gameScores: [],
                            currentStreak: 0,
                            bestStreak: 0
                        };
                    }

                    stats[key].played++;
                    stats[key].totalScoreSum += p.total;
                    stats[key].highestScore = Math.max(stats[key].highestScore, p.total);
                    stats[key].gameScores.push(p.total);

                    // Collecter tous les scores de manches
                    game.state.history.forEach(round => {
                        const roundScore = round[p.id] || 0;
                        stats[key].roundScores.push(roundScore);
                        stats[key].totalRounds++;
                        stats[key].highestRound = Math.max(stats[key].highestRound, roundScore);
                        if(roundScore > 0) {
                            stats[key].lowestRound = Math.min(stats[key].lowestRound, roundScore);
                        }
                    });
                });

                if(winner && stats[winner.name.toUpperCase()]) {
                    stats[winner.name.toUpperCase()].wins++;
                }
            });

            // Calculer les s√©ries de victoires
            const sortedGames = games.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
            const streaks = {};
            
            sortedGames.forEach(game => {
                const sortedPlayers = [...game.state.players].sort((a,b)=>b.total-a.total);
                const winner = sortedPlayers[0];
                
                game.state.players.forEach(p => {
                    const key = p.name.toUpperCase();
                    if(!streaks[key]) streaks[key] = { current: 0, best: 0, counting: true };
                    
                    if(p.id === winner.id && streaks[key].counting) {
                        streaks[key].current++;
                        streaks[key].best = Math.max(streaks[key].best, streaks[key].current);
                    } else {
                        streaks[key].counting = false;
                    }
                });
            });

            return Object.entries(stats).map(([name, data]) => {
                // Calculer la moyenne par manche
                const avgPerRound = data.totalRounds > 0 ? Math.round(data.roundScores.reduce((a,b)=>a+b,0) / data.totalRounds) : 0;
                
                // Calculer la r√©gularit√© (√©cart-type)
                const mean = avgPerRound;
                const variance = data.roundScores.length > 0 
                    ? data.roundScores.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0) / data.roundScores.length 
                    : 0;
                const stdDev = Math.sqrt(variance);
                
                // Convertir l'√©cart-type en score de r√©gularit√© (0-5 √©toiles)
                const maxStdDev = 50;
                const regularityScore = Math.max(0, Math.min(5, 5 - Math.floor((stdDev / maxStdDev) * 5)));
                
                // Calculer la forme r√©cente (5 derni√®res parties)
                const recentGames = data.gameScores.slice(-5);
                const olderGames = data.gameScores.slice(0, -5);
                const recentAvg = recentGames.length > 0 ? recentGames.reduce((a,b)=>a+b,0) / recentGames.length : 0;
                const olderAvg = olderGames.length > 0 ? olderGames.reduce((a,b)=>a+b,0) / olderGames.length : recentAvg;
                const formPercent = olderAvg > 0 ? Math.round(((recentAvg - olderAvg) / olderAvg) * 100) : 0;
                
                return {
                    name,
                    ...data,
                    winRate: data.played ? Math.round((data.wins / data.played) * 100) : 0,
                    avgPerRound,
                    lowestRound: data.lowestRound === Infinity ? 0 : data.lowestRound,
                    regularityScore,
                    regularityStars: '‚≠ê'.repeat(regularityScore) + '‚òÜ'.repeat(5 - regularityScore),
                    currentStreak: streaks[name]?.current || 0,
                    bestStreak: streaks[name]?.best || 0,
                    formPercent,
                    formTrend: formPercent > 0 ? '‚ÜóÔ∏è' : formPercent < 0 ? '‚ÜòÔ∏è' : '‚û°Ô∏è'
                };
            })
            .sort((a,b)=>b.winRate - a.winRate);
        },
        getRecordScores(mode = 'all') {
            const stats = this.calculateStats(mode);
            return stats.sort((a,b) => b.highestScore - a.highestScore).slice(0, 10);
        },
        calculateGameHighlights(state) {
            const highlights = [];
            let bestRound = { score: 0, player: null, roundIdx: 0 };
            state.history.forEach((round, idx) => {
                state.players.forEach(p => {
                    if(round[p.id] > bestRound.score) bestRound = { score: round[p.id], player: p, roundIdx: idx + 1 };
                });
            });
            if(bestRound.player) highlights.push({ icon: 'üî•', label: 'Meilleure manche', value: `${bestRound.player.name} - ${bestRound.score} pts (M${bestRound.roundIdx})`, color: bestRound.player.color });
            
            const rankProgression = {};
            state.players.forEach(p => {
                const ranks = [state.players.length];
                state.history.forEach((round, histIdx) => {
                    const totals = state.players.map(pl => {
                        let c = 0;
                        state.history.slice(0, histIdx + 1).forEach(r => c += r[pl.id] || 0);
                        return { id: pl.id, total: c };
                    }).sort((a,b) => b.total - a.total);
                    ranks.push(totals.findIndex(t => t.id === p.id) + 1);
                });
                const maxRank = Math.max(...ranks);
                const finalRank = ranks[ranks.length - 1];
                rankProgression[p.id] = { player: p, improvement: maxRank - finalRank, maxRank, finalRank };
            });
            const comeback = Object.values(rankProgression).sort((a,b) => b.improvement - a.improvement)[0];
            if(comeback && comeback.improvement > 0) highlights.push({ icon: '‚ö°', label: 'Comeback King', value: `${comeback.player.name} (${comeback.maxRank}e ‚Üí ${comeback.finalRank}e)`, color: comeback.player.color });

            const consistency = state.players.map(p => {
                const scores = state.history.map(r => r[p.id] || 0).filter(s => s > 0);
                if(scores.length === 0) return { player: p, std: Infinity };
                const mean = scores.reduce((a,b) => a+b, 0) / scores.length;
                const variance = scores.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0) / scores.length;
                return { player: p, std: Math.sqrt(variance), mean };
            }).sort((a,b) => a.std - b.std)[0];
            if(consistency && consistency.std !== Infinity) highlights.push({ icon: 'üéØ', label: 'Joueur r√©gulier', value: `${consistency.player.name} (${Math.round(consistency.mean)} pts/manche)`, color: consistency.player.color });
            
            if(state.history.length >= 20) highlights.push({ icon: 'üèÉ', label: 'Partie Marathon', value: `${state.history.length} manches jou√©es`, color: 'var(--primary)' });
            return highlights;
        }
    };

    // ==================== UI LAYER ====================
    const UI = {
        currentStatsMode: 'all',
        showToast(message, type = 'default') {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.className = 'toast show';
            if(type !== 'default') toast.classList.add(type);
            setTimeout(() => toast.classList.remove('show'), 2500);
            if(type === 'success') SoundFX.success();
            else if(type === 'error') SoundFX.error();
        },
        confirm(message, onYes) {
            SoundFX.click();
            const modal = document.getElementById('confirm-modal');
            const msgEl = document.getElementById('confirm-msg');
            const yesBtn = document.getElementById('confirm-yes-btn');
            msgEl.textContent = message;
            modal.classList.add('active');
            const newBtn = yesBtn.cloneNode(true);
            yesBtn.parentNode.replaceChild(newBtn, yesBtn);
            newBtn.addEventListener('click', () => {
                modal.classList.remove('active');
                onYes();
            });
        },
        closeConfirm() { document.getElementById('confirm-modal').classList.remove('active'); },
        
        showStats() {
            SoundFX.click();
            document.getElementById('stats-modal').classList.add('active');
            this.switchStatsTab('rank'); 
        },
        closeStats() { document.getElementById('stats-modal').classList.remove('active'); },
        switchStatsTab(tab) {
            SoundFX.click();
            document.getElementById('tab-rank').classList.remove('active');
            document.getElementById('tab-records').classList.remove('active');
            document.getElementById('stats-content-rank').classList.add('hidden');
            document.getElementById('stats-content-records').classList.add('hidden');
            document.getElementById('stats-content-player').classList.add('hidden');

            if(tab === 'rank') {
                document.getElementById('tab-rank').classList.add('active');
                this.renderRanking();
                document.getElementById('stats-content-rank').classList.remove('hidden');
            } else if (tab === 'records') {
                document.getElementById('tab-records').classList.add('active');
                this.renderRecords();
                document.getElementById('stats-content-records').classList.remove('hidden');
            }
        },
        showRanking() {
            SoundFX.click();
            this.switchStatsTab('rank');
        },
        filterStats(mode) {
            this.currentStatsMode = mode;
            document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
            document.querySelector(`.filter-btn[onclick="UI.filterStats('${mode}')"]`)?.classList.add('active');
            this.renderRanking();
        },
        renderRanking() {
            const data = StatsEngine.calculateStats(this.currentStatsMode);
            const container = document.getElementById('stats-content-rank');
            container.innerHTML = '';
            if(data.length === 0) { container.innerHTML = '<p class="text-center" style="color:var(--text-sec); padding:20px;">Aucune statistique disponible</p>'; return; }
            data.forEach((p, idx) => {
                const streakEmoji = p.currentStreak >= 3 ? 'üî•' : p.currentStreak > 0 ? '‚ö°' : '';
                const formIndicator = p.formPercent > 10 ? '‚ÜóÔ∏è' : p.formPercent < -10 ? '‚ÜòÔ∏è' : '';
                
                const el = document.createElement('div');
                el.className = `rank-item rank-${idx+1}`;
                el.onclick = () => this.renderPlayerDetail(p.name);
                el.innerHTML = `
                    <div class="rank-num">${idx+1}</div>
                    <div class="rank-info">
                        <div class="rank-name">${p.name} ${streakEmoji}${p.currentStreak > 0 ? p.currentStreak : ''}</div>
                        <div class="rank-sub">${p.played} parties ‚Ä¢ Moy. ${p.avgPerRound} pts/manche ${formIndicator}</div>
                    </div>
                    <div class="rank-val" style="color:${p.winRate >= 50 ? 'var(--success)' : 'var(--text)'}">${p.winRate}%</div>
                `;
                container.appendChild(el);
            });
        },
        renderPlayerDetail(name) {
            const allStats = StatsEngine.calculateStats();
            const p = allStats.find(s => s.name === name);
            if(!p) return;
            document.getElementById('stats-content-rank').classList.add('hidden');
            document.getElementById('stats-content-player').classList.remove('hidden');
            document.getElementById('stats-content-records').classList.add('hidden');
            const container = document.getElementById('player-detail-content');
            
            const streakColor = p.currentStreak >= 3 ? 'var(--danger)' : p.currentStreak > 0 ? 'var(--primary)' : 'var(--text)';
            const formColor = p.formPercent > 10 ? 'var(--success)' : p.formPercent < -10 ? 'var(--danger)' : 'var(--text)';
            
            container.innerHTML = `
                <h2 class="text-huge" style="margin:0 0 20px 0;">${name}</h2>
                
                <div style="display:grid; grid-template-columns: 1fr 1fr; gap:12px; margin-bottom:20px;">
                    <div class="stat-detail">
                        <h4 style="font-size:11px; color:var(--text-sec); margin:0 0 5px 0; font-weight:600;">TAUX VICTOIRE</h4>
                        <div class="value" style="font-size:32px; font-weight:900; color:var(--primary);">${p.winRate}%</div>
                    </div>
                    <div class="stat-detail">
                        <h4 style="font-size:11px; color:var(--text-sec); margin:0 0 5px 0; font-weight:600;">S√âRIE ACTUELLE</h4>
                        <div class="value" style="font-size:32px; font-weight:900; color:${streakColor};">${p.currentStreak > 0 ? 'üî• ' : ''}${p.currentStreak}</div>
                    </div>
                </div>
                
                <div style="background:var(--card); border:1px solid var(--border); border-radius:16px; padding:15px; margin-bottom:15px;">
                    <h3 style="font-size:14px; font-weight:700; margin:0 0 12px 0; color:var(--text);">üìä Statistiques D√©taill√©es</h3>
                    <div style="display:grid; gap:10px;">
                        <div style="display:flex; justify-content:space-between; align-items:center;">
                            <span style="font-size:13px; color:var(--text-sec);">Score moyen/manche</span>
                            <span style="font-size:15px; font-weight:700;">${p.avgPerRound} pts</span>
                        </div>
                        <div style="display:flex; justify-content:space-between; align-items:center;">
                            <span style="font-size:13px; color:var(--text-sec);">Meilleur score (manche)</span>
                            <span style="font-size:15px; font-weight:700; color:var(--success);">üèÜ ${p.highestRound} pts</span>
                        </div>
                        <div style="display:flex; justify-content:space-between; align-items:center;">
                            <span style="font-size:13px; color:var(--text-sec);">Pire score (manche)</span>
                            <span style="font-size:15px; font-weight:700; color:var(--danger);">${p.lowestRound} pts</span>
                        </div>
                        <div style="display:flex; justify-content:space-between; align-items:center;">
                            <span style="font-size:13px; color:var(--text-sec);">R√©gularit√©</span>
                            <span style="font-size:15px; font-weight:700;">${p.regularityStars}</span>
                        </div>
                        <div style="display:flex; justify-content:space-between; align-items:center;">
                            <span style="font-size:13px; color:var(--text-sec);">Meilleure s√©rie</span>
                            <span style="font-size:15px; font-weight:700;">üèÖ ${p.bestStreak} victoire${p.bestStreak > 1 ? 's' : ''}</span>
                        </div>
                        <div style="display:flex; justify-content:space-between; align-items:center;">
                            <span style="font-size:13px; color:var(--text-sec);">Forme r√©cente</span>
                            <span style="font-size:15px; font-weight:700; color:${formColor};">${p.formTrend} ${p.formPercent > 0 ? '+' : ''}${p.formPercent}%</span>
                        </div>
                    </div>
                </div>
                
                <div style="background:var(--card); border:1px solid var(--border); border-radius:16px; padding:15px;">
                    <h3 style="font-size:14px; font-weight:700; margin:0 0 12px 0; color:var(--text);">üéÆ Historique</h3>
                    <div style="display:grid; gap:10px;">
                        <div style="display:flex; justify-content:space-between; align-items:center;">
                            <span style="font-size:13px; color:var(--text-sec);">Victoires</span>
                            <span style="font-size:15px; font-weight:700; color:var(--success);">${p.wins} üèÜ</span>
                        </div>
                        <div style="display:flex; justify-content:space-between; align-items:center;">
                            <span style="font-size:13px; color:var(--text-sec);">Parties jou√©es</span>
                            <span style="font-size:15px; font-weight:700;">${p.played}</span>
                        </div>
                        <div style="display:flex; justify-content:space-between; align-items:center;">
                            <span style="font-size:13px; color:var(--text-sec);">Manches jou√©es</span>
                            <span style="font-size:15px; font-weight:700;">${p.totalRounds}</span>
                        </div>
                        <div style="display:flex; justify-content:space-between; align-items:center;">
                            <span style="font-size:13px; color:var(--text-sec);">Record (partie)</span>
                            <span style="font-size:15px; font-weight:700; color:var(--primary);">${p.highestScore} pts</span>
                        </div>
                    </div>
                </div>
            `;
        },
        filterRecords(mode) {
            this.currentStatsMode = mode;
            document.querySelectorAll('.filter-btn-records').forEach(b => b.classList.remove('active'));
            document.querySelector(`.filter-btn-records[onclick="UI.filterRecords('${mode}')"]`)?.classList.add('active');
            this.renderRecords();
        },
        renderRecords() {
            const data = StatsEngine.getRecordScores(this.currentStatsMode || 'all');
            const container = document.getElementById('stats-content-records');
            container.innerHTML = '';
            if(data.length === 0) { container.innerHTML = '<p class="text-center" style="color:var(--text-sec); padding:20px;">Aucun record.</p>'; return; }
            
            // Trouver les records sp√©ciaux
            const bestAvg = [...data].sort((a,b) => b.avgPerRound - a.avgPerRound)[0];
            const bestStreak = [...data].sort((a,b) => b.bestStreak - a.bestStreak)[0];
            const mostRegular = [...data].sort((a,b) => b.regularityScore - a.regularityScore)[0];
            
            // Afficher les records sp√©ciaux en haut
            container.innerHTML += `
                <div style="margin-bottom:20px;">
                    <h3 style="font-size:14px; font-weight:700; margin:0 0 12px 0; color:var(--text);">üèÜ Records Sp√©ciaux</h3>
                    <div style="display:grid; gap:8px;">
                        <div style="background:var(--card); border:1px solid var(--border); border-radius:12px; padding:12px; display:flex; justify-content:space-between; align-items:center;">
                            <div>
                                <div style="font-size:11px; color:var(--text-sec); font-weight:600;">MEILLEURE MOYENNE</div>
                                <div style="font-size:15px; font-weight:700; margin-top:3px;">${bestAvg.name}</div>
                            </div>
                            <div style="font-size:20px; font-weight:900; color:var(--primary);">${bestAvg.avgPerRound}</div>
                        </div>
                        <div style="background:var(--card); border:1px solid var(--border); border-radius:12px; padding:12px; display:flex; justify-content:space-between; align-items:center;">
                            <div>
                                <div style="font-size:11px; color:var(--text-sec); font-weight:600;">MEILLEURE S√âRIE</div>
                                <div style="font-size:15px; font-weight:700; margin-top:3px;">${bestStreak.name}</div>
                            </div>
                            <div style="font-size:20px; font-weight:900; color:var(--danger);">üî• ${bestStreak.bestStreak}</div>
                        </div>
                        <div style="background:var(--card); border:1px solid var(--border); border-radius:12px; padding:12px; display:flex; justify-content:space-between; align-items:center;">
                            <div>
                                <div style="font-size:11px; color:var(--text-sec); font-weight:600;">PLUS R√âGULIER</div>
                                <div style="font-size:15px; font-weight:700; margin-top:3px;">${mostRegular.name}</div>
                            </div>
                            <div style="font-size:18px; font-weight:900;">${mostRegular.regularityStars}</div>
                        </div>
                    </div>
                </div>
                
                <h3 style="font-size:14px; font-weight:700; margin:0 0 12px 0; color:var(--text);">üéØ Meilleurs Scores (Partie)</h3>
            `;
            
            data.forEach((p, idx) => {
                const el = document.createElement('div');
                el.className = 'rank-item';
                el.innerHTML = `
                    <div class="rank-info">
                        <div class="rank-name">${p.name}</div>
                        <div class="rank-sub">Meilleure manche: ${p.highestRound} pts</div>
                    </div>
                    <div class="rank-val">${p.highestScore}</div>
                `;
                container.appendChild(el);
            });
        },
        renderScoreCards(state) {
            const isLowest = app.currentGame.victoryCondition === 'lowest';
            const sorted = app.focusMode ? [...state.players] : [...state.players].sort((a,b) => {
                const scoreA = a.total + (state.temp[a.id]||0);
                const scoreB = b.total + (state.temp[b.id]||0);
                return isLowest ? scoreA - scoreB : scoreB - scoreA;
            });
            const grid = document.getElementById('grid');
            const rankChanges = new Set();
            app.lastRanks = app.lastRanks || {};

            state.players.forEach(p => {
                const newRank = sorted.findIndex(s => s.id === p.id);
                if(app.lastRanks[p.id] !== undefined && app.lastRanks[p.id] !== newRank) {
                    rankChanges.add(p.id);
                }
                app.lastRanks[p.id] = newRank;
            });
            grid.innerHTML = '';
            const displayOrder = app.focusMode ? state.players : sorted;
            displayOrder.forEach(p => {
                const tempScore = state.temp[p.id] || 0;
                const totalScore = p.total + tempScore;
                const rankIdx = sorted.findIndex(s => s.id === p.id);
                let badgeClass = 'badge-none', badgeText = '#' + (rankIdx + 1);
                if(rankIdx === 0) { badgeClass = 'badge-1'; badgeText = 'ü•á'; }
                else if(rankIdx === 1) { badgeClass = 'badge-2'; badgeText = 'ü•à'; }
                else if(rankIdx === 2) { badgeClass = 'badge-3'; badgeText = 'ü•â'; }
                const card = document.createElement('div');
                card.className = `p-card ${state.dealerId === p.id ? 'is-dealer' : ''}`;
                if(rankChanges.has(p.id) && !app.focusMode) card.classList.add('rank-change');
                card.innerHTML = `
                    <div class="rank-badge ${badgeClass} ${rankChanges.has(p.id) ? 'bounce' : ''}">${badgeText}</div>
                    <div class="p-name-btn" style="color:${p.color}; border-color:${p.color}40" onclick="app.openModal(${p.id})">${p.name}</div>
                    <div class="p-score ${tempScore !== 0 ? 'score-bump' : ''}" onclick="app.openSheet(${p.id})">${totalScore}</div>
                    <div class="p-temp">${tempScore ? (tempScore > 0 ? '+' + tempScore : tempScore) : ''}</div>
                    ${state.dealerId === p.id ? '<div style="position:absolute; top:8px; right:8px; font-size:12px;">üÉè</div>' : ''}
                `;
                grid.appendChild(card);
            });
        },
        renderHistory(state, editIdx) {
            const hist = document.getElementById('history');
            hist.innerHTML = '';
            state.history.slice().reverse().forEach((r, i) => {
                const idx = state.history.length - 1 - i;
                const isEditing = idx === editIdx;
                const row = document.createElement('div');
                row.className = 'h-row';
                row.style.borderColor = isEditing ? 'var(--dealer)' : 'var(--border)';
                let scoresHtml = '';
                state.players.forEach(p => {
                    const score = isEditing && state.temp[p.id] !== undefined ? state.temp[p.id] : (r[p.id] || 0);
                    scoresHtml += `
                        <div class="h-score-item">
                            <div style="font-size:7px; color:${p.color}; font-weight:900; opacity:0.7">${p.name.substring(0,4)}</div>
                            <div style="color:${p.color}; font-weight:800; font-size:14px;">${score}</div>
                        </div>
                    `;
                });
                row.innerHTML = `
                    <div class="h-idx">M${idx+1}</div>
                    <div class="h-scores" onclick="app.startEdit(${idx})">${scoresHtml}</div>
                    <button onclick="app.delRound(${idx})" style="border:none; background:none; color:var(--danger); font-size:18px; padding-left:10px; flex-shrink:0;">√ó</button>
                `;
                hist.appendChild(row);
            });
        },
        renderChart(state, editIdx) {
            const ctx = document.getElementById('chart');
            if(!ctx || typeof Chart === 'undefined') return;
            if(app.chart) app.chart.destroy();
            const datasets = state.players.map(p => {
                let cumul = 0;
                const data = [0];
                state.history.forEach((h, idx) => {
                    if(idx === editIdx && state.temp[p.id] !== undefined) cumul += state.temp[p.id];
                    else cumul += (h[p.id] || 0);
                    data.push(cumul);
                });
                if(Object.keys(state.temp).length > 0 && editIdx === null) data.push(cumul + (state.temp[p.id] || 0));
                return {
                    label: p.name, data, borderColor: p.color, backgroundColor: p.color + '20', tension: 0.4, pointRadius: 3, pointHoverRadius: 6, borderWidth: 2.5, fill: false
                };
            });
            const labels = ['0', ...state.history.map((_, i) => 'M' + (i + 1))];
            if(Object.keys(state.temp).length > 0 && editIdx === null) labels.push('...');
            app.chart = new Chart(ctx, {
                type: 'line',
                data: { labels, datasets },
                options: {
                    responsive: true, maintainAspectRatio: false,
                    interaction: { mode: 'index', intersect: false },
                    plugins: { legend: { display: false }, tooltip: { backgroundColor: 'rgba(0,0,0,0.8)', padding: 12, titleFont: { size: 14, weight: 'bold' }, bodyFont: { size: 13 } } },
                    scales: { x: { grid: { display: false }, ticks: { font: { size: 10, weight: '700' }, color: '#86868B' } }, y: { beginAtZero: true, grid: { color: 'rgba(128,128,128,0.08)' }, ticks: { font: { size: 10, weight: '600' }, color: '#86868B' } } },
                    animation: { duration: 400 }
                }
            });
        },
        switchVictoryTab(tab) {
            SoundFX.click();
            document.querySelectorAll('.victory-tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('[id^="victory-tab-"]').forEach(t => t.classList.add('hidden'));
            const tabIndex = { podium: 1, stats: 2, highlights: 3 };
            document.querySelector(`.victory-tab:nth-child(${tabIndex[tab]})`).classList.add('active');
            document.getElementById(`victory-tab-${tab}`).classList.remove('hidden');
        },
        showVictory(winner, score, state) {
            SoundFX.success();
            const overlay = document.getElementById('victory');
            const sorted = [...state.players].sort((a,b) => b.total - a.total);
            const podium = document.getElementById('podium');
            podium.innerHTML = '';
            const top3 = [sorted[1], sorted[0], sorted[2]].filter(p => p);
            top3.forEach((p) => {
                if(!p) return;
                const realRank = sorted.indexOf(p) + 1;
                const place = document.createElement('div');
                place.className = `podium-place p${realRank}`;
                place.innerHTML = `
                    <div class="podium-avatar" style="background:${p.color}30; border:3px solid ${p.color};">
                        ${realRank === 1 ? '<div class="podium-crown">üëë</div>' : ''}
                        <span style="color:${p.color}">${p.name.substring(0,2)}</span>
                    </div>
                    <div class="podium-name" style="color:${p.color}">${p.name}</div>
                    <div class="podium-score" style="color:${p.color}">${p.total}</div>
                    <div class="podium-bar">
                        ${realRank === 1 ? 'ü•á' : realRank === 2 ? 'ü•à' : 'ü•â'}
                    </div>
                `;
                podium.appendChild(place);
            });

            const allPlayersDiv = document.getElementById('victory-all-players');
            allPlayersDiv.innerHTML = '';
            sorted.forEach((p, idx) => {
                const stats = this.calculatePlayerGameStats(p, state);
                const row = document.createElement('div');
                row.className = 'player-stats-row';
                row.innerHTML = `
                    <div class="player-stats-rank" style="color:${idx < 3 ? p.color : 'var(--text-sec)'}">${idx+1}</div>
                    <div class="player-stats-info">
                        <div class="player-stats-name" style="color:${p.color}">${p.name}</div>
                        <div style="font-size:11px; color:var(--text-sec);">Meilleur: ${stats.best} ‚Ä¢ Moy: ${stats.avg} ‚Ä¢ Manches gagn√©es: ${stats.roundsWon}</div>
                    </div>
                    <div class="player-stats-score" style="color:${p.color}">${p.total}</div>
                `;
                allPlayersDiv.appendChild(row);
            });

            const highlights = StatsEngine.calculateGameHighlights(state);
            const highlightsDiv = document.getElementById('victory-highlights');
            highlightsDiv.innerHTML = '';
            if(highlights.length === 0) {
                highlightsDiv.innerHTML = '<p class="text-center" style="color:var(--text-sec); padding:20px;">Aucun highlight.</p>';
            } else {
                highlights.forEach(h => {
                    const card = document.createElement('div');
                    card.className = 'highlight-card';
                    card.innerHTML = `
                        <div class="highlight-icon">${h.icon}</div>
                        <div class="highlight-text">
                            <div class="highlight-label">${h.label}</div>
                            <div class="highlight-value" style="color:${h.color}">${h.value}</div>
                        </div>
                    `;
                    highlightsDiv.appendChild(card);
                });
            }
            overlay.classList.add('active');
            this.switchVictoryTab('podium');
            this.launchFireworks();
            if(navigator.vibrate) navigator.vibrate([100, 50, 100, 50, 200]);
        },
        calculatePlayerGameStats(player, state) {
            const scores = state.history.map(r => r[player.id] || 0);
            const nonZero = scores.filter(s => s > 0);
            const best = Math.max(...scores, 0);
            const avg = nonZero.length > 0 ? Math.round(nonZero.reduce((a,b) => a+b, 0) / nonZero.length) : 0;
            let roundsWon = 0;
            state.history.forEach(round => {
                const maxScore = Math.max(...state.players.map(p => round[p.id] || 0));
                if(round[player.id] === maxScore && maxScore > 0) roundsWon++;
            });
            return { best, avg, roundsWon };
        },
        closeVictory() { document.getElementById('victory').classList.remove('active'); },
        launchFireworks() {
            const duration = 5000;
            const end = Date.now() + duration;
            const colors = ['#007AFF', '#FF2D55', '#34C759', '#FF9500', '#AF52DE', '#FFD700'];
            (function frame() {
                confetti({ particleCount:3, angle: 60, spread: 55, origin: { x: 0, y: 0.8 }, colors: colors });
                confetti({ particleCount:3, angle: 120, spread: 55, origin: { x: 1, y: 0.8 }, colors: colors });
                if (Date.now() < end) requestAnimationFrame(frame);
            })();
            confetti({ particleCount: 100, spread: 70, origin: { y: 0.6 }, colors: colors });
        },
        launchMilestoneConfetti(score) {
            const colors = ['#007AFF', '#FF2D55', '#34C759', '#FF9500', '#AF52DE', '#FFD700'];
            confetti({ particleCount: 60, spread: 60, origin: { y: 0.6 }, colors: colors });
            let milestone = '';
            if(score >= 1000) milestone = 'üéâ 1000 POINTS !';
            else if(score >= 500) milestone = 'üéä 500 POINTS !';
            else if(score >= 200) milestone = '‚ú® 200 POINTS !';
            if(navigator.vibrate) {
                if(score >= 1000) navigator.vibrate([50, 100, 50, 100, 50]);
                else if(score >= 500) navigator.vibrate([50, 100, 50]);
                else navigator.vibrate(100);
            }
            if(milestone) this.showToast(milestone);
        }
    };

    // ==================== APP CONTROLLER ====================
    const app = {
        currentGame: null, activePlayerId: null, editIdx: null, chart: null, savedPlayers: {}, focusMode: false,

        init() {
            Storage.migrateData();
            const savedTheme = localStorage.getItem('sm_theme');
            if(savedTheme) { document.documentElement.setAttribute('data-theme', savedTheme); this.updateThemeIcon(); }
            
            try {
                const savedPlayersData = localStorage.getItem('sm_saved_players');
                if(savedPlayersData) { this.savedPlayers = JSON.parse(savedPlayersData); }
            } catch(e) { console.warn("Corrupt saved players data", e); this.savedPlayers = {}; }

            const game = Storage.loadCurrentGame();
            if(game) { 
                // Migration des anciennes parties
                if(!game.victoryCondition) {
                    game.victoryCondition = 'highest';
                }
                if(!game.endCondition) {
                    game.endCondition = game.mode === 'belote' ? { type: 'score', value: 1000 } : { type: 'free', value: null };
                }
                this.currentGame = game; 
                this.showGame(); 
            } else { 
                this.showSetup(); 
            }
            this.renderGamesList();
        },
        toggleTheme() {
            const root = document.documentElement;
            const currentTheme = root.getAttribute('data-theme');
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            root.setAttribute('data-theme', newTheme);
            localStorage.setItem('sm_theme', newTheme);
            this.updateThemeIcon();
            if(navigator.vibrate) navigator.vibrate(30);
        },
        updateThemeIcon() {
            const theme = document.documentElement.getAttribute('data-theme');
            const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
            const isDark = theme === 'dark' || (theme !== 'light' && prefersDark);
            document.getElementById('theme-toggle').textContent = isDark ? '‚òÄÔ∏è' : 'üåô';
        },
        updateThemeColor() {
            const theme = document.documentElement.getAttribute('data-theme');
            const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
            const isDark = theme === 'dark' || (theme !== 'light' && prefersDark);
            const metaTheme = document.querySelector('meta[name="theme-color"]');
            if(metaTheme) {
                metaTheme.setAttribute('content', isDark ? '#000000' : '#F5F5F7');
            }
        },
        showSetup() {
            UI.closeVictory();
            this.focusMode = false;
            document.getElementById('game').classList.remove('focus-mode');
            document.getElementById('dock').classList.add('hidden');
            this.currentGame = null;
            this.editIdx = null;
            document.getElementById('setup').classList.remove('hidden');
            document.getElementById('game').classList.add('hidden');
            this.renderGamesList();
        },
        showModeSelection(mode) {
            SoundFX.click();
            if(mode === 'belote') { this.createGame(mode, 2); }
            else { 
                document.getElementById('mode-setup-title').textContent = 'Mode Standard';
                document.getElementById('modal-player-count').classList.add('active'); 
                this.updateVictoryCondition();
                this.updateEndCondition();
            }
        },
        updateVictoryCondition() {
            const isLowest = document.querySelector('input[name="victory-condition"]:checked')?.value === 'lowest';
            const scoreLabel = document.getElementById('score-label-text');
            const highestLabel = document.getElementById('victory-highest-label');
            const lowestLabel = document.getElementById('victory-lowest-label');
            
            // Mettre √† jour les bordures
            highestLabel.style.borderColor = !isLowest ? 'var(--primary)' : 'var(--border)';
            lowestLabel.style.borderColor = isLowest ? 'var(--primary)' : 'var(--border)';
            
            // Mettre √† jour le texte du label score
            if(isLowest) {
                scoreLabel.textContent = '‚ö†Ô∏è Limite de d√©faite :';
            } else {
                scoreLabel.textContent = 'üéØ Score objectif :';
            }
        },
        updateEndCondition() {
            const endType = document.querySelector('input[name="end-condition"]:checked')?.value;
            const freeLabel = document.getElementById('end-free-label');
            const scoreLabel = document.getElementById('end-score-label');
            
            freeLabel.style.borderColor = endType === 'free' ? 'var(--primary)' : 'var(--border)';
            scoreLabel.style.borderColor = endType === 'score' ? 'var(--primary)' : 'var(--border)';
        },
        toggleMorePlayers() {
            const extraDiv = document.getElementById('extra-players');
            const btn = document.getElementById('btn-toggle-players');
            if (extraDiv.classList.contains('hidden')) { extraDiv.classList.remove('hidden'); btn.textContent = 'Moins ‚ñ≤'; }
            else { extraDiv.classList.add('hidden'); btn.textContent = 'Plus ‚ñº'; }
        },
        selectPlayerCount(count) {
            const victoryCondition = document.querySelector('input[name="victory-condition"]:checked')?.value || 'highest';
            const endType = document.querySelector('input[name="end-condition"]:checked')?.value || 'free';
            const scoreTarget = endType === 'score' ? parseInt(document.getElementById('score-target').value) || 100 : null;
            
            document.getElementById('modal-player-count').classList.remove('active');
            document.getElementById('extra-players').classList.add('hidden');
            document.getElementById('btn-toggle-players').textContent = 'Plus ‚ñº';
            
            this.createGame('standard', count, victoryCondition, endType, scoreTarget);
        },
        createGame(mode, playerCount, victoryCondition = 'highest', endType = 'free', scoreTarget = null) {
            this.currentGame = {
                id: Date.now().toString(),
                name: mode === 'belote' ? 'Belote' : 'Partie Standard',
                mode, 
                date: new Date().toISOString(),
                victoryCondition: mode === 'belote' ? 'highest' : victoryCondition,
                endCondition: mode === 'belote' ? { type: 'score', value: 1000 } : { type: endType, value: scoreTarget },
                state: GameState.create(mode, playerCount), 
                finished: false
            };
            if(this.savedPlayers[mode]) {
                const saved = this.savedPlayers[mode];
                this.currentGame.state.players.forEach((p, idx) => {
                    if(saved[idx]) { p.name = saved[idx].name; p.color = saved[idx].color; }
                });
            }
            if(!Storage.saveGame(this.currentGame)) {
                UI.showToast('‚ö†Ô∏è Erreur de sauvegarde (M√©moire pleine)', 'error');
                return;
            }
            this.showGame();
        },
        showGame() {
            document.getElementById('setup').classList.add('hidden');
            document.getElementById('game').classList.remove('hidden');
            document.getElementById('dock').classList.remove('hidden');
            const isBelote = this.currentGame.mode === 'belote';
            document.getElementById('mode-title').textContent = isBelote ? 'BELOTE' : 'STANDARD';
            
            // Afficher les infos de la partie
            const gameInfo = document.getElementById('game-info');
            const isLowest = this.currentGame.victoryCondition === 'lowest';
            const endCond = this.currentGame.endCondition;
            let infoText = '';
            
            if(isBelote) {
                infoText = 'üéØ Premier √† 1000 pts';
            } else {
                infoText = isLowest ? '‚¨áÔ∏è Score le plus BAS' : '‚¨ÜÔ∏è Score le plus HAUT';
                if(endCond.type === 'score') {
                    infoText += isLowest ? ` ‚Ä¢ Limite ${endCond.value} pts` : ` ‚Ä¢ Objectif ${endCond.value} pts`;
                }
            }
            gameInfo.textContent = infoText;
            
            document.getElementById('calc-btn').classList.toggle('hidden', !isBelote);
            document.getElementById('btn-82').classList.toggle('hidden', !isBelote);
            document.getElementById('btn-50').classList.toggle('hidden', isBelote);
            document.getElementById('smart-btn').textContent = isBelote ? 'CAPOT' : '+/-';
            this.render();
        },
        toggleFocusMode() {
            SoundFX.click();
            this.focusMode = !this.focusMode;
            const root = document.body; 
            const dockEl = document.getElementById('dock');
            const overlay = document.getElementById('zen-overlay');

            if(this.focusMode) { 
                root.classList.add('focus-mode');
                dockEl.classList.remove('hidden');
                if(overlay) overlay.classList.add('active');
                if(navigator.vibrate) navigator.vibrate(20);
            }
            else { 
                root.classList.remove('focus-mode');
                dockEl.classList.remove('hidden'); 
                if(overlay) overlay.classList.remove('active');
            }
        },
        showStats() { UI.showStats(); },
        render() {
            if(!this.currentGame) return;
            UI.renderScoreCards(this.currentGame.state);
            UI.renderHistory(this.currentGame.state, this.editIdx);
            UI.renderChart(this.currentGame.state, this.editIdx);
            
            // Mettre √† jour le texte du bouton avec le num√©ro de manche
            const saveBtn = document.getElementById('save-btn');
            if(saveBtn && this.editIdx === null) {
                const nextRound = this.currentGame.state.history.length + 1;
                saveBtn.textContent = `ENREGISTRER MANCHE ${nextRound}`;
            }
        },
        renderGamesList() {
            const games = Storage.loadGames();
            const list = document.getElementById('games-list');
            if(!games || games.length === 0) { list.innerHTML = '<p class="text-center" style="color:var(--text-sec); padding:20px;">Aucune partie enregistr√©e</p>'; return; }
            list.innerHTML = '';
            games.slice().reverse().forEach(game => {
                const sortedPlayers = [...game.state.players].sort((a,b) => b.total - a.total);
                const winner = sortedPlayers[0];
                const date = new Date(game.date).toLocaleDateString('fr-FR', { day: 'numeric', month: 'short', hour: '2-digit', minute: '2-digit' });
                const modeBadge = game.mode === 'belote' ? '<span class="game-mode-badge badge-belote">üÉè BELOTE</span>' : '<span class="game-mode-badge badge-standard">üé≤ STANDARD</span>';
                const item = document.createElement('div');
                item.className = 'game-item';
                let playersScoresHtml = '';
                sortedPlayers.forEach((p, idx) => {
                    const isWinner = idx === 0;
                    playersScoresHtml += `<div class="game-player-score" style="background:${p.color}20; color:${p.color}; border: 1px solid ${p.color}40;">${isWinner ? 'üèÜ ' : ''}${p.name}: ${p.total}</div>`;
                });
                item.innerHTML = `
                    <div onclick="app.loadGame('${game.id}')" style="flex:1; cursor:pointer;">
                        <div style="font-weight:900; font-size:16px; margin-bottom:6px;">${game.name} ${game.finished ? '‚úì' : ''} ${modeBadge}</div>
                        <div style="font-size:12px; color:var(--text-sec); margin-bottom:8px;">${date} ‚Ä¢ ${game.state.history.length} manches</div>
                        <div class="game-players-list">${playersScoresHtml}</div>
                    </div>
                    <div class="game-actions"><button onclick="event.stopPropagation(); app.deleteGame('${game.id}')" title="Supprimer">üóëÔ∏è</button></div>
                `;
                list.appendChild(item);
            });
        },
        loadGame(id) {
            SoundFX.click();
            const game = Storage.loadGames().find(g => g.id === id);
            if(game) {
                this.savedPlayers[game.mode] = game.state.players.map(p => ({ name: p.name, color: p.color }));
                localStorage.setItem('sm_saved_players', JSON.stringify(this.savedPlayers));
                this.currentGame = game;
                localStorage.setItem(Storage.CURRENT_KEY, id); 
                this.showGame();
            } else {
                UI.showToast('‚ö†Ô∏è Partie introuvable', 'error');
            }
        },
        deleteGame(gameId) {
            UI.confirm('Supprimer cette partie ?', () => {
                Storage.deleteGame(gameId);
                UI.showToast('‚úÖ Partie supprim√©e', 'success');
                this.renderGamesList();
            });
        },
        clearAll() {
            UI.confirm("‚ö†Ô∏è Supprimer TOUTES les parties ?", () => {
                localStorage.removeItem(Storage.GAMES_KEY);
                localStorage.removeItem(Storage.CURRENT_KEY);
                UI.showToast('‚úÖ Historique effac√©', 'success');
                this.renderGamesList();
            });
        },
        restartWithSamePlayers() {
            UI.closeVictory();
            if(!this.currentGame) return;
            if(!this.currentGame.finished) { this.currentGame.finished = true; Storage.saveGame(this.currentGame); }
            const oldState = this.currentGame.state;
            const newGame = {
                id: Date.now().toString(),
                name: this.currentGame.mode === 'belote' ? 'Belote' : 'Partie Standard',
                mode: this.currentGame.mode, date: new Date().toISOString(),
                state: { mode: oldState.mode, players: oldState.players.map(p => ({ ...p, total: 0, previousRank: null })), history: [], temp: {}, dealerId: oldState.dealerId, celebratedMilestones: {} },
                finished: false
            };
            this.currentGame = newGame;
            if(!Storage.saveGame(newGame)) {
                UI.showToast('‚ö†Ô∏è Erreur de sauvegarde (M√©moire pleine)', 'error');
                return;
            }
            UI.showToast('üéÆ Nouvelle partie lanc√©e !', 'success');
            this.render();
        },
        finishGame() {
            if(this.currentGame.state.history.length === 0) { UI.showToast('‚ö†Ô∏è Aucune manche jou√©e', 'warning'); return; }
            this.currentGame.finished = true;
            Storage.saveGame(this.currentGame);
            this.savedPlayers[this.currentGame.mode] = this.currentGame.state.players.map(p => ({ name: p.name, color: p.color }));
            localStorage.setItem('sm_saved_players', JSON.stringify(this.savedPlayers));
            const winner = [...this.currentGame.state.players].sort((a,b) => b.total - a.total)[0];
            UI.showVictory(winner, winner.total, this.currentGame.state);
        },
        async shareRecap() {
            if(!this.currentGame || !this.currentGame.finished) {
                UI.showToast('‚ö†Ô∏è Terminez d\'abord la partie', 'warning');
                return;
            }
            
            SoundFX.click();
            
            try {
                const canvas = await RecapGenerator.generate(this.currentGame.state);
                
                if(!canvas) return;
                
                const shared = await RecapGenerator.shareImage(canvas);
                
                if(!shared) {
                    RecapGenerator.downloadImage(canvas, `ScoreMaster_${new Date().toISOString().split('T')[0]}.png`);
                    UI.showToast('üì• R√©cap t√©l√©charg√© !', 'success');
                } else {
                    UI.showToast('‚úÖ R√©cap partag√© !', 'success');
                }
                
                if(navigator.vibrate) navigator.vibrate([50, 30, 50]);
                
            } catch (error) {
                console.error('[ScoreMaster] Erreur:', error);
                UI.showToast('‚ùå Erreur partage', 'error');
            }
        },
        openModal(playerId) {
            SoundFX.click();
            this.editPlayerId = playerId;
            const player = this.currentGame.state.players.find(p => p.id === playerId);
            document.getElementById('modal-title').textContent = player.name;
            document.getElementById('modal-title').style.color = player.color;
            document.getElementById('edit-name').value = player.name;
            document.getElementById('edit-dealer').checked = (this.currentGame.state.dealerId === playerId);
            document.getElementById('modal-player').classList.add('active');
        },
        closeModal() { document.getElementById('modal-player').classList.remove('active'); },
        savePlayer() {
            SoundFX.click();
            const player = this.currentGame.state.players.find(p => p.id === this.editPlayerId);
            const newName = document.getElementById('edit-name').value.trim().toUpperCase();
            if(newName) player.name = newName;
            if(document.getElementById('edit-dealer').checked) { this.currentGame.state.dealerId = player.id; }
            this.closeModal();
            this.render();
        },
        openSheet(playerId) {
            SoundFX.click();
            this.activePlayerId = playerId;
            const isBelote = this.currentGame.mode === 'belote';
            document.getElementById('calc-btn').classList.toggle('hidden', !isBelote);
            document.getElementById('btn-82').classList.toggle('hidden', !isBelote);
            document.getElementById('btn-50').classList.toggle('hidden', isBelote);
            this.renderSwitcher();
            document.getElementById('sheet').classList.add('active');
        },
        closeSheet() { document.getElementById('sheet').classList.remove('active'); this.render(); },
        renderSwitcher() {
            const cont = document.getElementById('input-switcher');
            cont.innerHTML = '';
            this.currentGame.state.players.forEach(p => {
                const isActive = p.id === this.activePlayerId;
                const tempScore = this.currentGame.state.temp[p.id] || 0;
                const div = document.createElement('div');
                div.className = `sel-box ${isActive ? 'active' : ''}`;
                if(isActive) div.style.setProperty('--p-color', p.color);
                div.onclick = () => { this.activePlayerId = p.id; this.renderSwitcher(); SoundFX.click(); };
                div.innerHTML = `<div style="font-size:10px; font-weight:800; color:${isActive ? p.color : 'var(--text-sec)'}">${p.name}</div><div style="font-size:20px; font-weight:900">${tempScore}</div>`;
                cont.appendChild(div);
            });
        },
        typeNum(n) {
            const current = (this.currentGame.state.temp[this.activePlayerId] || 0).toString();
            const newVal = parseInt((current === '0' ? '' : current) + n);
            if(newVal > 9999) { if(navigator.vibrate) navigator.vibrate([50, 50, 50]); UI.showToast('‚ö†Ô∏è Maximum 9999 points', 'warning'); return; }
            if(navigator.vibrate) navigator.vibrate(10);
            this.currentGame.state.temp[this.activePlayerId] = newVal;
            this.renderSwitcher();
            this.render();
        },
        addVal(value) {
            const current = this.currentGame.state.temp[this.activePlayerId] || 0;
            const newVal = current + value;
            if(newVal > 9999) { if(navigator.vibrate) navigator.vibrate([50, 50, 50]); UI.showToast('‚ö†Ô∏è Maximum 9999 points', 'warning'); return; }
            if(navigator.vibrate) navigator.vibrate(20);
            this.currentGame.state.temp[this.activePlayerId] = Math.max(0, newVal);
            this.renderSwitcher();
            this.render();
        },
        backspace() {
            const current = (this.currentGame.state.temp[this.activePlayerId] || 0).toString();
            this.currentGame.state.temp[this.activePlayerId] = current.length > 1 ? parseInt(current.slice(0, -1)) : 0;
            if(navigator.vibrate) navigator.vibrate(15);
            this.renderSwitcher();
            this.render();
        },
        clearInput() {
            this.currentGame.state.temp[this.activePlayerId] = 0;
            if(navigator.vibrate) navigator.vibrate([30, 50, 30]);
            this.renderSwitcher();
            this.render();
        },
        handleSmart() {
            SoundFX.click();
            if(this.currentGame.mode === 'belote') { this.currentGame.state.temp[this.activePlayerId] = 252; }
            else { const current = this.currentGame.state.temp[this.activePlayerId] || 0; this.currentGame.state.temp[this.activePlayerId] = current * -1; }
            this.renderSwitcher();
            this.render();
        },
        calcRest() {
            SoundFX.click();
            const otherPlayer = this.currentGame.state.players.find(p => p.id !== this.activePlayerId);
            if(otherPlayer) {
                const currentScore = this.currentGame.state.temp[this.activePlayerId] || 0;
                this.currentGame.state.temp[otherPlayer.id] = Math.max(0, 162 - currentScore);
                this.activePlayerId = otherPlayer.id;
                this.renderSwitcher();
                this.render();
            }
        },
        validateRound() {
            SoundFX.click();
            const state = this.currentGame.state;
            if(Object.keys(state.temp).length === 0) { UI.showToast('‚ö†Ô∏è Aucun score saisi', 'warning'); return; }
            const validation = GameState.validate(state.temp, this.currentGame.mode);
            if(!validation.valid) { UI.showToast(validation.error, 'error'); return; }
            const previousTotals = {};
            state.players.forEach(p => previousTotals[p.id] = p.total);
            
            let roundNumber;
            
            if(this.editIdx !== null) {
                roundNumber = this.editIdx + 1;
                GameState.updateRound(state, this.editIdx, state.temp);
                this.editIdx = null;
                document.getElementById('save-btn').textContent = `ENREGISTRER MANCHE ${state.history.length + 1}`;
                document.getElementById('save-btn').classList.remove('editing');
                UI.showToast(`‚úÖ Manche ${roundNumber} modifi√©e`, 'success');
            } else {
                roundNumber = state.history.length + 1;
                GameState.addRound(state, state.temp);
                const currentIdx = state.players.findIndex(p => p.id === state.dealerId);
                state.dealerId = state.players[(currentIdx + 1) % state.players.length].id;
                UI.showToast(`‚úÖ Manche ${roundNumber} enregistr√©e`, 'success');
            }
            if(this.currentGame.mode === 'standard') {
                state.players.forEach(p => {
                    const milestones = [200, 500, 1000];
                    milestones.forEach(milestone => {
                        const key = `${p.id}-${milestone}`;
                        if(!state.celebratedMilestones[key] && previousTotals[p.id] < milestone && p.total >= milestone) {
                            state.celebratedMilestones[key] = true;
                            setTimeout(() => UI.launchMilestoneConfetti(milestone), 300);
                        }
                    });
                });
            }
            
            // V√©rifier les conditions de fin de partie
            const endCond = this.currentGame.endCondition;
            const victCond = this.currentGame.victoryCondition;
            let gameEnded = false;
            let winner = null;
            
            if(this.currentGame.mode === 'belote') {
                winner = state.players.find(p => p.total >= 1000);
                if(winner) gameEnded = true;
            } else if(endCond.type === 'score') {
                if(victCond === 'highest') {
                    // Premier √† atteindre l'objectif gagne
                    winner = state.players.find(p => p.total >= endCond.value);
                    if(winner) gameEnded = true;
                } else {
                    // Premier √† d√©passer la limite perd, le plus petit score parmi les autres gagne
                    const overLimit = state.players.filter(p => p.total >= endCond.value);
                    if(overLimit.length > 0) {
                        gameEnded = true;
                        const remaining = state.players.filter(p => p.total < endCond.value);
                        if(remaining.length > 0) {
                            winner = remaining.sort((a,b) => a.total - b.total)[0];
                        } else {
                            // Tous ont d√©pass√©, le plus petit gagne
                            winner = [...state.players].sort((a,b) => a.total - b.total)[0];
                        }
                    }
                }
            }
            
            if(gameEnded && winner) {
                this.savedPlayers[this.currentGame.mode] = state.players.map(p => ({ name: p.name, color: p.color }));
                localStorage.setItem('sm_saved_players', JSON.stringify(this.savedPlayers));
                this.currentGame.finished = true;
                Storage.saveGame(this.currentGame);
                setTimeout(() => { UI.showVictory(winner, winner.total, state); }, 500);
            }
            
            if(!Storage.saveGame(this.currentGame)) {
                UI.showToast('‚ö†Ô∏è Erreur de sauvegarde (M√©moire pleine)', 'error');
            }
            state.temp = {};
            this.render();
        },
        startEdit(idx) {
            SoundFX.click();
            const state = this.currentGame.state;
            if(Object.keys(state.temp).length > 0) {
                UI.confirm('Abandonner la saisie en cours ?', () => {
                    this.editIdx = idx;
                    state.temp = {...state.history[idx]};
                    document.getElementById('save-btn').textContent = `MODIFIER MANCHE ${idx + 1}`;
                    document.getElementById('save-btn').classList.add('editing');
                    this.openSheet(state.players[0].id);
                });
                return;
            }
            this.editIdx = idx;
            state.temp = {...state.history[idx]};
            document.getElementById('save-btn').textContent = `MODIFIER MANCHE ${idx + 1}`;
            document.getElementById('save-btn').classList.add('editing');
            this.openSheet(state.players[0].id);
        },
        delRound(idx) {
            UI.confirm('Supprimer cette manche ?', () => {
                GameState.deleteRound(this.currentGame.state, idx);
                UI.showToast('‚úÖ Manche supprim√©e', 'success');
                this.render();
            });
        },
        undo() {
            const history = this.currentGame.state.history;
            if(history.length > 0) { this.delRound(history.length - 1); }
        }
    };
    
    // ==================== PWA MANAGER ====================
    const PWA = {
        deferredPrompt: null,
        isInstalled: false,
        
        init() {
            this.checkIfInstalled();
            this.registerServiceWorker();
            this.setupInstallPrompt();
            this.setupUpdateNotification();
            this.addInstallButton();
        },
        
        checkIfInstalled() {
            // V√©rifier si l'app est install√©e
            if (window.matchMedia('(display-mode: standalone)').matches || window.navigator.standalone === true) {
                this.isInstalled = true;
                console.log('[PWA] App install√©e');
            }
        },
        
        async registerServiceWorker() {
            if ('serviceWorker' in navigator) {
                try {
                    const registration = await navigator.serviceWorker.register('./service-worker.js');
                    console.log('[PWA] Service Worker enregistr√©:', registration.scope);
                    
                    // V√©rifier les mises √† jour
                    registration.addEventListener('updatefound', () => {
                        console.log('[PWA] Mise √† jour trouv√©e');
                        const newWorker = registration.installing;
                        newWorker.addEventListener('statechange', () => {
                            if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                                this.showUpdateNotification();
                            }
                        });
                    });
                } catch (error) {
                    console.error('[PWA] Erreur Service Worker:', error);
                }
            }
        },
        
        setupInstallPrompt() {
            window.addEventListener('beforeinstallprompt', (e) => {
                e.preventDefault();
                this.deferredPrompt = e;
                console.log('[PWA] Installation disponible');
                this.showInstallButton();
            });
            
            window.addEventListener('appinstalled', () => {
                console.log('[PWA] App install√©e avec succ√®s');
                this.isInstalled = true;
                this.hideInstallButton();
                UI.showToast('‚úÖ ScoreMaster install√© !', 'success');
            });
        },
        
        async installApp() {
            if (!this.deferredPrompt) {
                console.log('[PWA] Pas de prompt disponible');
                return;
            }
            
            this.deferredPrompt.prompt();
            const { outcome } = await this.deferredPrompt.userChoice;
            console.log('[PWA] Installation:', outcome);
            
            if (outcome === 'accepted') {
                SoundFX.success();
            }
            
            this.deferredPrompt = null;
            this.hideInstallButton();
        },
        
        addInstallButton() {
            // Cr√©er le bouton d'installation si pas encore install√©
            if (!this.isInstalled) {
                const setupContainer = document.getElementById('setup');
                if (setupContainer) {
                    const installBanner = document.createElement('div');
                    installBanner.id = 'install-banner';
                    installBanner.style.cssText = `
                        background: linear-gradient(135deg, var(--primary), #0051D5);
                        color: white;
                        padding: 15px 20px;
                        border-radius: 16px;
                        margin: 20px 0;
                        display: none;
                        align-items: center;
                        gap: 15px;
                        box-shadow: 0 8px 20px rgba(0,122,255,0.3);
                        cursor: pointer;
                        transition: transform 0.2s;
                    `;
                    installBanner.innerHTML = `
                        <div style="font-size: 32px;">üì±</div>
                        <div style="flex: 1;">
                            <div style="font-weight: 900; font-size: 16px; margin-bottom: 3px;">Installer ScoreMaster</div>
                            <div style="font-size: 12px; opacity: 0.9;">Acc√©dez rapidement depuis votre √©cran d'accueil</div>
                        </div>
                        <div style="font-size: 24px;">‚Üí</div>
                    `;
                    installBanner.onclick = () => this.installApp();
                    
                    const firstChild = setupContainer.querySelector('.header-controls');
                    if (firstChild && firstChild.nextSibling) {
                        setupContainer.insertBefore(installBanner, firstChild.nextSibling);
                    }
                }
            }
        },
        
        showInstallButton() {
            const banner = document.getElementById('install-banner');
            if (banner) {
                banner.style.display = 'flex';
                setTimeout(() => {
                    banner.style.animation = 'slideIn 0.4s ease-out';
                }, 100);
            }
        },
        
        hideInstallButton() {
            const banner = document.getElementById('install-banner');
            if (banner) {
                banner.style.display = 'none';
            }
        },
        
        setupUpdateNotification() {
            // √âcouter les messages du Service Worker
            navigator.serviceWorker?.addEventListener('message', (event) => {
                if (event.data.type === 'UPDATE_AVAILABLE') {
                    this.showUpdateNotification();
                }
            });
        },
        
        showUpdateNotification() {
            const updateBanner = document.createElement('div');
            updateBanner.style.cssText = `
                position: fixed;
                top: max(20px, env(safe-area-inset-top));
                left: 50%;
                transform: translateX(-50%);
                background: var(--card);
                border: 2px solid var(--primary);
                padding: 12px 20px;
                border-radius: 16px;
                box-shadow: 0 8px 20px rgba(0,0,0,0.2);
                z-index: 9999;
                display: flex;
                align-items: center;
                gap: 12px;
                max-width: 90%;
                animation: slideIn 0.4s ease-out;
            `;
            updateBanner.innerHTML = `
                <div style="font-size: 20px;">üÜï</div>
                <div style="flex: 1;">
                    <div style="font-weight: 700; font-size: 14px; color: var(--text);">Mise √† jour disponible</div>
                    <div style="font-size: 12px; color: var(--text-sec);">Rechargez pour la derni√®re version</div>
                </div>
                <button onclick="location.reload()" style="background: var(--primary); color: white; border: none; padding: 8px 16px; border-radius: 8px; font-weight: 700; font-size: 12px; cursor: pointer;">
                    RECHARGER
                </button>
            `;
            document.body.appendChild(updateBanner);
            
            // Auto-hide apr√®s 10 secondes
            setTimeout(() => {
                updateBanner.style.opacity = '0';
                updateBanner.style.transition = 'opacity 0.3s';
                setTimeout(() => updateBanner.remove(), 300);
            }, 10000);
        }
    };
    







    // ==================== RECAP GENERATOR V3.4 DYNAMIC ====================
    const RecapGenerator = {
        // Espacements optimis√©s
        SPACING: {
            AFTER_BANNER: 40,           
            BEFORE_CHAMPION: 40,        
            AFTER_CHAMPION: 20,         
            SECTION_HEADER: 15,         // Entre bandeau et contenu
            BETWEEN_SECTIONS: 30,       // Entre sections
            SECTION_PADDING: 25,        // Padding interne des sections (r√©duit de 30)
            ITEM_SPACING: 20            // Entre items (r√©duit de 38)
        },
        
        GENRE_COLORS: {
            DOMINATION: { primary: '#8B0000', secondary: '#FFD700', accent: '#FF4500', bg: 'rgba(139, 0, 0, 0.1)' },
            THRILLER: { primary: '#FF6B35', secondary: '#F7931E', accent: '#FDC830', bg: 'rgba(255, 107, 53, 0.1)' },
            CHAOS: { primary: '#6A0572', secondary: '#AB47BC', accent: '#E91E63', bg: 'rgba(106, 5, 114, 0.1)' },
            COMEBACK: { primary: '#2B5AA0', secondary: '#5B9BD5', accent: '#1E88E5', bg: 'rgba(43, 90, 160, 0.1)' }
        },
        
        StoryBrain: {
            analyze(history, players) {
                const totals = {};
                players.forEach((p, i) => totals[i] = 0);
                const leaders = [];
                const curves = players.map(() => []);
                
                history.forEach(r => {
                    players.forEach((p, i) => {
                        totals[i] += r[p.id] || 0;
                        curves[i].push(totals[i]);
                    });
                    const sorted = players.map((p, i) => ({ i, t: totals[i] })).sort((a, b) => b.t - a.t);
                    leaders.push(sorted[0].i);
                });
                
                let changes = 0;
                for (let i = 1; i < leaders.length; i++) {
                    if (leaders[i] != leaders[i - 1]) changes++;
                }
                
                const last = leaders[leaders.length - 1];
                const first = leaders[0];
                const finals = curves.map(c => c[c.length - 1]);
                const sortedF = finals.map((t, i) => ({ i, t })).sort((a, b) => b.t - a.t);
                const gap = sortedF[0].t - sortedF[1].t;
                
                let genre;
                if (changes >= 3) genre = "CHAOS";
                else if (first !== last) genre = "COMEBACK";
                else if (gap <= 100) genre = "THRILLER";
                else genre = "DOMINATION";
                
                return { genre, winner: players[last].name, winnerIdx: last, first: players[first].name, changes, gap, curves };
            }
        },
        
        PlayerCasting: {
            analyze(history, players) {
                const stats = players.map(p => ({ name: p.name, color: p.color, total: 0, best: -999, worst: 999, wins: 0 }));
                history.forEach(r => {
                    const scores = players.map((p, i) => ({ i, score: r[p.id] || 0 }));
                    const maxScore = Math.max(...scores.map(s => s.score));
                    
                    players.forEach((p, i) => {
                        const score = r[p.id] || 0;
                        stats[i].total += score;
                        stats[i].best = Math.max(stats[i].best, score);
                        stats[i].worst = Math.min(stats[i].worst, score);
                        if (score === maxScore && score > 0) stats[i].wins++;
                    });
                });
                const sorted = [...stats].sort((a, b) => b.total - a.total);
                const precision = sorted.map(s => ({
                    name: s.name,
                    value: history.length > 0 ? Math.round((s.wins / history.length) * 100) : 0
                }));
                return { hero: sorted[0].name, boulet: sorted[sorted.length - 1].name, stats: sorted, precision };
            }
        },
        
        NarrativeEngine: {
            pick: a => a[Math.floor(Math.random() * a.length)],
            templates: {
                DOMINATION: [
                    "Une bataille jusqu'√† la derni√®re manche. {b} a confondu strat√©gie et catastrophe.",
                    "Match √† sens unique du d√©but √† la fin. {b} n'a jamais exist√© dans cette partie.",
                    "Performance de tr√®s haut niveau. {b} devrait peut-√™tre changer de jeu.",
                    "D√©monstration absolue. {b} a √©t√© balay√© comme un f√©tu de paille.",
                    "Aucune piti√©, aucune chance. {b} a subi de bout en bout."
                ],
                THRILLER: [
                    "Une fin irrespirable. {b} a offert un grand moment de solitude.",
                    "Chaque point comptait. {b} s'est effondr√© au mauvais moment.",
                    "Un match de folie. {b} a craqu√© sous la pression.",
                    "Suspense insoutenable. {b} n'a pas tenu la distance.",
                    "Combat acharn√©. {b} a abandonn√© trop t√¥t."
                ],
                CHAOS: [
                    "Un chaos total du d√©but √† la fin. {b} a jou√© comme un pied.",
                    "Rebondissements √† chaque manche. {b} n'a rien compris au jeu.",
                    "Un joyeux bordel indescriptible. {b} s'est perdu en route.",
                    "Sc√©nario compl√®tement fou. {b} a fait n'importe quoi.",
                    "Impr√©visible de bout en bout. {b} a coul√© tout seul."
                ],
                COMEBACK: [
                    "Incroyable remont√©e. {b} devrait envisager un autre jeu.",
                    "Retour spectaculaire. {b} s'est fait avoir comme un bleu.",
                    "Renversement de situation. {b} pensait avoir gagn√©, quelle erreur.",
                    "Comeback l√©gendaire. {b} a vu la victoire lui √©chapper.",
                    "Remontada inoubliable. {b} va ruminer cette d√©faite longtemps."
                ]
            },
            reactions: {
                winner: [
                    "C'√©tait trop facile",
                    "Je savais que j'allais gagner",
                    "Vous m'avez pas fait transpirer",
                    "J'ai jou√© √† 50%",
                    "Merci pour l'entra√Ænement",
                    "On fait une vraie partie ?",
                    "Je m'attendais √† mieux",
                    "J'ai failli m'endormir"
                ],
                loser: [
                    "J'ai pas eu de chance",
                    "Je pense qu'il/elle a trich√©",
                    "Les cartes √©taient pourries",
                    "J'√©tais pas concentr√©",
                    "La prochaine fois je m√©lange",
                    "C'est de la chance pure",
                    "Mauvais tirage",
                    "Que des mauvaises cartes !"
                ]
            },
            build(brain, cast) {
                return this.pick(this.templates[brain.genre]).replace("{b}", cast.boulet);
            },
            getWinnerQuote() {
                return this.pick(this.reactions.winner);
            },
            getLoserQuote() {
                return this.pick(this.reactions.loser);
            }
        },
        
        async generate(gameState) {
            try {
                UI.showToast('üé® G√©n√©ration r√©cap DYNAMIC...', 'info');
                
                const canvas = document.createElement('canvas');
                canvas.width = 1080;
                
                const brain = this.StoryBrain.analyze(gameState.history, gameState.players);
                const cast = this.PlayerCasting.analyze(gameState.history, gameState.players);
                const narrative = this.NarrativeEngine.build(brain, cast);
                
                let bestRound = { player: null, score: -999, round: 0 };
                let worstRound = { player: null, score: 999, round: 0 };
                let secondBestRound = { player: null, score: -999, round: 0 };
                
                gameState.history.forEach((round, idx) => {
                    Object.keys(round).forEach(playerId => {
                        const score = round[playerId];
                        const player = gameState.players.find(p => p.id.toString() === playerId);
                        if (player) {
                            if (score > bestRound.score) {
                                secondBestRound = {...bestRound};
                                bestRound = { player: player.name, score, round: idx + 1 };
                            } else if (score > secondBestRound.score && score !== bestRound.score) {
                                secondBestRound = { player: player.name, score, round: idx + 1 };
                            }
                            if (score < worstRound.score) {
                                worstRound = { player: player.name, score, round: idx + 1 };
                            }
                        }
                    });
                });
                
                let bestStreak = { player: null, count: 0 };
                gameState.players.forEach(player => {
                    let current = 0, max = 0;
                    gameState.history.forEach(round => {
                        const scores = Object.entries(round).map(([id, score]) => ({ id: parseInt(id), score }));
                        const winner = scores.reduce((m, c) => c.score > m.score ? c : m);
                        if (winner.id === player.id) {
                            current++;
                            max = Math.max(max, current);
                        } else {
                            current = 0;
                        }
                    });
                    if (max > bestStreak.count) bestStreak = { player: player.name, count: max };
                });
                
                const sorted = [...gameState.players].sort((a,b) => b.total - a.total);
                const finalGap = sorted[0].total - sorted[1].total;
                
                const ctx = canvas.getContext('2d');
                const height = await this.draw(ctx, { 
                    brain, 
                    cast, 
                    narrative, 
                    bestRound,
                    secondBestRound,
                    worstRound, 
                    bestStreak,
                    finalGap
                }, gameState);
                
                canvas.height = height;
                
                await this.draw(ctx, { 
                    brain, 
                    cast, 
                    narrative, 
                    bestRound,
                    secondBestRound,
                    worstRound, 
                    bestStreak,
                    finalGap
                }, gameState);
                
                UI.showToast('‚úÖ R√©cap DYNAMIC g√©n√©r√© !', 'success');
                return canvas;
                
            } catch(error) {
                console.error('[RecapGenerator] Erreur:', error);
                UI.showToast('‚ùå Erreur g√©n√©ration', 'error');
                return null;
            }
        },
        
        async draw(ctx, ai, gameState) {
            const width = 1080;
            const colors = this.GENRE_COLORS[ai.brain.genre];
            const sp = this.SPACING;
            
            ctx.fillStyle = '#F5F1E8';
            ctx.fillRect(0, 0, width, 3000);
            
            ctx.fillStyle = 'rgba(139, 119, 101, 0.03)';
            for (let i = 0; i < 5000; i++) {
                ctx.fillRect(Math.random() * width, Math.random() * 3000, 1, 1);
            }
            
            this.drawFoldedPaper(ctx, width, 3000);
            
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 4;
            
            let y = 50;
            
            y = this.drawBanner3D(ctx, y, width, colors);
            y += sp.AFTER_BANNER;
            
            y = this.drawConfetti(ctx, width / 2, y + 20, 30);
            y += sp.BEFORE_CHAMPION;
            
            y = this.drawChampionBlock(ctx, y, width, ai.brain.winner, gameState.players.find(p => p.name === ai.brain.winner).total, colors);
            y += sp.AFTER_CHAMPION;
            
            ctx.font = 'italic 900 48px Arial';
            ctx.fillStyle = colors.primary;
            ctx.textAlign = 'center';
            ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
            ctx.shadowBlur = 4;
            ctx.shadowOffsetY = 2;
            ctx.fillText('√âCRASE LA CONCURRENCE', width / 2, y);
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            ctx.shadowOffsetY = 0;
            y += 65;
            
            ctx.font = 'italic 700 22px Georgia';
            ctx.fillStyle = '#1A1A1A';
            const words = ai.narrative.split(' ');
            let lines = [];
            let line = '';
            words.forEach(word => {
                const test = line + word + ' ';
                const m = ctx.measureText(test);
                if (m.width > width - 140) {
                    if (line) lines.push(line.trim());
                    line = word + ' ';
                } else {
                    line = test;
                }
            });
            if (line) lines.push(line.trim());
            lines.forEach((l, idx) => {
                ctx.fillText(l, width / 2, y + (idx * 30));
            });
            y += lines.length * 30 + 35;
            
            ctx.fillStyle = '#000000';
            ctx.fillRect(55, y, width - 110, 3);
            y += 30;
            
            y = this.drawGraphWithZones(ctx, 55, y, width - 110, ai, gameState, colors);
            y += 30;
            
            ctx.fillStyle = '#000000';
            ctx.fillRect(55, y, width - 110, 2);
            ctx.fillRect(55, y + 5, width - 110, 2);
            y += 40;
            
            const leftCol = 55;
            const colWidth = 465;
            const rightCol = leftCol + colWidth + 30;
            
            let yLeft = y;
            let yRight = y;
            
            yLeft = this.drawPodium3DImproved(ctx, leftCol, yLeft, colWidth, gameState.players, colors);
            yLeft += sp.BETWEEN_SECTIONS;
            yLeft = this.drawReactionsDynamic(ctx, leftCol, yLeft, colWidth, ai, colors);
            
            yRight = this.drawTempsFortsDynamic(ctx, rightCol, yRight, colWidth, ai, colors, gameState);
            yRight += sp.BETWEEN_SECTIONS;
            yRight = this.drawStatsDynamic(ctx, rightCol, yRight, colWidth, ai, gameState, colors);
            
            const finalY = Math.max(yLeft, yRight) + 60;
            
            ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
            ctx.shadowBlur = 5;
            ctx.shadowOffsetY = 2;
            ctx.font = 'bold 26px Arial';
            ctx.fillStyle = colors.primary;
            ctx.textAlign = 'center';
            ctx.fillText('ScoreMaster Sports‚Ñ¢', width / 2, finalY);
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            ctx.shadowOffsetY = 0;
            
            ctx.font = 'italic 20px Georgia';
            ctx.fillStyle = '#666';
            ctx.fillText('"On immortalise vos d√©faites depuis 2026"', width / 2, finalY + 35);
            
            const totalHeight = finalY + 80;
            
            ctx.strokeRect(25, 25, width - 50, totalHeight - 50);
            
            return totalHeight;
        },
        
        drawFoldedPaper(ctx, width, height) {
            const foldX = width / 2;
            const foldGradient = ctx.createLinearGradient(foldX - 3, 0, foldX + 3, 0);
            foldGradient.addColorStop(0, 'rgba(0, 0, 0, 0)');
            foldGradient.addColorStop(0.5, 'rgba(0, 0, 0, 0.05)');
            foldGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = foldGradient;
            ctx.fillRect(foldX - 3, 0, 6, height);
            
            for (let i = 0; i < 15; i++) {
                const x = Math.random() * width;
                const y = Math.random() * height;
                const w = Math.random() * 100 + 50;
                const angle = Math.random() * Math.PI / 6;
                
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(angle);
                ctx.fillStyle = 'rgba(0, 0, 0, 0.015)';
                ctx.fillRect(0, 0, w, 1);
                ctx.restore();
            }
        },
        
        drawBanner3D(ctx, y, width, colors) {
            ctx.fillStyle = '#000000';
            ctx.fillRect(55, y, width - 110, 4);
            y += 4;
            
            const gradient = ctx.createLinearGradient(0, y, 0, y + 130);
            gradient.addColorStop(0, colors.primary);
            gradient.addColorStop(0.5, colors.primary + 'DD');
            gradient.addColorStop(1, colors.primary + 'BB');
            ctx.fillStyle = gradient;
            
            ctx.shadowColor = 'rgba(0, 0, 0, 0.4)';
            ctx.shadowBlur = 15;
            ctx.shadowOffsetY = 8;
            ctx.fillRect(55, y, width - 110, 130);
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            ctx.shadowOffsetY = 0;
            
            ctx.fillStyle = '#000000';
            ctx.fillRect(55, y + 130, width - 110, 4);
            
            ctx.font = 'italic 900 95px Georgia';
            ctx.textAlign = 'center';
            
            ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
            ctx.shadowBlur = 3;
            ctx.shadowOffsetX = 6;
            ctx.shadowOffsetY = 6;
            ctx.fillStyle = '#000000';
            ctx.fillText('LE SCORE', width / 2, y + 87);
            
            ctx.shadowColor = 'rgba(255, 255, 255, 0.3)';
            ctx.shadowBlur = 5;
            ctx.shadowOffsetX = -2;
            ctx.shadowOffsetY = -2;
            ctx.fillStyle = '#FFFFFF';
            ctx.fillText('LE SCORE', width / 2, y + 85);
            
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
            
            y += 140;
            y += 35;
            
            ctx.font = 'bold 21px Arial';
            ctx.fillStyle = '#000000';
            const date = new Date().toLocaleDateString('fr-FR', {
                weekday: 'long',
                day: 'numeric',
                month: 'long',
                year: 'numeric'
            });
            ctx.fillText(`√âDITION SP√âCIALE ‚Äî ${date.toUpperCase()}`, width / 2, y);
            
            return y;
        },
        
        drawConfetti(ctx, cx, cy, count) {
            const confettiColors = ['#FF6B35', '#F7931E', '#FDC830', '#4CAF50', '#2196F3', '#9C27B0'];
            for (let i = 0; i < count; i++) {
                const x = cx + Math.random() * 300 - 150;
                const y = cy + Math.random() * 80 - 40;
                const size = Math.random() * 8 + 4;
                const rotation = Math.random() * Math.PI * 2;
                
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation);
                ctx.fillStyle = confettiColors[Math.floor(Math.random() * confettiColors.length)];
                ctx.globalAlpha = 0.7;
                ctx.fillRect(-size/2, -size/2, size, size);
                ctx.globalAlpha = 1;
                ctx.restore();
            }
            return cy;
        },
        
        drawChampionBlock(ctx, y, width, name, score, colors) {
            const blockWidth = 450;
            const blockHeight = 100;
            const x = (width - blockWidth) / 2;
            
            const gradient = ctx.createLinearGradient(x, y, x, y + blockHeight);
            gradient.addColorStop(0, colors.secondary);
            gradient.addColorStop(0.5, colors.accent);
            gradient.addColorStop(1, colors.secondary);
            ctx.fillStyle = gradient;
            
            ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
            ctx.shadowBlur = 20;
            ctx.shadowOffsetY = 10;
            ctx.fillRect(x, y, blockWidth, blockHeight);
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            ctx.shadowOffsetY = 0;
            
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 4;
            ctx.strokeRect(x, y, blockWidth, blockHeight);
            
            ctx.font = 'bold 50px Arial';
            ctx.fillStyle = '#000';
            ctx.textAlign = 'center';
            ctx.shadowColor = 'rgba(255, 255, 255, 0.5)';
            ctx.shadowBlur = 3;
            ctx.fillText(`üèÜ ${name.toUpperCase()} üèÜ`, width / 2, y + 45);
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            
            ctx.font = 'bold 32px Arial';
            ctx.fillText(`${score} pts`, width / 2, y + 80);
            
            return y + blockHeight;
        },
        
        drawGraphWithZones(ctx, x, y, w, ai, gameState, colors) {
            const h = 340;
            const padding = 50;
            
            ctx.fillStyle = '#FFFFFF';
            ctx.shadowColor = 'rgba(0, 0, 0, 0.15)';
            ctx.shadowBlur = 15;
            ctx.shadowOffsetY = 5;
            ctx.fillRect(x, y, w, h);
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            ctx.shadowOffsetY = 0;
            
            ctx.strokeStyle = '#CCCCCC';
            ctx.lineWidth = 2;
            ctx.strokeRect(x, y, w, h);
            
            ctx.font = 'bold 26px Arial';
            ctx.fillStyle = colors.primary;
            ctx.textAlign = 'center';
            ctx.fillText('üìà √âVOLUTION DES SCORES', x + w / 2, y + 30);
            
            const gx = x + padding;
            const gy = y + 60;
            const gw = w - padding * 2;
            const gh = h - 110;
            
            const curves = ai.brain.curves;
            const maxScore = Math.max(...curves.flat());
            const minScore = Math.min(...curves.flat(), 0);
            const nbRounds = gameState.history.length;
            
            const winGradient = ctx.createLinearGradient(0, gy, 0, gy + gh/3);
            winGradient.addColorStop(0, 'rgba(76, 175, 80, 0.15)');
            winGradient.addColorStop(1, 'rgba(76, 175, 80, 0)');
            ctx.fillStyle = winGradient;
            ctx.fillRect(gx, gy, gw, gh/3);
            
            const loseGradient = ctx.createLinearGradient(0, gy + 2*gh/3, 0, gy + gh);
            loseGradient.addColorStop(0, 'rgba(244, 67, 54, 0)');
            loseGradient.addColorStop(1, 'rgba(244, 67, 54, 0.15)');
            ctx.fillStyle = loseGradient;
            ctx.fillRect(gx, gy + 2*gh/3, gw, gh/3);
            
            const avgScore = (maxScore + minScore) / 2;
            const avgY = gy + gh - ((avgScore - minScore) / (maxScore - minScore || 1)) * gh;
            ctx.strokeStyle = '#999';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(gx, avgY);
            ctx.lineTo(gx + gw, avgY);
            ctx.stroke();
            ctx.setLineDash([]);
            
            ctx.strokeStyle = '#E5E5E5';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 4; i++) {
                const gridY = gy + (gh / 4) * i;
                ctx.beginPath();
                ctx.moveTo(gx, gridY);
                ctx.lineTo(gx + gw, gridY);
                ctx.stroke();
                
                const value = maxScore - ((maxScore - minScore) / 4) * i;
                ctx.font = '14px Arial';
                ctx.fillStyle = '#666';
                ctx.textAlign = 'right';
                ctx.fillText(Math.round(value), gx - 10, gridY + 5);
            }
            
            ctx.font = '14px Arial';
            ctx.fillStyle = '#666';
            ctx.textAlign = 'center';
            ctx.fillText('0', gx, y + h - 25);
            for (let i = 0; i < nbRounds; i++) {
                const labelX = gx + ((gw / nbRounds) * (i + 1));
                ctx.fillText(`M${i + 1}`, labelX, y + h - 25);
            }
            
            curves.forEach((curve, playerIdx) => {
                const player = gameState.players[playerIdx];
                ctx.strokeStyle = player.color;
                ctx.lineWidth = 5;
                ctx.beginPath();
                
                ctx.moveTo(gx, gy + gh);
                
                curve.forEach((score, roundIdx) => {
                    const px = gx + ((gw / nbRounds) * (roundIdx + 1));
                    const py = gy + gh - ((score - minScore) / (maxScore - minScore || 1)) * gh;
                    ctx.lineTo(px, py);
                });
                
                ctx.stroke();
                
                ctx.fillStyle = player.color + '40';
                curve.forEach((score, roundIdx) => {
                    const px = gx + ((gw / nbRounds) * (roundIdx + 1));
                    const py = gy + gh - ((score - minScore) / (maxScore - minScore || 1)) * gh;
                    ctx.beginPath();
                    ctx.arc(px, py, 10, 0, Math.PI * 2);
                    ctx.fill();
                });
                
                ctx.fillStyle = player.color;
                curve.forEach((score, roundIdx) => {
                    const px = gx + ((gw / nbRounds) * (roundIdx + 1));
                    const py = gy + gh - ((score - minScore) / (maxScore - minScore || 1)) * gh;
                    ctx.beginPath();
                    ctx.arc(px, py, 6, 0, Math.PI * 2);
                    ctx.fill();
                });
                
                const lastScore = curve[curve.length - 1];
                const lastX = gx + gw;
                const lastY = gy + gh - ((lastScore - minScore) / (maxScore - minScore || 1)) * gh;
                ctx.fillStyle = player.color + '60';
                ctx.beginPath();
                ctx.arc(lastX, lastY, 14, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = player.color;
                ctx.beginPath();
                ctx.arc(lastX, lastY, 9, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.font = 'bold 16px Arial';
                ctx.fillStyle = player.color;
                ctx.textAlign = 'left';
                ctx.fillText(player.name, lastX + 18, lastY + 5);
            });
            
            return y + h + 20;
        },
        
        drawPodium3DImproved(ctx, x, y, w, players, colors) {
            const sorted = [...players].sort((a,b) => b.total - a.total);
            
            ctx.shadowColor = 'rgba(0, 0, 0, 0.2)';
            ctx.shadowBlur = 10;
            ctx.shadowOffsetY = 3;
            ctx.fillStyle = colors.primary;
            ctx.fillRect(x, y, w, 45);
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            ctx.shadowOffsetY = 0;
            
            ctx.font = 'bold 24px Arial';
            ctx.fillStyle = '#FFFFFF';
            ctx.textAlign = 'center';
            ctx.fillText('üèÜ LE CLASSEMENT FINAL', x + w / 2, y + 30);
            
            y += 45 + this.SPACING.SECTION_HEADER;
            
            const podiumY = y;
            const podiumHeight = 320;
            
            ctx.fillStyle = '#FFFFFF';
            ctx.shadowColor = 'rgba(0, 0, 0, 0.15)';
            ctx.shadowBlur = 15;
            ctx.shadowOffsetY = 5;
            ctx.fillRect(x, y, w, podiumHeight);
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            ctx.shadowOffsetY = 0;
            
            ctx.strokeStyle = '#CCCCCC';
            ctx.lineWidth = 2;
            ctx.strokeRect(x, y, w, podiumHeight);
            
            y += 25;
            
            const blockWidth = 130;
            const spacing = 10;
            const totalWidth = blockWidth * 3 + spacing * 2;
            const startX = x + (w - totalWidth) / 2;
            
            const pos2X = startX;
            const pos1X = startX + blockWidth + spacing;
            const pos3X = startX + (blockWidth + spacing) * 2;
            
            if (sorted.length > 1) {
                const h2 = 120;
                const y2 = podiumY + podiumHeight - h2 - 30;
                
                ctx.save();
                ctx.shadowColor = 'rgba(0, 0, 0, 0.25)';
                ctx.shadowBlur = 8;
                ctx.shadowOffsetY = 4;
                
                const grad2 = ctx.createLinearGradient(pos2X, y2, pos2X, y2 + h2);
                grad2.addColorStop(0, '#E0E0E0');
                grad2.addColorStop(0.3, '#C0C0C0');
                grad2.addColorStop(0.7, '#A8A8A8');
                grad2.addColorStop(1, '#909090');
                ctx.fillStyle = grad2;
                ctx.fillRect(pos2X, y2, blockWidth, h2);
                ctx.restore();
                
                ctx.strokeStyle = '#666';
                ctx.lineWidth = 3;
                ctx.strokeRect(pos2X, y2, blockWidth, h2);
                
                ctx.font = '40px Arial';
                ctx.fillText('ü•à', pos2X + blockWidth/2, y2 - 10);
                
                ctx.font = 'bold 20px Arial';
                ctx.fillStyle = '#000';
                const name2 = sorted[1].name.length > 7 ? sorted[1].name.substring(0, 7) : sorted[1].name;
                ctx.fillText(name2, pos2X + blockWidth/2, y2 + h2/2 - 5);
                
                ctx.font = 'bold 24px Arial';
                ctx.fillStyle = '#333';
                ctx.fillText(sorted[1].total, pos2X + blockWidth/2, y2 + h2/2 + 22);
                
                ctx.font = '16px Arial';
                ctx.fillStyle = '#666';
                const diff1 = sorted[0].total - sorted[1].total;
                ctx.fillText(`-${diff1}`, pos2X + blockWidth/2, y2 + h2/2 + 42);
            }
            
            const h1 = 180;
            const y1 = podiumY + podiumHeight - h1 - 30;
            
            ctx.save();
            ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
            ctx.shadowBlur = 12;
            ctx.shadowOffsetY = 6;
            
            const grad1 = ctx.createLinearGradient(pos1X, y1, pos1X, y1 + h1);
            grad1.addColorStop(0, '#FFD700');
            grad1.addColorStop(0.3, '#FFED4E');
            grad1.addColorStop(0.5, '#FFC107');
            grad1.addColorStop(0.7, '#FFB300');
            grad1.addColorStop(1, '#FF8F00');
            ctx.fillStyle = grad1;
            ctx.fillRect(pos1X, y1, blockWidth, h1);
            ctx.restore();
            
            ctx.strokeStyle = '#CC8800';
            ctx.lineWidth = 4;
            ctx.strokeRect(pos1X, y1, blockWidth, h1);
            
            ctx.font = '45px Arial';
            ctx.fillText('üèÜ', pos1X + blockWidth/2, y1 - 10);
            
            ctx.font = 'bold 22px Arial';
            ctx.fillStyle = '#000';
            const name1 = sorted[0].name.length > 7 ? sorted[0].name.substring(0, 7) : sorted[0].name;
            ctx.fillText(name1, pos1X + blockWidth/2, y1 + h1/2 - 18);
            
            ctx.font = 'bold 28px Arial';
            ctx.fillStyle = '#000';
            ctx.fillText(sorted[0].total, pos1X + blockWidth/2, y1 + h1/2 + 10);
            
            ctx.font = 'bold 18px Arial';
            ctx.fillStyle = '#8B4513';
            ctx.fillText('CHAMPION', pos1X + blockWidth/2, y1 + h1/2 + 35);
            
            if (sorted.length > 2) {
                const h3 = 90;
                const y3 = podiumY + podiumHeight - h3 - 30;
                
                ctx.save();
                ctx.shadowColor = 'rgba(0, 0, 0, 0.2)';
                ctx.shadowBlur = 6;
                ctx.shadowOffsetY = 3;
                
                const grad3 = ctx.createLinearGradient(pos3X, y3, pos3X, y3 + h3);
                grad3.addColorStop(0, '#E4A853');
                grad3.addColorStop(0.4, '#CD7F32');
                grad3.addColorStop(0.7, '#B87333');
                grad3.addColorStop(1, '#8B5A2B');
                ctx.fillStyle = grad3;
                ctx.fillRect(pos3X, y3, blockWidth, h3);
                ctx.restore();
                
                ctx.strokeStyle = '#8B5A2B';
                ctx.lineWidth = 3;
                ctx.strokeRect(pos3X, y3, blockWidth, h3);
                
                ctx.font = '35px Arial';
                ctx.fillText('ü•â', pos3X + blockWidth/2, y3 - 8);
                
                ctx.font = 'bold 18px Arial';
                ctx.fillStyle = '#000';
                const name3 = sorted[2].name.length > 7 ? sorted[2].name.substring(0, 7) : sorted[2].name;
                ctx.fillText(name3, pos3X + blockWidth/2, y3 + h3/2 - 2);
                
                ctx.font = 'bold 22px Arial';
                ctx.fillStyle = '#333';
                ctx.fillText(sorted[2].total, pos3X + blockWidth/2, y3 + h3/2 + 22);
                
                const diff2 = sorted[0].total - sorted[2].total;
                ctx.font = '14px Arial';
                ctx.fillStyle = '#666';
                ctx.fillText(`-${diff2}`, pos3X + blockWidth/2, y3 + h3/2 + 40);
            }
            
            return podiumY + podiumHeight;
        },
        
        drawReactionsDynamic(ctx, x, y, w, ai, colors) {
            const sp = this.SPACING;
            const startY = y;
            
            const gradient = ctx.createLinearGradient(x, y, x + w, y);
            gradient.addColorStop(0, colors.accent);
            gradient.addColorStop(1, colors.primary);
            ctx.fillStyle = gradient;
            
            ctx.shadowColor = 'rgba(0, 0, 0, 0.2)';
            ctx.shadowBlur = 10;
            ctx.shadowOffsetY = 3;
            ctx.fillRect(x, y, w, 45);
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            ctx.shadowOffsetY = 0;
            
            ctx.font = 'bold 24px Arial';
            ctx.fillStyle = '#FFFFFF';
            ctx.textAlign = 'center';
            ctx.fillText('üí¨ LES R√âACTIONS', x + w / 2, y + 30);
            
            y += 45 + sp.SECTION_HEADER;
            
            const contentStartY = y;
            y += sp.SECTION_PADDING;
            
            ctx.font = 'bold 19px Arial';
            ctx.fillStyle = colors.primary;
            ctx.textAlign = 'left';
            ctx.fillText(`üé§ ${ai.brain.winner.toUpperCase()}`, x + 20, y);
            y += 24;
            
            const winnerQuote = this.NarrativeEngine.getWinnerQuote();
            ctx.font = 'italic 17px Georgia';
            ctx.fillStyle = '#555';
            const winnerLines = this.wrapText(ctx, `"${winnerQuote}"`, w - 40);
            winnerLines.forEach((line, idx) => {
                ctx.fillText(line, x + 20, y + (idx * 22));
            });
            y += winnerLines.length * 22 + 20;
            
            ctx.strokeStyle = '#EEEEEE';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(x + 20, y);
            ctx.lineTo(x + w - 20, y);
            ctx.stroke();
            y += 20;
            
            ctx.font = 'bold 19px Arial';
            ctx.fillStyle = '#C8102E';
            ctx.fillText(`üò≠ ${ai.cast.boulet.toUpperCase()}`, x + 20, y);
            y += 24;
            
            const loserQuote = this.NarrativeEngine.getLoserQuote();
            ctx.font = 'italic 17px Georgia';
            ctx.fillStyle = '#555';
            const loserLines = this.wrapText(ctx, `"${loserQuote}"`, w - 40);
            loserLines.forEach((line, idx) => {
                ctx.fillText(line, x + 20, y + (idx * 22));
            });
            y += loserLines.length * 22 + sp.SECTION_PADDING;
            
            const sectionHeight = y - contentStartY;
            
            ctx.fillStyle = '#FFFFFF';
            ctx.shadowColor = 'rgba(0, 0, 0, 0.15)';
            ctx.shadowBlur = 15;
            ctx.shadowOffsetY = 5;
            ctx.fillRect(x, contentStartY, w, sectionHeight);
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            ctx.shadowOffsetY = 0;
            
            ctx.strokeStyle = '#CCCCCC';
            ctx.lineWidth = 2;
            ctx.strokeRect(x, contentStartY, w, sectionHeight);
            
            y = contentStartY + sp.SECTION_PADDING;
            
            ctx.font = 'bold 19px Arial';
            ctx.fillStyle = colors.primary;
            ctx.textAlign = 'left';
            ctx.fillText(`üé§ ${ai.brain.winner.toUpperCase()}`, x + 20, y);
            y += 24;
            
            ctx.font = 'italic 17px Georgia';
            ctx.fillStyle = '#555';
            winnerLines.forEach((line, idx) => {
                ctx.fillText(line, x + 20, y + (idx * 22));
            });
            y += winnerLines.length * 22 + 20;
            
            ctx.strokeStyle = '#EEEEEE';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(x + 20, y);
            ctx.lineTo(x + w - 20, y);
            ctx.stroke();
            y += 20;
            
            ctx.font = 'bold 19px Arial';
            ctx.fillStyle = '#C8102E';
            ctx.fillText(`üò≠ ${ai.cast.boulet.toUpperCase()}`, x + 20, y);
            y += 24;
            
            ctx.font = 'italic 17px Georgia';
            ctx.fillStyle = '#555';
            loserLines.forEach((line, idx) => {
                ctx.fillText(line, x + 20, y + (idx * 22));
            });
            
            return contentStartY + sectionHeight;
        },
        
        drawTempsFortsDynamic(ctx, x, y, w, ai, colors, gameState) {
            const sp = this.SPACING;
            const startY = y;
            
            const gradient = ctx.createLinearGradient(x, y, x + w, y);
            gradient.addColorStop(0, colors.primary);
            gradient.addColorStop(1, colors.accent);
            ctx.fillStyle = gradient;
            
            ctx.shadowColor = 'rgba(0, 0, 0, 0.2)';
            ctx.shadowBlur = 10;
            ctx.shadowOffsetY = 3;
            ctx.fillRect(x, y, w, 45);
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            ctx.shadowOffsetY = 0;
            
            ctx.font = 'bold 24px Arial';
            ctx.fillStyle = '#FFFFFF';
            ctx.textAlign = 'center';
            ctx.fillText('‚≠ê LES TEMPS FORTS', x + w / 2, y + 30);
            
            y += 45 + sp.SECTION_HEADER;
            
            const contentStartY = y;
            y += sp.SECTION_PADDING;
            
            this.drawFlame(ctx, x + 30, y - 5, 18);
            ctx.font = 'bold 22px Arial';
            ctx.fillStyle = '#FF6600';
            ctx.textAlign = 'left';
            ctx.fillText('LE MOMENT FEU', x + 60, y);
            y += 24;
            
            ctx.font = '18px Arial';
            ctx.fillStyle = '#333';
            const feuLines = this.wrapText(ctx, `${ai.bestRound.player} a explos√©`, w - 40);
            feuLines.forEach((line, idx) => {
                ctx.fillText(line, x + 20, y + (idx * 20));
            });
            y += feuLines.length * 20 + 4;
            
            ctx.font = 'bold 20px Arial';
            ctx.fillStyle = '#FF6600';
            const mancheLines = this.wrapText(ctx, `‚ñ∂ ${ai.bestRound.score} pts (M${ai.bestRound.round})`, w - 40);
            mancheLines.forEach((line, idx) => {
                ctx.fillText(line, x + 20, y + (idx * 20));
            });
            y += mancheLines.length * 20 + sp.ITEM_SPACING;
            
            ctx.strokeStyle = '#DDDDDD';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(x + 20, y);
            ctx.lineTo(x + w - 20, y);
            ctx.stroke();
            y += sp.ITEM_SPACING;
            
            if (ai.worstRound.score < 0) {
                ctx.font = '28px Arial';
                ctx.fillText('üíÄ', x + 20, y);
                ctx.font = 'bold 22px Arial';
                ctx.fillStyle = '#8B0000';
                ctx.fillText('LE DRAMA', x + 60, y);
                y += 24;
                
                ctx.font = '18px Arial';
                ctx.fillStyle = '#333';
                const dramaLines = this.wrapText(ctx, `${ai.worstRound.player} catastrophique`, w - 40);
                dramaLines.forEach((line, idx) => {
                    ctx.fillText(line, x + 20, y + (idx * 20));
                });
                y += dramaLines.length * 20 + 4;
                
                ctx.font = 'bold 20px Arial';
                ctx.fillStyle = '#8B0000';
                const dramaScoreLines = this.wrapText(ctx, `‚ñ∂ ${ai.worstRound.score} pts (M${ai.worstRound.round})`, w - 40);
                dramaScoreLines.forEach((line, idx) => {
                    ctx.fillText(line, x + 20, y + (idx * 20));
                });
                y += dramaScoreLines.length * 20 + sp.ITEM_SPACING;
            } else {
                ctx.font = '28px Arial';
                ctx.fillText('üéØ', x + 20, y);
                ctx.font = 'bold 22px Arial';
                ctx.fillStyle = '#4CAF50';
                ctx.fillText('EXPLOIT #2', x + 60, y);
                y += 24;
                
                ctx.font = '18px Arial';
                ctx.fillStyle = '#333';
                const exploitLines = this.wrapText(ctx, `${ai.secondBestRound.player} en feu`, w - 40);
                exploitLines.forEach((line, idx) => {
                    ctx.fillText(line, x + 20, y + (idx * 20));
                });
                y += exploitLines.length * 20 + 4;
                
                ctx.font = 'bold 20px Arial';
                ctx.fillStyle = '#4CAF50';
                const exploitScoreLines = this.wrapText(ctx, `‚ñ∂ ${ai.secondBestRound.score} pts (M${ai.secondBestRound.round})`, w - 40);
                exploitScoreLines.forEach((line, idx) => {
                    ctx.fillText(line, x + 20, y + (idx * 20));
                });
                y += exploitScoreLines.length * 20 + sp.ITEM_SPACING;
            }
            
            ctx.strokeStyle = '#DDDDDD';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(x + 20, y);
            ctx.lineTo(x + w - 20, y);
            ctx.stroke();
            y += sp.ITEM_SPACING;
            
            if (ai.bestStreak.count > 1) {
                this.drawLightning(ctx, x + 25, y - 20, 20);
                ctx.font = 'bold 22px Arial';
                ctx.fillStyle = '#FFD700';
                ctx.fillText('LA S√âRIE', x + 60, y);
                y += 24;
                
                ctx.font = '18px Arial';
                ctx.fillStyle = '#333';
                const serieLines = this.wrapText(ctx, `${ai.bestStreak.player} : ${ai.bestStreak.count} victoires`, w - 40);
                serieLines.forEach((line, idx) => {
                    ctx.fillText(line, x + 20, y + (idx * 20));
                });
                y += serieLines.length * 20 + 4;
                
                ctx.font = 'bold 20px Arial';
                ctx.fillStyle = '#FFD700';
                const autoLines = this.wrapText(ctx, '‚ñ∂ Mode auto', w - 40);
                autoLines.forEach((line, idx) => {
                    ctx.fillText(line, x + 20, y + (idx * 20));
                });
                y += autoLines.length * 20 + sp.SECTION_PADDING;
            } else {
                ctx.font = '28px Arial';
                ctx.fillText('üìä', x + 20, y);
                ctx.font = 'bold 22px Arial';
                ctx.fillStyle = colors.primary;
                ctx.fillText('R√âGULARIT√â', x + 60, y);
                y += 24;
                
                ctx.font = '18px Arial';
                ctx.fillStyle = '#333';
                ctx.fillText(`Match √©quilibr√©`, x + 20, y);
                y += 24;
                
                ctx.font = 'bold 20px Arial';
                ctx.fillStyle = colors.primary;
                const manchesLines = this.wrapText(ctx, `‚ñ∂ ${gameState.history.length} manches`, w - 40);
                manchesLines.forEach((line, idx) => {
                    ctx.fillText(line, x + 20, y + (idx * 20));
                });
                y += manchesLines.length * 20 + sp.SECTION_PADDING;
            }
            
            const sectionHeight = y - contentStartY;
            
            ctx.fillStyle = '#FFFFFF';
            ctx.shadowColor = 'rgba(0, 0, 0, 0.15)';
            ctx.shadowBlur = 15;
            ctx.shadowOffsetY = 5;
            ctx.fillRect(x, contentStartY, w, sectionHeight);
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            ctx.shadowOffsetY = 0;
            
            ctx.strokeStyle = '#CCCCCC';
            ctx.lineWidth = 2;
            ctx.strokeRect(x, contentStartY, w, sectionHeight);
            
            y = contentStartY + sp.SECTION_PADDING;
            
            this.drawFlame(ctx, x + 30, y - 5, 18);
            ctx.font = 'bold 22px Arial';
            ctx.fillStyle = '#FF6600';
            ctx.textAlign = 'left';
            ctx.fillText('LE MOMENT FEU', x + 60, y);
            y += 24;
            
            ctx.font = '18px Arial';
            ctx.fillStyle = '#333';
            feuLines.forEach((line, idx) => {
                ctx.fillText(line, x + 20, y + (idx * 20));
            });
            y += feuLines.length * 20 + 4;
            
            ctx.font = 'bold 20px Arial';
            ctx.fillStyle = '#FF6600';
            mancheLines.forEach((line, idx) => {
                ctx.fillText(line, x + 20, y + (idx * 20));
            });
            y += mancheLines.length * 20 + sp.ITEM_SPACING;
            
            ctx.strokeStyle = '#DDDDDD';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(x + 20, y);
            ctx.lineTo(x + w - 20, y);
            ctx.stroke();
            y += sp.ITEM_SPACING;
            
            if (ai.worstRound.score < 0) {
                ctx.font = '28px Arial';
                ctx.fillText('üíÄ', x + 20, y);
                ctx.font = 'bold 22px Arial';
                ctx.fillStyle = '#8B0000';
                ctx.fillText('LE DRAMA', x + 60, y);
                y += 24;
                
                ctx.font = '18px Arial';
                ctx.fillStyle = '#333';
                const dramaLines2 = this.wrapText(ctx, `${ai.worstRound.player} catastrophique`, w - 40);
                dramaLines2.forEach((line, idx) => {
                    ctx.fillText(line, x + 20, y + (idx * 20));
                });
                y += dramaLines2.length * 20 + 4;
                
                ctx.font = 'bold 20px Arial';
                ctx.fillStyle = '#8B0000';
                const dramaScoreLines2 = this.wrapText(ctx, `‚ñ∂ ${ai.worstRound.score} pts (M${ai.worstRound.round})`, w - 40);
                dramaScoreLines2.forEach((line, idx) => {
                    ctx.fillText(line, x + 20, y + (idx * 20));
                });
                y += dramaScoreLines2.length * 20 + sp.ITEM_SPACING;
            } else {
                ctx.font = '28px Arial';
                ctx.fillText('üéØ', x + 20, y);
                ctx.font = 'bold 22px Arial';
                ctx.fillStyle = '#4CAF50';
                ctx.fillText('EXPLOIT #2', x + 60, y);
                y += 24;
                
                ctx.font = '18px Arial';
                ctx.fillStyle = '#333';
                const exploitLines2 = this.wrapText(ctx, `${ai.secondBestRound.player} en feu`, w - 40);
                exploitLines2.forEach((line, idx) => {
                    ctx.fillText(line, x + 20, y + (idx * 20));
                });
                y += exploitLines2.length * 20 + 4;
                
                ctx.font = 'bold 20px Arial';
                ctx.fillStyle = '#4CAF50';
                const exploitScoreLines2 = this.wrapText(ctx, `‚ñ∂ ${ai.secondBestRound.score} pts (M${ai.secondBestRound.round})`, w - 40);
                exploitScoreLines2.forEach((line, idx) => {
                    ctx.fillText(line, x + 20, y + (idx * 20));
                });
                y += exploitScoreLines2.length * 20 + sp.ITEM_SPACING;
            }
            
            ctx.strokeStyle = '#DDDDDD';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(x + 20, y);
            ctx.lineTo(x + w - 20, y);
            ctx.stroke();
            y += sp.ITEM_SPACING;
            
            if (ai.bestStreak.count > 1) {
                this.drawLightning(ctx, x + 25, y - 20, 20);
                ctx.font = 'bold 22px Arial';
                ctx.fillStyle = '#FFD700';
                ctx.fillText('LA S√âRIE', x + 60, y);
                y += 24;
                
                ctx.font = '18px Arial';
                ctx.fillStyle = '#333';
                const serieLines2 = this.wrapText(ctx, `${ai.bestStreak.player} : ${ai.bestStreak.count} victoires`, w - 40);
                serieLines2.forEach((line, idx) => {
                    ctx.fillText(line, x + 20, y + (idx * 20));
                });
                y += serieLines2.length * 20 + 4;
                
                ctx.font = 'bold 20px Arial';
                ctx.fillStyle = '#FFD700';
                const autoLines2 = this.wrapText(ctx, '‚ñ∂ Mode auto', w - 40);
                autoLines2.forEach((line, idx) => {
                    ctx.fillText(line, x + 20, y + (idx * 20));
                });
            } else {
                ctx.font = '28px Arial';
                ctx.fillText('üìä', x + 20, y);
                ctx.font = 'bold 22px Arial';
                ctx.fillStyle = colors.primary;
                ctx.fillText('R√âGULARIT√â', x + 60, y);
                y += 24;
                
                ctx.font = '18px Arial';
                ctx.fillStyle = '#333';
                ctx.fillText(`Match √©quilibr√©`, x + 20, y);
                y += 24;
                
                ctx.font = 'bold 20px Arial';
                ctx.fillStyle = colors.primary;
                const manchesLines2 = this.wrapText(ctx, `‚ñ∂ ${gameState.history.length} manches`, w - 40);
                manchesLines2.forEach((line, idx) => {
                    ctx.fillText(line, x + 20, y + (idx * 20));
                });
            }
            
            return contentStartY + sectionHeight;
        },
        
        drawFlame(ctx, x, y, size) {
            ctx.fillStyle = '#FF6600';
            ctx.beginPath();
            ctx.moveTo(x, y + size);
            ctx.bezierCurveTo(x - size*0.4, y, x - size*0.2, y - size, x, y - size*1.5);
            ctx.bezierCurveTo(x + size*0.2, y - size, x + size*0.4, y, x, y + size);
            ctx.fill();
            
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.arc(x, y - size*0.3, size*0.4, 0, Math.PI * 2);
            ctx.fill();
        },
        
        drawLightning(ctx, x, y, size) {
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x + size*0.3, y + size*0.5);
            ctx.lineTo(x + size*0.15, y + size*0.5);
            ctx.lineTo(x + size*0.4, y + size);
            ctx.lineTo(x - size*0.1, y + size*0.6);
            ctx.lineTo(x + size*0.1, y + size*0.6);
            ctx.closePath();
            ctx.fill();
            
            ctx.strokeStyle = '#FF8C00';
            ctx.lineWidth = 2;
            ctx.stroke();
        },
        
        drawStatsDynamic(ctx, x, y, w, ai, gameState, colors) {
            const sp = this.SPACING;
            const startY = y;
            
            const gradient = ctx.createLinearGradient(x, y, x + w, y);
            gradient.addColorStop(0, colors.primary);
            gradient.addColorStop(1, colors.accent);
            ctx.fillStyle = gradient;
            
            ctx.shadowColor = 'rgba(0, 0, 0, 0.2)';
            ctx.shadowBlur = 10;
            ctx.shadowOffsetY = 3;
            ctx.fillRect(x, y, w, 45);
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            ctx.shadowOffsetY = 0;
            
            ctx.font = 'bold 24px Arial';
            ctx.fillStyle = '#FFFFFF';
            ctx.textAlign = 'center';
            ctx.fillText('üìä LES STATS', x + w / 2, y + 30);
            
            y += 45 + sp.SECTION_HEADER;
            
            const contentStartY = y;
            y += sp.SECTION_PADDING;
            
            ctx.font = '18px Arial';
            ctx.fillStyle = '#333';
            ctx.textAlign = 'left';
            const precision = ai.cast.precision;
            if (precision && precision.length > 0) {
                const topPlayer = precision[0];
                const precisionLines = this.wrapText(ctx, `üéØ Taux victoire : ${topPlayer.name}`, w - 40);
                precisionLines.forEach((line, idx) => {
                    ctx.fillText(line, x + 20, y + (idx * 20));
                });
                y += precisionLines.length * 20 + 4;
                
                this.drawStatBar(ctx, x + 20, y, w - 40, topPlayer.value, 100, colors.primary);
                y += 26;
            }
            
            ctx.strokeStyle = '#EEEEEE';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(x + 20, y);
            ctx.lineTo(x + w - 20, y);
            ctx.stroke();
            y += 18;
            
            ctx.font = '18px Arial';
            ctx.fillStyle = '#333';
            const bestLines = this.wrapText(ctx, `üîß Meilleure : ${ai.bestRound.player}`, w - 40);
            bestLines.forEach((line, idx) => {
                ctx.fillText(line, x + 20, y + (idx * 20));
            });
            y += bestLines.length * 20 + 4;
            
            ctx.font = 'bold 19px Arial';
            ctx.fillStyle = colors.accent;
            ctx.fillText(`${ai.bestRound.score} pts`, x + 20, y);
            y += 24;
            
            ctx.strokeStyle = '#EEEEEE';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(x + 20, y);
            ctx.lineTo(x + w - 20, y);
            ctx.stroke();
            y += 18;
            
            if (ai.worstRound.score < 0) {
                ctx.font = '18px Arial';
                ctx.fillStyle = '#333';
                const worstLines = this.wrapText(ctx, `üíÄ Pire : ${ai.worstRound.player}`, w - 40);
                worstLines.forEach((line, idx) => {
                    ctx.fillText(line, x + 20, y + (idx * 20));
                });
                y += worstLines.length * 20 + 4;
                
                ctx.font = 'bold 19px Arial';
                ctx.fillStyle = '#F44336';
                ctx.fillText(`${ai.worstRound.score} pts`, x + 20, y);
                y += 24;
                
                ctx.strokeStyle = '#EEEEEE';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(x + 20, y);
                ctx.lineTo(x + w - 20, y);
                ctx.stroke();
                y += 18;
            }
            
            if (ai.bestStreak.count > 1) {
                ctx.font = '18px Arial';
                ctx.fillStyle = '#333';
                const streakLines = this.wrapText(ctx, `‚ö° S√©rie : ${ai.bestStreak.player}`, w - 40);
                streakLines.forEach((line, idx) => {
                    ctx.fillText(line, x + 20, y + (idx * 20));
                });
                y += streakLines.length * 20 + 4;
                
                ctx.font = 'bold 19px Arial';
                ctx.fillStyle = colors.secondary;
                ctx.fillText(`${ai.bestStreak.count} victoires`, x + 20, y);
                y += 24;
                
                ctx.strokeStyle = '#EEEEEE';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(x + 20, y);
                ctx.lineTo(x + w - 20, y);
                ctx.stroke();
                y += 18;
            }
            
            ctx.font = '18px Arial';
            ctx.fillStyle = '#333';
            const ecartLines = this.wrapText(ctx, `üéØ √âcart final : ${ai.finalGap} pts`, w - 40);
            ecartLines.forEach((line, idx) => {
                ctx.fillText(line, x + 20, y + (idx * 20));
            });
            y += ecartLines.length * 20 + 22;
            
            ctx.strokeStyle = '#EEEEEE';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(x + 20, y);
            ctx.lineTo(x + w - 20, y);
            ctx.stroke();
            y += 18;
            
            const manchesLines = this.wrapText(ctx, `üìà Manches : ${gameState.history.length}`, w - 40);
            manchesLines.forEach((line, idx) => {
                ctx.fillText(line, x + 20, y + (idx * 20));
            });
            y += manchesLines.length * 20 + sp.SECTION_PADDING;
            
            const sectionHeight = y - contentStartY;
            
            ctx.fillStyle = '#FFFFFF';
            ctx.shadowColor = 'rgba(0, 0, 0, 0.15)';
            ctx.shadowBlur = 15;
            ctx.shadowOffsetY = 5;
            ctx.fillRect(x, contentStartY, w, sectionHeight);
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            ctx.shadowOffsetY = 0;
            
            ctx.strokeStyle = '#CCCCCC';
            ctx.lineWidth = 2;
            ctx.strokeRect(x, contentStartY, w, sectionHeight);
            
            y = contentStartY + sp.SECTION_PADDING;
            
            ctx.font = '18px Arial';
            ctx.fillStyle = '#333';
            ctx.textAlign = 'left';
            if (precision && precision.length > 0) {
                const topPlayer = precision[0];
                const precisionLines2 = this.wrapText(ctx, `üéØ Taux victoire : ${topPlayer.name}`, w - 40);
                precisionLines2.forEach((line, idx) => {
                    ctx.fillText(line, x + 20, y + (idx * 20));
                });
                y += precisionLines2.length * 20 + 4;
                
                this.drawStatBar(ctx, x + 20, y, w - 40, topPlayer.value, 100, colors.primary);
                y += 26;
            }
            
            ctx.strokeStyle = '#EEEEEE';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(x + 20, y);
            ctx.lineTo(x + w - 20, y);
            ctx.stroke();
            y += 18;
            
            ctx.font = '18px Arial';
            ctx.fillStyle = '#333';
            const bestLines2 = this.wrapText(ctx, `üîß Meilleure : ${ai.bestRound.player}`, w - 40);
            bestLines2.forEach((line, idx) => {
                ctx.fillText(line, x + 20, y + (idx * 20));
            });
            y += bestLines2.length * 20 + 4;
            
            ctx.font = 'bold 19px Arial';
            ctx.fillStyle = colors.accent;
            ctx.fillText(`${ai.bestRound.score} pts`, x + 20, y);
            y += 24;
            
            ctx.strokeStyle = '#EEEEEE';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(x + 20, y);
            ctx.lineTo(x + w - 20, y);
            ctx.stroke();
            y += 18;
            
            if (ai.worstRound.score < 0) {
                ctx.font = '18px Arial';
                ctx.fillStyle = '#333';
                const worstLines2 = this.wrapText(ctx, `üíÄ Pire : ${ai.worstRound.player}`, w - 40);
                worstLines2.forEach((line, idx) => {
                    ctx.fillText(line, x + 20, y + (idx * 20));
                });
                y += worstLines2.length * 20 + 4;
                
                ctx.font = 'bold 19px Arial';
                ctx.fillStyle = '#F44336';
                ctx.fillText(`${ai.worstRound.score} pts`, x + 20, y);
                y += 24;
                
                ctx.strokeStyle = '#EEEEEE';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(x + 20, y);
                ctx.lineTo(x + w - 20, y);
                ctx.stroke();
                y += 18;
            }
            
            if (ai.bestStreak.count > 1) {
                ctx.font = '18px Arial';
                ctx.fillStyle = '#333';
                const streakLines2 = this.wrapText(ctx, `‚ö° S√©rie : ${ai.bestStreak.player}`, w - 40);
                streakLines2.forEach((line, idx) => {
                    ctx.fillText(line, x + 20, y + (idx * 20));
                });
                y += streakLines2.length * 20 + 4;
                
                ctx.font = 'bold 19px Arial';
                ctx.fillStyle = colors.secondary;
                ctx.fillText(`${ai.bestStreak.count} victoires`, x + 20, y);
                y += 24;
                
                ctx.strokeStyle = '#EEEEEE';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(x + 20, y);
                ctx.lineTo(x + w - 20, y);
                ctx.stroke();
                y += 18;
            }
            
            ctx.font = '18px Arial';
            ctx.fillStyle = '#333';
            const ecartLines2 = this.wrapText(ctx, `üéØ √âcart final : ${ai.finalGap} pts`, w - 40);
            ecartLines2.forEach((line, idx) => {
                ctx.fillText(line, x + 20, y + (idx * 20));
            });
            y += ecartLines2.length * 20 + 22;
            
            ctx.strokeStyle = '#EEEEEE';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(x + 20, y);
            ctx.lineTo(x + w - 20, y);
            ctx.stroke();
            y += 18;
            
            const manchesLines2 = this.wrapText(ctx, `üìà Manches : ${gameState.history.length}`, w - 40);
            manchesLines2.forEach((line, idx) => {
                ctx.fillText(line, x + 20, y + (idx * 20));
            });
            
            return contentStartY + sectionHeight;
        },
        
        drawStatBar(ctx, x, y, w, value, maxValue, color) {
            ctx.fillStyle = '#E0E0E0';
            ctx.fillRect(x, y, w, 22);
            
            const barWidth = (value / maxValue) * w;
            const gradient = ctx.createLinearGradient(x, y, x + barWidth, y);
            gradient.addColorStop(0, color);
            gradient.addColorStop(1, color + 'AA');
            ctx.fillStyle = gradient;
            ctx.fillRect(x, y, barWidth, 22);
            
            ctx.strokeStyle = '#999';
            ctx.lineWidth = 1;
            ctx.strokeRect(x, y, w, 22);
            
            ctx.font = 'bold 15px Arial';
            ctx.fillStyle = '#000';
            ctx.textAlign = 'center';
            ctx.fillText(`${value}%`, x + w/2, y + 16);
        },
        
        wrapText(ctx, text, maxWidth) {
            const words = text.split(' ');
            const lines = [];
            let line = '';
            
            words.forEach(word => {
                const test = line + word + ' ';
                const metrics = ctx.measureText(test);
                if (metrics.width > maxWidth && line !== '') {
                    lines.push(line.trim());
                    line = word + ' ';
                } else {
                    line = test;
                }
            });
            
            if (line) lines.push(line.trim());
            return lines;
        },
        
        downloadImage(canvas, filename = 'ScoreMaster_Recap_DYNAMIC.png') {
            canvas.toBlob((blob) => {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                a.click();
                URL.revokeObjectURL(url);
            });
        },
        
        async shareImage(canvas) {
            if (!navigator.share || !navigator.canShare) return false;
            
            try {
                const blob = await new Promise(resolve => canvas.toBlob(resolve));
                const file = new File([blob], 'ScoreMaster_Recap_DYNAMIC.png', { type: 'image/png' });
                
                if (navigator.canShare({ files: [file] })) {
                    await navigator.share({
                        files: [file],
                        title: 'ScoreMaster - R√©cap DYNAMIC',
                        text: 'D√©couvrez le r√©cap DYNAMIC ! üèÜ'
                    });
                    return true;
                }
            } catch (error) {
                console.error('Erreur partage:', error);
            }
            
            return false;
        }
    };
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => {
            app.init();
            PWA.init();
        });
    } else {
        app.init();
        PWA.init();
    }
</script>
```

</body>
</html>